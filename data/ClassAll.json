[{"description":"An applet is a small program that is intended not to be run on\r\nits own, but rather to be embedded inside another application.\r\n<p>\r\nThe <code>Applet</code> class must be the superclass of any\r\napplet that is to be embedded in a Web page or viewed by the Java\r\nApplet Viewer. The <code>Applet</code> class provides a standard\r\ninterface between applets and their environment.","inherit":["java.awt.Panel"],"name":"java.applet.Applet","type":false},{"description":"This class implements accessibility support for the\r\n<code>Applet</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to applet user-interface elements.","inherit":["java.awt.Panel.AccessibleAWTPanel"],"name":"java.applet.Applet.AccessibleApplet","type":false},{"description":"This interface corresponds to an applet's environment: the\r\ndocument containing the applet and the other applets in the same\r\ndocument.\r\n<p>\r\nThe methods in this interface can be used by an applet to obtain\r\ninformation about its environment.","inherit":[],"name":"java.applet.AppletContext","type":true},{"description":"When an applet is first created, an applet stub is attached to it\r\nusing the applet's <code>setStub</code> method. This stub\r\nserves as the interface between the applet and the browser\r\nenvironment or applet viewer environment in which the application\r\nis running.","inherit":[],"name":"java.applet.AppletStub","type":true},{"description":"The <code>AudioClip</code> interface is a simple abstraction for\r\nplaying a sound clip. Multiple <code>AudioClip</code> items can be\r\nplaying at the same time, and the resulting sound is mixed\r\ntogether to produce a composite.","inherit":[],"name":"java.applet.AudioClip","type":true},{"description":"An interface for events that know how to dispatch themselves.\r\nBy implementing this interface an event can be placed upon the event\r\nqueue and its <code>dispatch()</code> method will be called when the event\r\nis dispatched, using the <code>EventDispatchThread</code>.\r\n<p>\r\nThis is a very useful mechanism for avoiding deadlocks. If\r\na thread is executing in a critical section (i.e., it has entered\r\none or more monitors), calling other synchronized code may\r\ncause deadlocks. To avoid the potential deadlocks, an\r\n<code>ActiveEvent</code> can be created to run the second section of\r\ncode at later time. If there is contention on the monitor,\r\nthe second thread will simply block until the first thread\r\nhas finished its work and exited its monitors.\r\n<p>\r\nFor security reasons, it is often desirable to use an <code>ActiveEvent</code>\r\nto avoid calling untrusted code from a critical thread. For\r\ninstance, peer implementations can use this facility to avoid\r\nmaking calls into user code from a system thread. Doing so avoids\r\npotential deadlocks and denial-of-service attacks.","inherit":[],"name":"java.awt.ActiveEvent","type":true},{"description":"The interface for objects which have an adjustable numeric value\r\ncontained within a bounded range of values.","inherit":[],"name":"java.awt.Adjustable","type":true},{"description":"","inherit":["java.awt.Composite"],"name":"java.awt.AlphaComposite","type":false},{"description":"","inherit":[],"name":"java.awt.AttributeValue","type":false},{"description":"Thrown when a serious Abstract Window Toolkit error has occurred.","inherit":["java.lang.Error"],"name":"java.awt.AWTError","type":false},{"description":"The root event class for all AWT events.\r\nThis class and its subclasses supercede the original\r\njava.awt.Event class.\r\nSubclasses of this root AWTEvent class defined outside of the\r\njava.awt.event package should define event ID values greater than\r\nthe value defined by RESERVED_ID_MAX.\r\n<p>\r\nThe event masks defined in this class are needed by Component subclasses\r\nwhich are using Component.enableEvents() to select for event types not\r\nselected by registered listeners. If a listener is registered on a\r\ncomponent, the appropriate event mask is already set internally by the\r\ncomponent.\r\n<p>\r\nThe masks are also used to specify to which types of events an\r\nAWTEventListener should listen. The masks are bitwise-ORed together\r\nand passed to Toolkit.addAWTEventListener.","inherit":["java.util.EventObject"],"name":"java.awt.AWTEvent","type":false},{"description":"","inherit":["java.awt.event.ComponentListener","java.awt.event.ContainerListener","java.awt.event.FocusListener","java.awt.event.KeyListener","java.awt.event.MouseListener","java.awt.event.MouseMotionListener","java.awt.event.WindowListener","java.awt.event.WindowFocusListener","java.awt.event.WindowStateListener","java.awt.event.ActionListener","java.awt.event.ItemListener","java.awt.event.AdjustmentListener","java.awt.event.TextListener","java.awt.event.InputMethodListener","java.awt.event.HierarchyListener","java.awt.event.HierarchyBoundsListener","java.awt.event.MouseWheelListener"],"name":"java.awt.AWTEventMulticaster","type":false},{"description":"Signals that an Abstract Window Toolkit exception has occurred.","inherit":["java.lang.Exception"],"name":"java.awt.AWTException","type":false},{"description":"An <code>AWTKeyStroke</code> represents a key action on the\r\nkeyboard, or equivalent input device. <code>AWTKeyStroke</code>s\r\ncan correspond to only a press or release of a\r\nparticular key, just as <code>KEY_PRESSED</code> and\r\n<code>KEY_RELEASED</code> <code>KeyEvent</code>s do;\r\nalternately, they can correspond to typing a specific Java character, just\r\nas <code>KEY_TYPED</code> <code>KeyEvent</code>s do.\r\nIn all cases, <code>AWTKeyStroke</code>s can specify modifiers\r\n(alt, shift, control, meta, altGraph, or a combination thereof) which must be present\r\nduring the action for an exact match.\r\n<p>\r\n<code>AWTKeyStrokes</code> are immutable, and are intended\r\nto be unique. Client code should never create an\r\n<code>AWTKeyStroke</code> on its own, but should instead use\r\na variant of <code>getAWTKeyStroke</code>. Client use of these factory\r\nmethods allows the <code>AWTKeyStroke</code> implementation\r\nto cache and share instances efficiently.","inherit":["java.io.Serializable"],"name":"java.awt.AWTKeyStroke","type":false},{"description":"","inherit":[],"name":"java.awt.VKCollection","type":false},{"description":"","inherit":["java.security.BasicPermission"],"name":"java.awt.AWTPermission","type":false},{"description":"The <code>BasicStroke</code> class defines a basic set of rendering\r\nattributes for the outlines of graphics primitives, which are rendered\r\nwith a {@link Graphics2D} object that has its Stroke attribute set to\r\nthis <code>BasicStroke</code>.\r\nThe rendering attributes defined by <code>BasicStroke</code> describe\r\nthe shape of the mark made by a pen drawn along the outline of a\r\n{@link Shape} and the decorations applied at the ends and joins of\r\npath segments of the <code>Shape</code>.\r\nThese rendering attributes include:\r\n<dl>\r\n<dt><i>width</i>\r\n<dd>The pen width, measured perpendicularly to the pen trajectory.\r\n<dt><i>end caps</i>\r\n<dd>The decoration applied to the ends of unclosed subpaths and\r\ndash segments.  Subpaths that start and end on the same point are\r\nstill considered unclosed if they do not have a CLOSE segment.\r\nSee {@link java.awt.geom.PathIterator#SEG_CLOSE SEG_CLOSE}\r\nfor more information on the CLOSE segment.\r\nThe three different decorations are: {@link #CAP_BUTT},\r\n{@link #CAP_ROUND}, and {@link #CAP_SQUARE}.\r\n<dt><i>line joins</i>\r\n<dd>The decoration applied at the intersection of two path segments\r\nand at the intersection of the endpoints of a subpath that is closed\r\nusing {@link java.awt.geom.PathIterator#SEG_CLOSE SEG_CLOSE}.\r\nThe three different decorations are: {@link #JOIN_BEVEL},\r\n{@link #JOIN_MITER}, and {@link #JOIN_ROUND}.\r\n<dt><i>miter limit</i>\r\n<dd>The limit to trim a line join that has a JOIN_MITER decoration.\r\nA line join is trimmed when the ratio of miter length to stroke\r\nwidth is greater than the miterlimit value.  The miter length is\r\nthe diagonal length of the miter, which is the distance between\r\nthe inside corner and the outside corner of the intersection.\r\nThe smaller the angle formed by two line segments, the longer\r\nthe miter length and the sharper the angle of intersection.  The\r\ndefault miterlimit value of 10.0f causes all angles less than\r\n11 degrees to be trimmed.  Trimming miters converts\r\nthe decoration of the line join to bevel.\r\n<dt><i>dash attributes</i>\r\n<dd>The definition of how to make a dash pattern by alternating\r\nbetween opaque and transparent sections.\r\n</dl>\r\nAll attributes that specify measurements and distances controlling\r\nthe shape of the returned outline are measured in the same\r\ncoordinate system as the original unstroked <code>Shape</code>\r\nargument.  When a <code>Graphics2D</code> object uses a\r\n<code>Stroke</code> object to redefine a path during the execution\r\nof one of its <code>draw</code> methods, the geometry is supplied\r\nin its original form before the <code>Graphics2D</code> transform\r\nattribute is applied.  Therefore, attributes such as the pen width\r\nare interpreted in the user space coordinate system of the\r\n<code>Graphics2D</code> object and are subject to the scaling and\r\nshearing effects of the user-space-to-device-space transform in that\r\nparticular <code>Graphics2D</code>.\r\nFor example, the width of a rendered shape's outline is determined\r\nnot only by the width attribute of this <code>BasicStroke</code>,\r\nbut also by the transform attribute of the\r\n<code>Graphics2D</code> object.  Consider this code:\r\n<blockquote><tt>\r\n     // sets the Graphics2D object's Transform attribute\r\n     g2d.scale(10, 10);\r\n     // sets the Graphics2D object's Stroke attribute\r\n     g2d.setStroke(new BasicStroke(1.5f));\r\n</tt></blockquote>\r\nAssuming there are no other scaling transforms added to the\r\n<code>Graphics2D</code> object, the resulting line\r\nwill be approximately 15 pixels wide.\r\nAs the example code demonstrates, a floating-point line\r\noffers better precision, especially when large transforms are\r\nused with a <code>Graphics2D</code> object.\r\nWhen a line is diagonal, the exact width depends on how the\r\nrendering pipeline chooses which pixels to fill as it traces the\r\ntheoretical widened outline.  The choice of which pixels to turn\r\non is affected by the antialiasing attribute because the\r\nantialiasing rendering pipeline can choose to color\r\npartially-covered pixels.\r\n<p>\r\nFor more information on the user space coordinate system and the\r\nrendering process, see the <code>Graphics2D</code> class comments.","inherit":["java.awt.Stroke"],"name":"java.awt.BasicStroke","type":false},{"description":"A border layout lays out a container, arranging and resizing\r\nits components to fit in five regions:\r\nnorth, south, east, west, and center.\r\nEach region may contain no more than one component, and\r\nis identified by a corresponding constant:\r\n<code>NORTH</code>, <code>SOUTH</code>, <code>EAST</code>,\r\n<code>WEST</code>, and <code>CENTER</code>.  When adding a\r\ncomponent to a container with a border layout, use one of these\r\nfive constants, for example:\r\n<pre>\r\n   Panel p = new Panel();\r\n   p.setLayout(new BorderLayout());\r\n   p.add(new Button(\"Okay\"), BorderLayout.SOUTH);\r\n</pre>\r\nAs a convenience, <code>BorderLayout</code> interprets the\r\nabsence of a string specification the same as the constant\r\n<code>CENTER</code>:\r\n<pre>\r\n   Panel p2 = new Panel();\r\n   p2.setLayout(new BorderLayout());\r\n   p2.add(new TextArea());  // Same as p.add(new TextArea(), BorderLayout.CENTER);\r\n</pre>\r\n<p>\r\nIn addition, <code>BorderLayout</code> supports the relative\r\npositioning constants, <code>PAGE_START</code>, <code>PAGE_END</code>,\r\n<code>LINE_START</code>, and <code>LINE_END</code>.\r\nIn a container whose <code>ComponentOrientation</code> is set to\r\n<code>ComponentOrientation.LEFT_TO_RIGHT</code>, these constants map to\r\n<code>NORTH</code>, <code>SOUTH</code>, <code>WEST</code>, and\r\n<code>EAST</code>, respectively.\r\n<p>\r\nFor compatibility with previous releases, <code>BorderLayout</code>\r\nalso includes the relative positioning constants <code>BEFORE_FIRST_LINE</code>,\r\n<code>AFTER_LAST_LINE</code>, <code>BEFORE_LINE_BEGINS</code> and\r\n<code>AFTER_LINE_ENDS</code>.  These are equivalent to\r\n<code>PAGE_START</code>, <code>PAGE_END</code>, <code>LINE_START</code>\r\nand <code>LINE_END</code> respectively.  For\r\nconsistency with the relative positioning constants used by other\r\ncomponents, the latter constants are preferred.\r\n<p>\r\nMixing both absolute and relative positioning constants can lead to\r\nunpredictable results.  If\r\nyou use both types, the relative constants will take precedence.\r\nFor example, if you add components using both the <code>NORTH</code>\r\nand <code>PAGE_START</code> constants in a container whose\r\norientation is <code>LEFT_TO_RIGHT</code>, only the\r\n<code>PAGE_START</code> will be layed out.\r\n<p>\r\nNOTE: Currently (in the Java 2 platform v1.2),\r\n<code>BorderLayout</code> does not support vertical\r\norientations.  The <code>isVertical</code> setting on the container's\r\n<code>ComponentOrientation</code> is not respected.\r\n<p>\r\nThe components are laid out according to their\r\npreferred sizes and the constraints of the container's size.\r\nThe <code>NORTH</code> and <code>SOUTH</code> components may\r\nbe stretched horizontally; the <code>EAST</code> and\r\n<code>WEST</code> components may be stretched vertically;\r\nthe <code>CENTER</code> component may stretch both horizontally\r\nand vertically to fill any space left over.\r\n<p>\r\nHere is an example of five buttons in an applet laid out using\r\nthe <code>BorderLayout</code> layout manager:\r\n<p>\r\n<img src=\"doc-files/BorderLayout-1.gif\"\r\nalt=\"Diagram of an applet demonstrating BorderLayout.\r\n     Each section of the BorderLayout contains a Button corresponding to its position in the layout, one of:\r\n     North, West, Center, East, or South.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nThe code for this applet is as follows:\r\n\r\n<hr><blockquote><pre>\r\nimport java.awt.*;\r\nimport java.applet.Applet;\r\n\r\npublic class buttonDir extends Applet {\r\n  public void init() {\r\n    setLayout(new BorderLayout());\r\n    add(new Button(\"North\"), BorderLayout.NORTH);\r\n    add(new Button(\"South\"), BorderLayout.SOUTH);\r\n    add(new Button(\"East\"), BorderLayout.EAST);\r\n    add(new Button(\"West\"), BorderLayout.WEST);\r\n    add(new Button(\"Center\"), BorderLayout.CENTER);\r\n  }\r\n}\r\n</pre></blockquote><hr>\r\n<p>","inherit":["java.awt.LayoutManager2","java.io.Serializable"],"name":"java.awt.BorderLayout","type":false},{"description":"Capabilities and properties of buffers.","inherit":["java.lang.Cloneable"],"name":"java.awt.BufferCapabilities","type":false},{"description":"A type-safe enumeration of the possible back buffer contents after\r\npage-flipping","inherit":["java.awt.AttributeValue"],"name":"java.awt.BufferCapabilities.FlipContents","type":false},{"description":"This class creates a labeled button. The application can cause\r\nsome action to happen when the button is pushed. This image\r\ndepicts three views of a \"<code>Quit</code>\" button as it appears\r\nunder the Solaris operating system:\r\n<p>\r\n<img src=\"doc-files/Button-1.gif\" alt=\"The following context describes the graphic\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nThe first view shows the button as it appears normally.\r\nThe second view shows the button\r\nwhen it has input focus. Its outline is darkened to let the\r\nuser know that it is an active object. The third view shows the\r\nbutton when the user clicks the mouse over the button, and thus\r\nrequests that an action be performed.\r\n<p>\r\nThe gesture of clicking on a button with the mouse\r\nis associated with one instance of <code>ActionEvent</code>,\r\nwhich is sent out when the mouse is both pressed and released\r\nover the button. If an application is interested in knowing\r\nwhen the button has been pressed but not released, as a separate\r\ngesture, it can specialize <code>processMouseEvent</code>,\r\nor it can register itself as a listener for mouse events by\r\ncalling <code>addMouseListener</code>. Both of these methods are\r\ndefined by <code>Component</code>, the abstract superclass of\r\nall components.\r\n<p>\r\nWhen a button is pressed and released, AWT sends an instance\r\nof <code>ActionEvent</code> to the button, by calling\r\n<code>processEvent</code> on the button. The button's\r\n<code>processEvent</code> method receives all events\r\nfor the button; it passes an action event along by\r\ncalling its own <code>processActionEvent</code> method.\r\nThe latter method passes the action event on to any action\r\nlisteners that have registered an interest in action\r\nevents generated by this button.\r\n<p>\r\nIf an application wants to perform some action based on\r\na button being pressed and released, it should implement\r\n<code>ActionListener</code> and register the new listener\r\nto receive events from this button, by calling the button's\r\n<code>addActionListener</code> method. The application can\r\nmake use of the button's action command as a messaging protocol.","inherit":["java.awt.Component","javax.accessibility.Accessible"],"name":"java.awt.Button","type":false},{"description":"This class implements accessibility support for the\r\n<code>Button</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to button user-interface elements.","inherit":["java.awt.Component.AccessibleAWTComponent","javax.accessibility.AccessibleAction","javax.accessibility.AccessibleValue"],"name":"java.awt.Button.AccessibleAWTButton","type":false},{"description":"A <code>Canvas</code> component represents a blank rectangular\r\narea of the screen onto which the application can draw or from\r\nwhich the application can trap input events from the user.\r\n<p>\r\nAn application must subclass the <code>Canvas</code> class in\r\norder to get useful functionality such as creating a custom\r\ncomponent. The <code>paint</code> method must be overridden\r\nin order to perform custom graphics on the canvas.","inherit":["java.awt.Component","javax.accessibility.Accessible"],"name":"java.awt.Canvas","type":false},{"description":"This class implements accessibility support for the\r\n<code>Canvas</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to canvas user-interface elements.","inherit":["java.awt.Component.AccessibleAWTComponent"],"name":"java.awt.Canvas.AccessibleAWTCanvas","type":false},{"description":"","inherit":["java.awt.LayoutManager2","java.io.Serializable"],"name":"java.awt.CardLayout","type":false},{"description":"","inherit":["java.io.Serializable"],"name":"java.awt.CardLayout.Card","type":false},{"description":"A check box is a graphical component that can be in either an\r\n\"on\" (<code>true</code>) or \"off\" (<code>false</code>) state.\r\nClicking on a check box changes its state from\r\n\"on\" to \"off,\" or from \"off\" to \"on.\"\r\n<p>\r\nThe following code example creates a set of check boxes in\r\na grid layout:\r\n\r\n<hr><blockquote><pre>\r\nsetLayout(new GridLayout(3, 1));\r\nadd(new Checkbox(\"one\", null, true));\r\nadd(new Checkbox(\"two\"));\r\nadd(new Checkbox(\"three\"));\r\n</pre></blockquote><hr>\r\n<p>\r\nThis image depicts the check boxes and grid layout\r\ncreated by this code example:\r\n<p>\r\n<img src=\"doc-files/Checkbox-1.gif\" alt=\"The following context describes the graphic.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nThe button labeled <code>one</code> is in the \"on\" state, and the\r\nother two are in the \"off\" state. In this example, which uses the\r\n<code>GridLayout</code> class, the states of the three check\r\nboxes are set independently.\r\n<p>\r\nAlternatively, several check boxes can be grouped together under\r\nthe control of a single object, using the\r\n<code>CheckboxGroup</code> class.\r\nIn a check box group, at most one button can be in the \"on\"\r\nstate at any given time. Clicking on a check box to turn it on\r\nforces any other check box in the same group that is on\r\ninto the \"off\" state.","inherit":["java.awt.Component","java.awt.ItemSelectable","javax.accessibility.Accessible"],"name":"java.awt.Checkbox","type":false},{"description":"This class implements accessibility support for the\r\n<code>Checkbox</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to checkbox user-interface elements.","inherit":["java.awt.Component.AccessibleAWTComponent","java.awt.event.ItemListener","javax.accessibility.AccessibleAction","javax.accessibility.AccessibleValue"],"name":"java.awt.Checkbox.AccessibleAWTCheckbox","type":false},{"description":"The <code>CheckboxGroup</code> class is used to group together\r\na set of <code>Checkbox</code> buttons.\r\n<p>\r\nExactly one check box button in a <code>CheckboxGroup</code> can\r\nbe in the \"on\" state at any given time. Pushing any\r\nbutton sets its state to \"on\" and forces any other button that\r\nis in the \"on\" state into the \"off\" state.\r\n<p>\r\nThe following code example produces a new check box group,\r\nwith three check boxes:\r\n\r\n<hr><blockquote><pre>\r\nsetLayout(new GridLayout(3, 1));\r\nCheckboxGroup cbg = new CheckboxGroup();\r\nadd(new Checkbox(\"one\", cbg, true));\r\nadd(new Checkbox(\"two\", cbg, false));\r\nadd(new Checkbox(\"three\", cbg, false));\r\n</pre></blockquote><hr>\r\n<p>\r\nThis image depicts the check box group created by this example:\r\n<p>\r\n<img src=\"doc-files/CheckboxGroup-1.gif\"\r\nalt=\"Shows three checkboxes, arranged vertically, labeled one, two, and three. Checkbox one is in the on state.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>","inherit":["java.io.Serializable"],"name":"java.awt.CheckboxGroup","type":false},{"description":"This class represents a check box that can be included in a menu.\r\nSelecting the check box in the menu changes its state from\r\n\"on\" to \"off\" or from \"off\" to \"on.\"\r\n<p>\r\nThe following picture depicts a menu which contains an instance\r\nof <code>CheckBoxMenuItem</code>:\r\n<p>\r\n<img src=\"doc-files/MenuBar-1.gif\"\r\nalt=\"Menu labeled Examples, containing items Basic, Simple, Check, and More Examples. The Check item is a CheckBoxMenuItem instance, in the off state.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nThe item labeled <code>Check</code> shows a check box menu item\r\nin its \"off\" state.\r\n<p>\r\nWhen a check box menu item is selected, AWT sends an item event to\r\nthe item. Since the event is an instance of <code>ItemEvent</code>,\r\nthe <code>processEvent</code> method examines the event and passes\r\nit along to <code>processItemEvent</code>. The latter method redirects\r\nthe event to any <code>ItemListener</code> objects that have\r\nregistered an interest in item events generated by this menu item.","inherit":["java.awt.MenuItem","java.awt.ItemSelectable","javax.accessibility.Accessible"],"name":"java.awt.CheckboxMenuItem","type":false},{"description":"Inner class of CheckboxMenuItem used to provide default support for\r\naccessibility.  This class is not meant to be used directly by\r\napplication developers, but is instead meant only to be\r\nsubclassed by menu component developers.\r\n<p>\r\nThis class implements accessibility support for the\r\n<code>CheckboxMenuItem</code> class.  It provides an implementation\r\nof the Java Accessibility API appropriate to checkbox menu item\r\nuser-interface elements.","inherit":["java.awt.MenuItem.AccessibleAWTMenuItem","javax.accessibility.AccessibleAction","javax.accessibility.AccessibleValue"],"name":"java.awt.CheckboxMenuItem.AccessibleAWTCheckboxMenuItem","type":false},{"description":"The <code>Choice</code> class presents a pop-up menu of choices.\r\nThe current choice is displayed as the title of the menu.\r\n<p>\r\nThe following code example produces a pop-up menu:\r\n\r\n<hr><blockquote><pre>\r\nChoice ColorChooser = new Choice();\r\nColorChooser.add(\"Green\");\r\nColorChooser.add(\"Red\");\r\nColorChooser.add(\"Blue\");\r\n</pre></blockquote><hr>\r\n<p>\r\nAfter this choice menu has been added to a panel,\r\nit appears as follows in its normal state:\r\n<p>\r\n<img src=\"doc-files/Choice-1.gif\" alt=\"The following text describes the graphic\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nIn the picture, <code>\"Green\"</code> is the current choice.\r\nPushing the mouse button down on the object causes a menu to\r\nappear with the current choice highlighted.\r\n<p>\r\nSome native platforms do not support arbitrary resizing of\r\n<code>Choice</code> components and the behavior of\r\n<code>setSize()/getSize()</code> is bound by\r\nsuch limitations.\r\nNative GUI <code>Choice</code> components' size are often bound by such\r\nattributes as font size and length of items contained within\r\nthe <code>Choice</code>.\r\n<p>","inherit":["java.awt.Component","java.awt.ItemSelectable","javax.accessibility.Accessible"],"name":"java.awt.Choice","type":false},{"description":"This class implements accessibility support for the\r\n<code>Choice</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to choice user-interface elements.","inherit":["java.awt.Component.AccessibleAWTComponent","javax.accessibility.AccessibleAction"],"name":"java.awt.Choice.AccessibleAWTChoice","type":false},{"description":"","inherit":["java.lang.RuntimeException"],"name":"java.awt.color.CMMException","type":false},{"description":"","inherit":["java.io.Serializable"],"name":"java.awt.color.ColorSpace","type":false},{"description":"","inherit":["java.awt.color.ColorSpace"],"name":"java.awt.color.ICC_ColorSpace","type":false},{"description":"","inherit":["java.io.Serializable"],"name":"java.awt.color.ICC_Profile","type":false},{"description":"","inherit":["java.awt.color.ICC_Profile"],"name":"java.awt.color.ICC_ProfileGray","type":false},{"description":"","inherit":["java.awt.color.ICC_Profile"],"name":"java.awt.color.ICC_ProfileRGB","type":false},{"description":"","inherit":["java.lang.RuntimeException"],"name":"java.awt.color.ProfileDataException","type":false},{"description":"The <code>Color</code> class is used to encapsulate colors in the default\r\nsRGB color space or colors in arbitrary color spaces identified by a\r\n{@link ColorSpace}.  Every color has an implicit alpha value of 1.0 or\r\nan explicit one provided in the constructor.  The alpha value\r\ndefines the transparency of a color and can be represented by\r\na float value in the range 0.0&nbsp;-&nbsp;1.0 or 0&nbsp;-&nbsp;255.\r\nAn alpha value of 1.0 or 255 means that the color is completely\r\nopaque and an alpha value of 0 or 0.0 means that the color is\r\ncompletely transparent.\r\nWhen constructing a <code>Color</code> with an explicit alpha or\r\ngetting the color/alpha components of a <code>Color</code>, the color\r\ncomponents are never premultiplied by the alpha component.\r\n<p>\r\nThe default color space for the Java 2D(tm) API is sRGB, a proposed\r\nstandard RGB color space.  For further information on sRGB,\r\nsee <A href=\"http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html\">\r\nhttp://www.w3.org/pub/WWW/Graphics/Color/sRGB.html\r\n</A>.\r\n<p>","inherit":["java.awt.Paint","java.io.Serializable"],"name":"java.awt.Color","type":false},{"description":"","inherit":["java.awt.PaintContext"],"name":"java.awt.ColorPaintContext","type":false},{"description":"A <em>component</em> is an object having a graphical representation\r\nthat can be displayed on the screen and that can interact with the\r\nuser. Examples of components are the buttons, checkboxes, and scrollbars\r\nof a typical graphical user interface. <p>\r\nThe <code>Component</code> class is the abstract superclass of\r\nthe nonmenu-related Abstract Window Toolkit components. Class\r\n<code>Component</code> can also be extended directly to create a\r\nlightweight component. A lightweight component is a component that is\r\nnot associated with a native window. On the contrary, a heavyweight\r\ncomponent is associated with a native window. The {@link #isLightweight()}\r\nmethod may be used to distinguish between the two kinds of the components.\r\n<p>\r\nLightweight and heavyweight components may be mixed in a single component\r\nhierarchy. However, for correct operating of such a mixed hierarchy of\r\ncomponents, the whole hierarchy must be valid. When the hierarchy gets\r\ninvalidated, like after changing the bounds of components, or\r\nadding/removing components to/from containers, the whole hierarchy must be\r\nvalidated afterwards by means of the {@link Container#validate()} method\r\ninvoked on the top-most invalid container of the hierarchy.\r\n\r\n<h3>Serialization</h3>\r\nIt is important to note that only AWT listeners which conform\r\nto the <code>Serializable</code> protocol will be saved when\r\nthe object is stored.  If an AWT object has listeners that\r\naren't marked serializable, they will be dropped at\r\n<code>writeObject</code> time.  Developers will need, as always,\r\nto consider the implications of making an object serializable.\r\nOne situation to watch out for is this:\r\n<pre>\r\n   import java.awt.*;\r\n   import java.awt.event.*;\r\n   import java.io.Serializable;\r\n\r\n   class MyApp implements ActionListener, Serializable\r\n   {\r\n       BigObjectThatShouldNotBeSerializedWithAButton bigOne;\r\n       Button aButton = new Button();\r\n\r\n       MyApp()\r\n       {\r\n           // Oops, now aButton has a listener with a reference\r\n           // to bigOne!\r\n           aButton.addActionListener(this);\r\n       }\r\n\r\n       public void actionPerformed(ActionEvent e)\r\n       {\r\n           System.out.println(\"Hello There\");\r\n       }\r\n   }\r\n</pre>\r\nIn this example, serializing <code>aButton</code> by itself\r\nwill cause <code>MyApp</code> and everything it refers to\r\nto be serialized as well.  The problem is that the listener\r\nis serializable by coincidence, not by design.  To separate\r\nthe decisions about <code>MyApp</code> and the\r\n<code>ActionListener</code> being serializable one can use a\r\nnested class, as in the following example:\r\n<pre>\r\n   import java.awt.*;\r\n   import java.awt.event.*;\r\n   import java.io.Serializable;\r\n\r\n   class MyApp implements java.io.Serializable\r\n   {\r\n        BigObjectThatShouldNotBeSerializedWithAButton bigOne;\r\n        Button aButton = new Button();\r\n\r\n        static class MyActionListener implements ActionListener\r\n        {\r\n            public void actionPerformed(ActionEvent e)\r\n            {\r\n                System.out.println(\"Hello There\");\r\n            }\r\n        }\r\n\r\n        MyApp()\r\n        {\r\n            aButton.addActionListener(new MyActionListener());\r\n        }\r\n   }\r\n</pre>\r\n<p>\r\n<b>Note</b>: For more information on the paint mechanisms utilitized\r\nby AWT and Swing, including information on how to write the most\r\nefficient painting code, see\r\n<a href=\"http://www.oracle.com/technetwork/java/painting-140037.html\">Painting in AWT and Swing</a>.\r\n<p>\r\nFor details on the focus subsystem, see\r\n<a href=\"https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html\">\r\nHow to Use the Focus Subsystem</a>,\r\na section in <em>The Java Tutorial</em>, and the\r\n<a href=\"../../java/awt/doc-files/FocusSpec.html\">Focus Specification</a>\r\nfor more information.","inherit":["java.awt.image.ImageObserver","java.awt.MenuContainer","java.io.Serializable"],"name":"java.awt.Component","type":false},{"description":"","inherit":[],"name":"java.awt.Component.AWTTreeLock","type":false},{"description":"This is a proxy capabilities class used when a FlipBufferStrategy\r\nis created instead of the requested Blit strategy.","inherit":["sun.java2d.pipe.hw.ExtendedBufferCapabilities"],"name":"java.awt.Component.ProxyCapabilities","type":false},{"description":"Inner class for flipping buffers on a component.  That component must\r\nbe a <code>Canvas</code> or <code>Window</code>.","inherit":["java.awt.image.BufferStrategy"],"name":"java.awt.Component.FlipBufferStrategy","type":false},{"description":"Inner class for blitting offscreen surfaces to a component.","inherit":["java.awt.image.BufferStrategy"],"name":"java.awt.Component.BltBufferStrategy","type":false},{"description":"Private class to perform sub-region flipping.","inherit":["java.awt.Component.FlipBufferStrategy","sun.awt.SubRegionShowable"],"name":"java.awt.Component.FlipSubRegionBufferStrategy","type":false},{"description":"Private class to perform sub-region blitting.  Swing will use\r\nthis subclass via the SubRegionShowable interface in order to\r\ncopy only the area changed during a repaint.\r\nSee javax.swing.BufferStrategyPaintManager.","inherit":["java.awt.Component.BltBufferStrategy","sun.awt.SubRegionShowable"],"name":"java.awt.Component.BltSubRegionBufferStrategy","type":false},{"description":"Inner class for flipping buffers on a component.  That component must\r\nbe a <code>Canvas</code> or <code>Window</code>.","inherit":["java.awt.image.BufferStrategy"],"name":"java.awt.Component.SingleBufferStrategy","type":false},{"description":"","inherit":["sun.awt.RequestFocusController"],"name":"java.awt.Component.DummyRequestFocusController","type":false},{"description":"Inner class of Component used to provide default support for\r\naccessibility.  This class is not meant to be used directly by\r\napplication developers, but is instead meant only to be\r\nsubclassed by component developers.\r\n<p>\r\nThe class used to obtain the accessible role for this object.","inherit":["javax.accessibility.AccessibleContext","java.io.Serializable","javax.accessibility.AccessibleComponent"],"name":"java.awt.Component.AccessibleAWTComponent","type":false},{"description":"Fire PropertyChange listener, if one is registered,\r\nwhen shown/hidden..","inherit":["java.awt.event.ComponentListener"],"name":"java.awt.Component.AccessibleAWTComponent.AccessibleAWTComponentHandler","type":false},{"description":"Fire PropertyChange listener, if one is registered,\r\nwhen focus events happen","inherit":["java.awt.event.FocusListener"],"name":"java.awt.Component.AccessibleAWTComponent.AccessibleAWTFocusHandler","type":false},{"description":"The ComponentOrientation class encapsulates the language-sensitive\r\norientation that is to be used to order the elements of a component\r\nor of text. It is used to reflect the differences in this ordering\r\nbetween Western alphabets, Middle Eastern (such as Hebrew), and Far\r\nEastern (such as Japanese).\r\n<p>\r\nFundamentally, this governs items (such as characters) which are laid out\r\nin lines, with the lines then laid out in a block. This also applies\r\nto items in a widget: for example, in a check box where the box is\r\npositioned relative to the text.\r\n<p>\r\nThere are four different orientations used in modern languages\r\nas in the following table.<br>\r\n<pre>\r\nLT          RT          TL          TR\r\nA B C       C B A       A D G       G D A\r\nD E F       F E D       B E H       H E B\r\nG H I       I H G       C F I       I F C\r\n</pre><br>\r\n(In the header, the two-letter abbreviation represents the item direction\r\nin the first letter, and the line direction in the second. For example,\r\nLT means \"items left-to-right, lines top-to-bottom\",\r\nTL means \"items top-to-bottom, lines left-to-right\", and so on.)\r\n<p>\r\nThe orientations are:\r\n<ul>\r\n<li>LT - Western Europe (optional for Japanese, Chinese, Korean)\r\n<li>RT - Middle East (Arabic, Hebrew)\r\n<li>TR - Japanese, Chinese, Korean\r\n<li>TL - Mongolian\r\n</ul>\r\nComponents whose view and controller code depends on orientation\r\nshould use the <code>isLeftToRight()</code> and\r\n<code>isHorizontal()</code> methods to\r\ndetermine their behavior. They should not include switch-like\r\ncode that keys off of the constants, such as:\r\n<pre>\r\nif (orientation == LEFT_TO_RIGHT) {\r\n  ...\r\n} else if (orientation == RIGHT_TO_LEFT) {\r\n  ...\r\n} else {\r\n  // Oops\r\n}\r\n</pre>\r\nThis is unsafe, since more constants may be added in the future and\r\nsince it is not guaranteed that orientation objects will be unique.","inherit":["java.io.Serializable"],"name":"java.awt.ComponentOrientation","type":false},{"description":"The <code>Composite</code> interface, along with\r\n{@link CompositeContext}, defines the methods to compose a draw\r\nprimitive with the underlying graphics area.\r\nAfter the <code>Composite</code> is set in the\r\n{@link Graphics2D} context, it combines a shape, text, or an image\r\nbeing rendered with the colors that have already been rendered\r\naccording to pre-defined rules. The classes\r\nimplementing this interface provide the rules and a method to create\r\nthe context for a particular operation.\r\n<code>CompositeContext</code> is an environment used by the\r\ncompositing operation, which is created by the <code>Graphics2D</code>\r\nprior to the start of the operation.  <code>CompositeContext</code>\r\ncontains private information and resources needed for a compositing\r\noperation.  When the <code>CompositeContext</code> is no longer needed,\r\nthe <code>Graphics2D</code> object disposes of it in order to reclaim\r\nresources allocated for the operation.\r\n<p>\r\nInstances of classes implementing <code>Composite</code> must be\r\nimmutable because the <code>Graphics2D</code> does not clone\r\nthese objects when they are set as an attribute with the\r\n<code>setComposite</code> method or when the <code>Graphics2D</code>\r\nobject is cloned.  This is to avoid undefined rendering behavior of\r\n<code>Graphics2D</code>, resulting from the modification of\r\nthe <code>Composite</code> object after it has been set in the\r\n<code>Graphics2D</code> context.\r\n<p>\r\nSince this interface must expose the contents of pixels on the\r\ntarget device or image to potentially arbitrary code, the use of\r\ncustom objects which implement this interface when rendering directly\r\nto a screen device is governed by the <code>readDisplayPixels</code>\r\n{@link AWTPermission}.  The permission check will occur when such\r\na custom object is passed to the <code>setComposite</code> method\r\nof a <code>Graphics2D</code> retrieved from a {@link Component}.","inherit":[],"name":"java.awt.Composite","type":true},{"description":"","inherit":[],"name":"java.awt.CompositeContext","type":true},{"description":"Conditional is used by the EventDispatchThread's message pumps to\r\ndetermine if a given pump should continue to run, or should instead exit\r\nand yield control to the parent pump.","inherit":[],"name":"java.awt.Conditional","type":true},{"description":"A generic Abstract Window Toolkit(AWT) container object is a component\r\nthat can contain other AWT components.\r\n<p>\r\nComponents added to a container are tracked in a list.  The order\r\nof the list will define the components' front-to-back stacking order\r\nwithin the container.  If no index is specified when adding a\r\ncomponent to a container, it will be added to the end of the list\r\n(and hence to the bottom of the stacking order).\r\n<p>\r\n<b>Note</b>: For details on the focus subsystem, see\r\n<a href=\"https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html\">\r\nHow to Use the Focus Subsystem</a>,\r\na section in <em>The Java Tutorial</em>, and the\r\n<a href=\"../../java/awt/doc-files/FocusSpec.html\">Focus Specification</a>\r\nfor more information.","inherit":["java.awt.Component"],"name":"java.awt.Container","type":false},{"description":"","inherit":[],"name":"java.awt.Container.EventTargetFilter","type":true},{"description":"","inherit":["java.awt.Container.EventTargetFilter"],"name":"java.awt.Container.MouseEventTargetFilter","type":false},{"description":"","inherit":["java.awt.Container.EventTargetFilter"],"name":"java.awt.Container.DropTargetEventTargetFilter","type":false},{"description":"","inherit":["java.lang.Runnable"],"name":"java.awt.Container.WakingRunnable","type":false},{"description":"Inner class of Container used to provide default support for\r\naccessibility.  This class is not meant to be used directly by\r\napplication developers, but is instead meant only to be\r\nsubclassed by container developers.\r\n<p>\r\nThe class used to obtain the accessible role for this object,\r\nas well as implementing many of the methods in the\r\nAccessibleContainer interface.","inherit":["java.awt.Component.AccessibleAWTComponent"],"name":"java.awt.Container.AccessibleAWTContainer","type":false},{"description":"Fire <code>PropertyChange</code> listener, if one is registered,\r\nwhen children are added or removed.","inherit":["java.awt.event.ContainerListener"],"name":"java.awt.Container.AccessibleAWTContainer.AccessibleContainerHandler","type":false},{"description":"Class to manage the dispatching of MouseEvents to the lightweight descendants\r\nand SunDropTargetEvents to both lightweight and heavyweight descendants\r\ncontained by a native container.\r\n\r\nNOTE: the class name is not appropriate anymore, but we cannot change it\r\nbecause we must keep serialization compatibility.","inherit":["java.io.Serializable","java.awt.event.AWTEventListener"],"name":"java.awt.LightweightDispatcher","type":false},{"description":"A FocusTraversalPolicy that determines traversal order based on the order\r\nof child Components in a Container. From a particular focus cycle root, the\r\npolicy makes a pre-order traversal of the Component hierarchy, and traverses\r\na Container's children according to the ordering of the array returned by\r\n<code>Container.getComponents()</code>. Portions of the hierarchy that are\r\nnot visible and displayable will not be searched.\r\n<p>\r\nBy default, ContainerOrderFocusTraversalPolicy implicitly transfers focus\r\ndown-cycle. That is, during normal forward focus traversal, the Component\r\ntraversed after a focus cycle root will be the focus-cycle-root's default\r\nComponent to focus. This behavior can be disabled using the\r\n<code>setImplicitDownCycleTraversal</code> method.\r\n<p>\r\nBy default, methods of this class will return a Component only if it is\r\nvisible, displayable, enabled, and focusable. Subclasses can modify this\r\nbehavior by overriding the <code>accept</code> method.\r\n<p>\r\nThis policy takes into account <a\r\nhref=\"doc-files/FocusSpec.html#FocusTraversalPolicyProviders\">focus traversal\r\npolicy providers</a>.  When searching for first/last/next/previous Component,\r\nif a focus traversal policy provider is encountered, its focus traversal\r\npolicy is used to perform the search operation.","inherit":["java.awt.FocusTraversalPolicy","java.io.Serializable"],"name":"java.awt.ContainerOrderFocusTraversalPolicy","type":false},{"description":"A class to encapsulate the bitmap representation of the mouse cursor.","inherit":["java.io.Serializable"],"name":"java.awt.Cursor","type":false},{"description":"","inherit":["sun.java2d.DisposerRecord"],"name":"java.awt.Cursor.CursorDisposer","type":false},{"description":"A class that implements a mechanism to transfer data using\r\ncut/copy/paste operations.\r\n<p>\r\n{@link FlavorListener}s may be registered on an instance of the\r\nClipboard class to be notified about changes to the set of\r\n{@link DataFlavor}s available on this clipboard (see\r\n{@link #addFlavorListener}).","inherit":[],"name":"java.awt.datatransfer.Clipboard","type":false},{"description":"","inherit":[],"name":"java.awt.datatransfer.ClipboardOwner","type":true},{"description":"A {@code DataFlavor} provides meta information about data. {@code DataFlavor}\r\nis typically used to access data on the clipboard, or during\r\na drag and drop operation.\r\n<p>\r\nAn instance of {@code DataFlavor} encapsulates a content type as\r\ndefined in <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\r\nand <a href=\"http://www.ietf.org/rfc/rfc2046.txt\">RFC 2046</a>.\r\nA content type is typically referred to as a MIME type.\r\n<p>\r\nA content type consists of a media type (referred\r\nto as the primary type), a subtype, and optional parameters. See\r\n<a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\r\nfor details on the syntax of a MIME type.\r\n<p>\r\nThe JRE data transfer implementation interprets the parameter &quot;class&quot;\r\nof a MIME type as <B>a representation class</b>.\r\nThe representation class reflects the class of the object being\r\ntransferred. In other words, the representation class is the type of\r\nobject returned by {@link Transferable#getTransferData}.\r\nFor example, the MIME type of {@link #imageFlavor} is\r\n{@code \"image/x-java-image;class=java.awt.Image\"},\r\nthe primary type is {@code image}, the subtype is\r\n{@code x-java-image}, and the representation class is\r\n{@code java.awt.Image}. When {@code getTransferData} is invoked\r\nwith a {@code DataFlavor} of {@code imageFlavor}, an instance of\r\n{@code java.awt.Image} is returned.\r\nIt's important to note that {@code DataFlavor} does no error checking\r\nagainst the representation class. It is up to consumers of\r\n{@code DataFlavor}, such as {@code Transferable}, to honor the representation\r\nclass.\r\n<br>\r\nNote, if you do not specify a representation class when\r\ncreating a {@code DataFlavor}, the default\r\nrepresentation class is used. See appropriate documentation for\r\n{@code DataFlavor}'s constructors.\r\n<p>\r\nAlso, {@code DataFlavor} instances with the &quot;text&quot; primary\r\nMIME type may have a &quot;charset&quot; parameter. Refer to\r\n<a href=\"http://www.ietf.org/rfc/rfc2046.txt\">RFC 2046</a> and\r\n{@link #selectBestTextFlavor} for details on &quot;text&quot; MIME types\r\nand the &quot;charset&quot; parameter.\r\n<p>\r\nEquality of {@code DataFlavors} is determined by the primary type,\r\nsubtype, and representation class. Refer to {@link #equals(DataFlavor)} for\r\ndetails. When determining equality, any optional parameters are ignored.\r\nFor example, the following produces two {@code DataFlavors} that\r\nare considered identical:\r\n<pre>\r\n  DataFlavor flavor1 = new DataFlavor(Object.class, &quot;X-test/test; class=&lt;java.lang.Object&gt;; foo=bar&quot;);\r\n  DataFlavor flavor2 = new DataFlavor(Object.class, &quot;X-test/test; class=&lt;java.lang.Object&gt;; x=y&quot;);\r\n  // The following returns true.\r\n  flavor1.equals(flavor2);\r\n</pre>\r\nAs mentioned, {@code flavor1} and {@code flavor2} are considered identical.\r\nAs such, asking a {@code Transferable} for either {@code DataFlavor} returns\r\nthe same results.\r\n<p>\r\nFor more information on the using data transfer with Swing see\r\nthe <a href=\"https://docs.oracle.com/javase/tutorial/uiswing/dnd/index.html\">\r\nHow to Use Drag and Drop and Data Transfer</a>,\r\nsection in <em>Java Tutorial</em>.","inherit":["java.io.Externalizable","java.lang.Cloneable"],"name":"java.awt.datatransfer.DataFlavor","type":false},{"description":"","inherit":["sun.awt.datatransfer.DataTransferer.DataFlavorComparator"],"name":"java.awt.datatransfer.DataFlavor.TextFlavorComparator","type":false},{"description":"<code>FlavorEvent</code> is used to notify interested parties\r\nthat available {@link DataFlavor}s have changed in the\r\n{@link Clipboard} (the event source).","inherit":["java.util.EventObject"],"name":"java.awt.datatransfer.FlavorEvent","type":false},{"description":"Defines an object which listens for {@link FlavorEvent}s.","inherit":["java.util.EventListener"],"name":"java.awt.datatransfer.FlavorListener","type":true},{"description":"A two-way Map between \"natives\" (Strings), which correspond to platform-\r\nspecific data formats, and \"flavors\" (DataFlavors), which correspond to\r\nplatform-independent MIME types. FlavorMaps need not be symmetric, but\r\ntypically are.","inherit":[],"name":"java.awt.datatransfer.FlavorMap","type":true},{"description":"A FlavorMap which relaxes the traditional 1-to-1 restriction of a Map. A\r\nflavor is permitted to map to any number of natives, and likewise a native\r\nis permitted to map to any number of flavors. FlavorTables need not be\r\nsymmetric, but typically are.","inherit":["java.awt.datatransfer.FlavorMap"],"name":"java.awt.datatransfer.FlavorTable","type":true},{"description":"A Multipurpose Internet Mail Extension (MIME) type, as defined\r\nin RFC 2045 and 2046.\r\n\r\nTHIS IS *NOT* - REPEAT *NOT* - A PUBLIC CLASS! DataFlavor IS\r\nTHE PUBLIC INTERFACE, AND THIS IS PROVIDED AS A ***PRIVATE***\r\n(THAT IS AS IN *NOT* PUBLIC) HELPER CLASS!","inherit":["java.io.Externalizable","java.lang.Cloneable"],"name":"java.awt.datatransfer.MimeType","type":false},{"description":"An object that encapsulates the parameter list of a MimeType\r\nas defined in RFC 2045 and 2046.","inherit":["java.lang.Cloneable"],"name":"java.awt.datatransfer.MimeTypeParameterList","type":false},{"description":"   A class to encapsulate MimeType parsing related exceptions","inherit":["java.lang.Exception"],"name":"java.awt.datatransfer.MimeTypeParseException","type":false},{"description":"A <code>Transferable</code> which implements the capability required\r\nto transfer a <code>String</code>.\r\n\r\nThis <code>Transferable</code> properly supports\r\n<code>DataFlavor.stringFlavor</code>\r\nand all equivalent flavors. Support for\r\n<code>DataFlavor.plainTextFlavor</code>\r\nand all equivalent flavors is <b>deprecated</b>. No other\r\n<code>DataFlavor</code>s are supported.","inherit":["java.awt.datatransfer.Transferable","java.awt.datatransfer.ClipboardOwner"],"name":"java.awt.datatransfer.StringSelection","type":false},{"description":"The SystemFlavorMap is a configurable map between \"natives\" (Strings), which\r\ncorrespond to platform-specific data formats, and \"flavors\" (DataFlavors),\r\nwhich correspond to platform-independent MIME types. This mapping is used\r\nby the data transfer subsystem to transfer data between Java and native\r\napplications, and between Java applications in separate VMs.\r\n<p>","inherit":["java.awt.datatransfer.FlavorMap","java.awt.datatransfer.FlavorTable"],"name":"java.awt.datatransfer.SystemFlavorMap","type":false},{"description":"","inherit":[],"name":"java.awt.datatransfer.SystemFlavorMap.SoftCache","type":false},{"description":"","inherit":[],"name":"java.awt.datatransfer.Transferable","type":true},{"description":"Signals that the requested data is not supported in this flavor.","inherit":["java.lang.Exception"],"name":"java.awt.datatransfer.UnsupportedFlavorException","type":false},{"description":"A FocusTraversalPolicy that determines traversal order based on the order\r\nof child Components in a Container. From a particular focus cycle root, the\r\npolicy makes a pre-order traversal of the Component hierarchy, and traverses\r\na Container's children according to the ordering of the array returned by\r\n<code>Container.getComponents()</code>. Portions of the hierarchy that are\r\nnot visible and displayable will not be searched.\r\n<p>\r\nIf client code has explicitly set the focusability of a Component by either\r\noverriding <code>Component.isFocusTraversable()</code> or\r\n<code>Component.isFocusable()</code>, or by calling\r\n<code>Component.setFocusable()</code>, then a DefaultFocusTraversalPolicy\r\nbehaves exactly like a ContainerOrderFocusTraversalPolicy. If, however, the\r\nComponent is relying on default focusability, then a\r\nDefaultFocusTraversalPolicy will reject all Components with non-focusable\r\npeers. This is the default FocusTraversalPolicy for all AWT Containers.\r\n<p>\r\nThe focusability of a peer is implementation-dependent. Sun recommends that\r\nall implementations for a particular native platform construct peers with\r\nthe same focusability. The recommendations for Windows and Unix are that\r\nCanvases, Labels, Panels, Scrollbars, ScrollPanes, Windows, and lightweight\r\nComponents have non-focusable peers, and all other Components have focusable\r\npeers. These recommendations are used in the Sun AWT implementations. Note\r\nthat the focusability of a Component's peer is different from, and does not\r\nimpact, the focusability of the Component itself.\r\n<p>\r\nPlease see\r\n<a href=\"https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html\">\r\nHow to Use the Focus Subsystem</a>,\r\na section in <em>The Java Tutorial</em>, and the\r\n<a href=\"../../java/awt/doc-files/FocusSpec.html\">Focus Specification</a>\r\nfor more information.","inherit":["java.awt.ContainerOrderFocusTraversalPolicy"],"name":"java.awt.DefaultFocusTraversalPolicy","type":false},{"description":"The default KeyboardFocusManager for AWT applications. Focus traversal is\r\ndone in response to a Component's focus traversal keys, and using a\r\nContainer's FocusTraversalPolicy.\r\n<p>\r\nPlease see\r\n<a href=\"https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html\">\r\nHow to Use the Focus Subsystem</a>,\r\na section in <em>The Java Tutorial</em>, and the\r\n<a href=\"../../java/awt/doc-files/FocusSpec.html\">Focus Specification</a>\r\nfor more information.","inherit":["java.awt.KeyboardFocusManager"],"name":"java.awt.DefaultKeyboardFocusManager","type":false},{"description":"","inherit":[],"name":"java.awt.DefaultKeyboardFocusManager.TypeAheadMarker","type":false},{"description":"A special type of SentEvent which updates a counter in the target\r\nKeyboardFocusManager if it is an instance of\r\nDefaultKeyboardFocusManager.","inherit":["java.awt.SentEvent"],"name":"java.awt.DefaultKeyboardFocusManager.DefaultKeyboardFocusManagerSentEvent","type":false},{"description":"The {@code Desktop} class allows a Java application to launch\r\nassociated applications registered on the native desktop to handle\r\na {@link java.net.URI} or a file.\r\n\r\n<p> Supported operations include:\r\n<ul>\r\n  <li>launching the user-default browser to show a specified\r\n      URI;</li>\r\n  <li>launching the user-default mail client with an optional\r\n      {@code mailto} URI;</li>\r\n  <li>launching a registered application to open, edit or print a\r\n      specified file.</li>\r\n</ul>\r\n\r\n<p> This class provides methods corresponding to these\r\noperations. The methods look for the associated application\r\nregistered on the current platform, and launch it to handle a URI\r\nor file. If there is no associated application or the associated\r\napplication fails to be launched, an exception is thrown.\r\n\r\n<p> An application is registered to a URI or file type; for\r\nexample, the {@code \"sxi\"} file extension is typically registered\r\nto StarOffice.  The mechanism of registering, accessing, and\r\nlaunching the associated application is platform-dependent.\r\n\r\n<p> Each operation is an action type represented by the {@link\r\nDesktop.Action} class.\r\n\r\n<p> Note: when some action is invoked and the associated\r\napplication is executed, it will be executed on the same system as\r\nthe one on which the Java application was launched.","inherit":[],"name":"java.awt.Desktop","type":false},{"description":"A Dialog is a top-level window with a title and a border\r\nthat is typically used to take some form of input from the user.\r\n\r\nThe size of the dialog includes any area designated for the\r\nborder.  The dimensions of the border area can be obtained\r\nusing the <code>getInsets</code> method, however, since\r\nthese dimensions are platform-dependent, a valid insets\r\nvalue cannot be obtained until the dialog is made displayable\r\nby either calling <code>pack</code> or <code>show</code>.\r\nSince the border area is included in the overall size of the\r\ndialog, the border effectively obscures a portion of the dialog,\r\nconstraining the area available for rendering and/or displaying\r\nsubcomponents to the rectangle which has an upper-left corner\r\nlocation of <code>(insets.left, insets.top)</code>, and has a size of\r\n<code>width - (insets.left + insets.right)</code> by\r\n<code>height - (insets.top + insets.bottom)</code>.\r\n<p>\r\nThe default layout for a dialog is <code>BorderLayout</code>.\r\n<p>\r\nA dialog may have its native decorations (i.e. Frame &amp; Titlebar) turned off\r\nwith <code>setUndecorated</code>.  This can only be done while the dialog\r\nis not {@link Component#isDisplayable() displayable}.\r\n<p>\r\nA dialog may have another window as its owner when it's constructed.  When\r\nthe owner window of a visible dialog is minimized, the dialog will\r\nautomatically be hidden from the user. When the owner window is subsequently\r\nrestored, the dialog is made visible to the user again.\r\n<p>\r\nIn a multi-screen environment, you can create a <code>Dialog</code>\r\non a different screen device than its owner.  See {@link java.awt.Frame} for\r\nmore information.\r\n<p>\r\nA dialog can be either modeless (the default) or modal.  A modal\r\ndialog is one which blocks input to some other top-level windows\r\nin the application, except for any windows created with the dialog\r\nas their owner. See <a href=\"doc-files/Modality.html\">AWT Modality</a>\r\nspecification for details.\r\n<p>\r\nDialogs are capable of generating the following\r\n<code>WindowEvents</code>:\r\n<code>WindowOpened</code>, <code>WindowClosing</code>,\r\n<code>WindowClosed</code>, <code>WindowActivated</code>,\r\n<code>WindowDeactivated</code>, <code>WindowGainedFocus</code>,\r\n<code>WindowLostFocus</code>.","inherit":["java.awt.Window"],"name":"java.awt.Dialog","type":false},{"description":"This class implements accessibility support for the\r\n<code>Dialog</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to dialog user-interface elements.","inherit":["java.awt.Window.AccessibleAWTWindow"],"name":"java.awt.Dialog.AccessibleAWTDialog","type":false},{"description":"The <code>Dimension</code> class encapsulates the width and\r\nheight of a component (in integer precision) in a single object.\r\nThe class is\r\nassociated with certain properties of components. Several methods\r\ndefined by the <code>Component</code> class and the\r\n<code>LayoutManager</code> interface return a\r\n<code>Dimension</code> object.\r\n<p>\r\nNormally the values of <code>width</code>\r\nand <code>height</code> are non-negative integers.\r\nThe constructors that allow you to create a dimension do\r\nnot prevent you from setting a negative value for these properties.\r\nIf the value of <code>width</code> or <code>height</code> is\r\nnegative, the behavior of some methods defined by other objects is\r\nundefined.","inherit":["java.awt.geom.Dimension2D","java.io.Serializable"],"name":"java.awt.Dimension","type":false},{"description":"","inherit":[],"name":"java.awt.DisplayMode","type":false},{"description":"","inherit":[],"name":"java.awt.dnd.Autoscroll","type":true},{"description":"This class contains constant values representing\r\nthe type of action(s) to be performed by a Drag and Drop operation.","inherit":[],"name":"java.awt.dnd.DnDConstants","type":false},{"description":"","inherit":["java.awt.AWTEventMulticaster","java.awt.dnd.DragSourceListener","java.awt.dnd.DragSourceMotionListener"],"name":"java.awt.dnd.DnDEventMulticaster","type":false},{"description":"","inherit":["java.util.EventObject"],"name":"java.awt.dnd.DragGestureEvent","type":false},{"description":"","inherit":["java.util.EventListener"],"name":"java.awt.dnd.DragGestureListener","type":true},{"description":"","inherit":["java.io.Serializable"],"name":"java.awt.dnd.DragGestureRecognizer","type":false},{"description":"","inherit":["java.io.Serializable"],"name":"java.awt.dnd.DragSource","type":false},{"description":"An abstract adapter class for receiving drag source events. The methods in\r\nthis class are empty. This class exists only as a convenience for creating\r\nlistener objects.\r\n<p>\r\nExtend this class to create a <code>DragSourceEvent</code> listener\r\nand override the methods for the events of interest. (If you implement the\r\n<code>DragSourceListener</code> interface, you have to define all of\r\nthe methods in it. This abstract class defines null methods for them\r\nall, so you only have to define methods for events you care about.)\r\n<p>\r\nCreate a listener object using the extended class and then register it with\r\na <code>DragSource</code>. When the drag enters, moves over, or exits\r\na drop site, when the drop action changes, and when the drag ends, the\r\nrelevant method in the listener object is invoked, and the\r\n<code>DragSourceEvent</code> is passed to it.\r\n<p>\r\nThe drop site is <i>associated with the previous <code>dragEnter()</code>\r\ninvocation</i> if the latest invocation of <code>dragEnter()</code> on this\r\nadapter corresponds to that drop site and is not followed by a\r\n<code>dragExit()</code> invocation on this adapter.","inherit":["java.awt.dnd.DragSourceListener","java.awt.dnd.DragSourceMotionListener"],"name":"java.awt.dnd.DragSourceAdapter","type":false},{"description":"","inherit":["java.awt.dnd.DragSourceListener","java.awt.dnd.DragSourceMotionListener","java.io.Serializable"],"name":"java.awt.dnd.DragSourceContext","type":false},{"description":"","inherit":["java.awt.dnd.DragSourceEvent"],"name":"java.awt.dnd.DragSourceDragEvent","type":false},{"description":"","inherit":["java.awt.dnd.DragSourceEvent"],"name":"java.awt.dnd.DragSourceDropEvent","type":false},{"description":"","inherit":["java.util.EventObject"],"name":"java.awt.dnd.DragSourceEvent","type":false},{"description":"","inherit":["java.util.EventListener"],"name":"java.awt.dnd.DragSourceListener","type":true},{"description":"","inherit":["java.util.EventListener"],"name":"java.awt.dnd.DragSourceMotionListener","type":true},{"description":"","inherit":["java.awt.dnd.DropTargetListener","java.io.Serializable"],"name":"java.awt.dnd.DropTarget","type":false},{"description":"","inherit":["java.awt.event.ActionListener"],"name":"java.awt.dnd.DropTarget.DropTargetAutoScroller","type":false},{"description":"An abstract adapter class for receiving drop target events. The methods in\r\nthis class are empty. This class exists only as a convenience for creating\r\nlistener objects.\r\n<p>\r\nExtend this class to create a <code>DropTargetEvent</code> listener\r\nand override the methods for the events of interest. (If you implement the\r\n<code>DropTargetListener</code> interface, you have to define all of\r\nthe methods in it. This abstract class defines a null implementation for\r\nevery method except <code>drop(DropTargetDropEvent)</code>, so you only have\r\nto define methods for events you care about.) You must provide an\r\nimplementation for at least <code>drop(DropTargetDropEvent)</code>. This\r\nmethod cannot have a null implementation because its specification requires\r\nthat you either accept or reject the drop, and, if accepted, indicate\r\nwhether the drop was successful.\r\n<p>\r\nCreate a listener object using the extended class and then register it with\r\na <code>DropTarget</code>. When the drag enters, moves over, or exits\r\nthe operable part of the drop site for that <code>DropTarget</code>, when\r\nthe drop action changes, and when the drop occurs, the relevant method in\r\nthe listener object is invoked, and the <code>DropTargetEvent</code> is\r\npassed to it.\r\n<p>\r\nThe operable part of the drop site for the <code>DropTarget</code> is\r\nthe part of the associated <code>Component</code>'s geometry that is not\r\nobscured by an overlapping top-level window or by another\r\n<code>Component</code> higher in the Z-order that has an associated active\r\n<code>DropTarget</code>.\r\n<p>\r\nDuring the drag, the data associated with the current drag operation can be\r\nretrieved by calling <code>getTransferable()</code> on\r\n<code>DropTargetDragEvent</code> instances passed to the listener's\r\nmethods.\r\n<p>\r\nNote that <code>getTransferable()</code> on the\r\n<code>DropTargetDragEvent</code> instance should only be called within the\r\nrespective listener's method and all the necessary data should be retrieved\r\nfrom the returned <code>Transferable</code> before that method returns.","inherit":["java.awt.dnd.DropTargetListener"],"name":"java.awt.dnd.DropTargetAdapter","type":false},{"description":"","inherit":["java.io.Serializable"],"name":"java.awt.dnd.DropTargetContext","type":false},{"description":"","inherit":["java.awt.datatransfer.Transferable"],"name":"java.awt.dnd.DropTargetContext.TransferableProxy","type":false},{"description":"","inherit":["java.awt.dnd.DropTargetEvent"],"name":"java.awt.dnd.DropTargetDragEvent","type":false},{"description":"","inherit":["java.awt.dnd.DropTargetEvent"],"name":"java.awt.dnd.DropTargetDropEvent","type":false},{"description":"","inherit":["java.util.EventObject"],"name":"java.awt.dnd.DropTargetEvent","type":false},{"description":"","inherit":["java.util.EventListener"],"name":"java.awt.dnd.DropTargetListener","type":true},{"description":"","inherit":["java.lang.IllegalStateException"],"name":"java.awt.dnd.InvalidDnDOperationException","type":false},{"description":"","inherit":["java.awt.dnd.DragGestureRecognizer","java.awt.event.MouseListener","java.awt.event.MouseMotionListener"],"name":"java.awt.dnd.MouseDragGestureRecognizer","type":false},{"description":"","inherit":[],"name":"java.awt.dnd.peer.DragSourceContextPeer","type":true},{"description":"","inherit":[],"name":"java.awt.dnd.peer.DropTargetContextPeer","type":true},{"description":"","inherit":[],"name":"java.awt.dnd.peer.DropTargetPeer","type":true},{"description":"Tests if an object can truly be serialized by serializing it to a null\r\nOutputStream.","inherit":[],"name":"java.awt.dnd.SerializationTester","type":false},{"description":"A semantic event which indicates that a component-defined action occurred.\r\nThis high-level event is generated by a component (such as a\r\n<code>Button</code>) when\r\nthe component-specific action occurs (such as being pressed).\r\nThe event is passed to every <code>ActionListener</code> object\r\nthat registered to receive such events using the component's\r\n<code>addActionListener</code> method.\r\n<p>\r\n<b>Note:</b> To invoke an <code>ActionEvent</code> on a\r\n<code>Button</code> using the keyboard, use the Space bar.\r\n<P>\r\nThe object that implements the <code>ActionListener</code> interface\r\ngets this <code>ActionEvent</code> when the event occurs. The listener\r\nis therefore spared the details of processing individual mouse movements\r\nand mouse clicks, and can instead process a \"meaningful\" (semantic)\r\nevent like \"button pressed\".\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code ActionEvent} instance is not\r\nin the range from {@code ACTION_FIRST} to {@code ACTION_LAST}.","inherit":["java.awt.AWTEvent"],"name":"java.awt.event.ActionEvent","type":false},{"description":"The listener interface for receiving action events.\r\nThe class that is interested in processing an action event\r\nimplements this interface, and the object created with that\r\nclass is registered with a component, using the component's\r\n<code>addActionListener</code> method. When the action event\r\noccurs, that object's <code>actionPerformed</code> method is\r\ninvoked.","inherit":["java.util.EventListener"],"name":"java.awt.event.ActionListener","type":true},{"description":"The adjustment event emitted by Adjustable objects like\r\n{@link java.awt.Scrollbar} and {@link java.awt.ScrollPane}.\r\nWhen the user changes the value of the scrolling component,\r\nit receives an instance of {@code AdjustmentEvent}.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code AdjustmentEvent} instance is not\r\nin the range from {@code ADJUSTMENT_FIRST} to {@code ADJUSTMENT_LAST}.\r\n<p>\r\nThe {@code type} of any {@code AdjustmentEvent} instance takes one of the following\r\nvalues:\r\n                    <ul>\r\n                    <li> {@code UNIT_INCREMENT}\r\n                    <li> {@code UNIT_DECREMENT}\r\n                    <li> {@code BLOCK_INCREMENT}\r\n                    <li> {@code BLOCK_DECREMENT}\r\n                    <li> {@code TRACK}\r\n                    </ul>\r\nAssigning the value different from listed above will cause an unspecified behavior.","inherit":["java.awt.AWTEvent"],"name":"java.awt.event.AdjustmentEvent","type":false},{"description":"The listener interface for receiving adjustment events.","inherit":["java.util.EventListener"],"name":"java.awt.event.AdjustmentListener","type":true},{"description":"The listener interface for receiving notification of events\r\ndispatched to objects that are instances of Component or\r\nMenuComponent or their subclasses.  Unlike the other EventListeners\r\nin this package, AWTEventListeners passively observe events\r\nbeing dispatched in the AWT, system-wide.  Most applications\r\nshould never use this class; applications which might use\r\nAWTEventListeners include event recorders for automated testing,\r\nand facilities such as the Java Accessibility package.\r\n<p>\r\nThe class that is interested in monitoring AWT events\r\nimplements this interface, and the object created with that\r\nclass is registered with the Toolkit, using the Toolkit's\r\n<code>addAWTEventListener</code> method.  When an event is\r\ndispatched anywhere in the AWT, that object's\r\n<code>eventDispatched</code> method is invoked.","inherit":["java.util.EventListener"],"name":"java.awt.event.AWTEventListener","type":true},{"description":"A class which extends the {@code EventListenerProxy}\r\nspecifically for adding an {@code AWTEventListener}\r\nfor a specific event mask.\r\nInstances of this class can be added as {@code AWTEventListener}s\r\nto a {@code Toolkit} object.\r\n<p>\r\nThe {@code getAWTEventListeners} method of {@code Toolkit}\r\ncan return a mixture of {@code AWTEventListener}\r\nand {@code AWTEventListenerProxy} objects.","inherit":["java.util.EventListenerProxy","java.awt.event.AWTEventListener"],"name":"java.awt.event.AWTEventListenerProxy","type":false},{"description":"An abstract adapter class for receiving component events.\r\nThe methods in this class are empty. This class exists as\r\nconvenience for creating listener objects.\r\n<P>\r\nExtend this class to create a <code>ComponentEvent</code> listener\r\nand override the methods for the events of interest. (If you implement the\r\n<code>ComponentListener</code> interface, you have to define all of\r\nthe methods in it. This abstract class defines null methods for them\r\nall, so you can only have to define methods for events you care about.)\r\n<P>\r\nCreate a listener object using your class and then register it with a\r\ncomponent using the component's <code>addComponentListener</code>\r\nmethod. When the component's size, location, or visibility\r\nchanges, the relevant method in the listener object is invoked,\r\nand the <code>ComponentEvent</code> is passed to it.","inherit":["java.awt.event.ComponentListener"],"name":"java.awt.event.ComponentAdapter","type":false},{"description":"A low-level event which indicates that a component moved, changed\r\nsize, or changed visibility (also, the root class for the other\r\ncomponent-level events).\r\n<P>\r\nComponent events are provided for notification purposes ONLY;\r\nThe AWT will automatically handle component moves and resizes\r\ninternally so that GUI layout works properly regardless of\r\nwhether a program is receiving these events or not.\r\n<P>\r\nIn addition to serving as the base class for other component-related\r\nevents (InputEvent, FocusEvent, WindowEvent, ContainerEvent),\r\nthis class defines the events that indicate changes in\r\na component's size, position, or visibility.\r\n<P>\r\nThis low-level event is generated by a component object (such as a\r\nList) when the component is moved, resized, rendered invisible, or made\r\nvisible again. The event is passed to every <code>ComponentListener</code>\r\nor <code>ComponentAdapter</code> object which registered to receive such\r\nevents using the component's <code>addComponentListener</code> method.\r\n(<code>ComponentAdapter</code> objects implement the\r\n<code>ComponentListener</code> interface.) Each such listener object\r\ngets this <code>ComponentEvent</code> when the event occurs.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code ComponentEvent} instance is not\r\nin the range from {@code COMPONENT_FIRST} to {@code COMPONENT_LAST}.","inherit":["java.awt.AWTEvent"],"name":"java.awt.event.ComponentEvent","type":false},{"description":"The listener interface for receiving component events.\r\nThe class that is interested in processing a component event\r\neither implements this interface (and all the methods it\r\ncontains) or extends the abstract <code>ComponentAdapter</code> class\r\n(overriding only the methods of interest).\r\nThe listener object created from that class is then registered with a\r\ncomponent using the component's <code>addComponentListener</code>\r\nmethod. When the component's size, location, or visibility\r\nchanges, the relevant method in the listener object is invoked,\r\nand the <code>ComponentEvent</code> is passed to it.\r\n<P>\r\nComponent events are provided for notification purposes ONLY;\r\nThe AWT will automatically handle component moves and resizes\r\ninternally so that GUI layout works properly regardless of\r\nwhether a program registers a <code>ComponentListener</code> or not.","inherit":["java.util.EventListener"],"name":"java.awt.event.ComponentListener","type":true},{"description":"An abstract adapter class for receiving container events.\r\nThe methods in this class are empty. This class exists as\r\nconvenience for creating listener objects.\r\n<P>\r\nExtend this class to create a <code>ContainerEvent</code> listener\r\nand override the methods for the events of interest. (If you implement the\r\n<code>ContainerListener</code> interface, you have to define all of\r\nthe methods in it. This abstract class defines null methods for them\r\nall, so you can only have to define methods for events you care about.)\r\n<P>\r\nCreate a listener object using the extended class and then register it with\r\na component using the component's <code>addContainerListener</code>\r\nmethod. When the container's contents change because a component has\r\nbeen added or removed, the relevant method in the listener object is invoked,\r\nand the <code>ContainerEvent</code> is passed to it.","inherit":["java.awt.event.ContainerListener"],"name":"java.awt.event.ContainerAdapter","type":false},{"description":"A low-level event which indicates that a container's contents\r\nchanged because a component was added or removed.\r\n<P>\r\nContainer events are provided for notification purposes ONLY;\r\nThe AWT will automatically handle changes to the containers\r\ncontents internally so that the program works properly regardless of\r\nwhether the program is receiving these events or not.\r\n<P>\r\nThis low-level event is generated by a container object (such as a\r\nPanel) when a component is added to it or removed from it.\r\nThe event is passed to every <code>ContainerListener</code>\r\nor <code>ContainerAdapter</code> object which registered to receive such\r\nevents using the component's <code>addContainerListener</code> method.\r\n(<code>ContainerAdapter</code> objects implement the\r\n<code>ContainerListener</code> interface.) Each such listener object\r\ngets this <code>ContainerEvent</code> when the event occurs.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code ContainerEvent} instance is not\r\nin the range from {@code CONTAINER_FIRST} to {@code CONTAINER_LAST}.","inherit":["java.awt.event.ComponentEvent"],"name":"java.awt.event.ContainerEvent","type":false},{"description":"The listener interface for receiving container events.\r\nThe class that is interested in processing a container event\r\neither implements this interface (and all the methods it\r\ncontains) or extends the abstract <code>ContainerAdapter</code> class\r\n(overriding only the methods of interest).\r\nThe listener object created from that class is then registered with a\r\ncomponent using the component's <code>addContainerListener</code>\r\nmethod. When the container's contents change because a component\r\nhas been added or removed, the relevant method in the listener object\r\nis invoked, and the <code>ContainerEvent</code> is passed to it.\r\n<P>\r\nContainer events are provided for notification purposes ONLY;\r\nThe AWT will automatically handle add and remove operations\r\ninternally so the program works properly regardless of\r\nwhether the program registers a {@code ContainerListener} or not.","inherit":["java.util.EventListener"],"name":"java.awt.event.ContainerListener","type":true},{"description":"An abstract adapter class for receiving keyboard focus events.\r\nThe methods in this class are empty. This class exists as\r\nconvenience for creating listener objects.\r\n<P>\r\nExtend this class to create a <code>FocusEvent</code> listener\r\nand override the methods for the events of interest. (If you implement the\r\n<code>FocusListener</code> interface, you have to define all of\r\nthe methods in it. This abstract class defines null methods for them\r\nall, so you can only have to define methods for events you care about.)\r\n<P>\r\nCreate a listener object using the extended class and then register it with\r\na component using the component's <code>addFocusListener</code>\r\nmethod. When the component gains or loses the keyboard focus,\r\nthe relevant method in the listener object is invoked,\r\nand the <code>FocusEvent</code> is passed to it.","inherit":["java.awt.event.FocusListener"],"name":"java.awt.event.FocusAdapter","type":false},{"description":"A low-level event which indicates that a Component has gained or lost the\r\ninput focus. This low-level event is generated by a Component (such as a\r\nTextField). The event is passed to every <code>FocusListener</code> or\r\n<code>FocusAdapter</code> object which registered to receive such events\r\nusing the Component's <code>addFocusListener</code> method. (<code>\r\nFocusAdapter</code> objects implement the <code>FocusListener</code>\r\ninterface.) Each such listener object gets this <code>FocusEvent</code> when\r\nthe event occurs.\r\n<p>\r\nThere are two levels of focus events: permanent and temporary. Permanent\r\nfocus change events occur when focus is directly moved from one Component to\r\nanother, such as through a call to requestFocus() or as the user uses the\r\nTAB key to traverse Components. Temporary focus change events occur when\r\nfocus is temporarily lost for a Component as the indirect result of another\r\noperation, such as Window deactivation or a Scrollbar drag. In this case,\r\nthe original focus state will automatically be restored once that operation\r\nis finished, or, for the case of Window deactivation, when the Window is\r\nreactivated. Both permanent and temporary focus events are delivered using\r\nthe FOCUS_GAINED and FOCUS_LOST event ids; the level may be distinguished in\r\nthe event using the isTemporary() method.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code FocusEvent} instance is not\r\nin the range from {@code FOCUS_FIRST} to {@code FOCUS_LAST}.","inherit":["java.awt.event.ComponentEvent"],"name":"java.awt.event.FocusEvent","type":false},{"description":"The listener interface for receiving keyboard focus events on\r\na component.\r\nThe class that is interested in processing a focus event\r\neither implements this interface (and all the methods it\r\ncontains) or extends the abstract <code>FocusAdapter</code> class\r\n(overriding only the methods of interest).\r\nThe listener object created from that class is then registered with a\r\ncomponent using the component's <code>addFocusListener</code>\r\nmethod. When the component gains or loses the keyboard focus,\r\nthe relevant method in the listener object\r\nis invoked, and the <code>FocusEvent</code> is passed to it.","inherit":["java.util.EventListener"],"name":"java.awt.event.FocusListener","type":true},{"description":"An abstract adapter class for receiving ancestor moved and resized events.\r\nThe methods in this class are empty. This class exists as a\r\nconvenience for creating listener objects.\r\n<p>\r\nExtend this class and override the method for the event of interest. (If\r\nyou implement the <code>HierarchyBoundsListener</code> interface, you have\r\nto define both methods in it. This abstract class defines null methods for\r\nthem both, so you only have to define the method for the event you care\r\nabout.)\r\n<p>\r\nCreate a listener object using your class and then register it with a\r\nComponent using the Component's <code>addHierarchyBoundsListener</code>\r\nmethod. When the hierarchy to which the Component belongs changes by\r\nresize or movement of an ancestor, the relevant method in the listener\r\nobject is invoked, and the <code>HierarchyEvent</code> is passed to it.","inherit":["java.awt.event.HierarchyBoundsListener"],"name":"java.awt.event.HierarchyBoundsAdapter","type":false},{"description":"The listener interface for receiving ancestor moved and resized events.\r\nThe class that is interested in processing these events either implements\r\nthis interface (and all the methods it contains) or extends the abstract\r\n<code>HierarchyBoundsAdapter</code> class (overriding only the method of\r\ninterest).\r\nThe listener object created from that class is then registered with a\r\nComponent using the Component's <code>addHierarchyBoundsListener</code>\r\nmethod. When the hierarchy to which the Component belongs changes by\r\nthe resizing or movement of an ancestor, the relevant method in the listener\r\nobject is invoked, and the <code>HierarchyEvent</code> is passed to it.\r\n<p>\r\nHierarchy events are provided for notification purposes ONLY;\r\nThe AWT will automatically handle changes to the hierarchy internally so\r\nthat GUI layout works properly regardless of whether a\r\nprogram registers an <code>HierarchyBoundsListener</code> or not.","inherit":["java.util.EventListener"],"name":"java.awt.event.HierarchyBoundsListener","type":true},{"description":"An event which indicates a change to the <code>Component</code>\r\nhierarchy to which <code>Component</code> belongs.\r\n<ul>\r\n<li>Hierarchy Change Events (HierarchyListener)\r\n    <ul>\r\n    <li> addition of an ancestor\r\n    <li> removal of an ancestor\r\n    <li> hierarchy made displayable\r\n    <li> hierarchy made undisplayable\r\n    <li> hierarchy shown on the screen (both visible and displayable)\r\n    <li> hierarchy hidden on the screen (either invisible or undisplayable)\r\n    </ul>\r\n<li>Ancestor Reshape Events (HierarchyBoundsListener)\r\n    <ul>\r\n    <li> an ancestor was resized\r\n    <li> an ancestor was moved\r\n    </ul>\r\n</ul>\r\n<p>\r\nHierarchy events are provided for notification purposes ONLY.\r\nThe AWT will automatically handle changes to the hierarchy internally so\r\nthat GUI layout and displayability works properly regardless of whether a\r\nprogram is receiving these events or not.\r\n<p>\r\nThis event is generated by a Container object (such as a Panel) when the\r\nContainer is added, removed, moved, or resized, and passed down the\r\nhierarchy. It is also generated by a Component object when that object's\r\n<code>addNotify</code>, <code>removeNotify</code>, <code>show</code>, or\r\n<code>hide</code> method is called. The {@code ANCESTOR_MOVED} and\r\n{@code ANCESTOR_RESIZED}\r\nevents are dispatched to every <code>HierarchyBoundsListener</code> or\r\n<code>HierarchyBoundsAdapter</code> object which registered to receive\r\nsuch events using the Component's <code>addHierarchyBoundsListener</code>\r\nmethod. (<code>HierarchyBoundsAdapter</code> objects implement the <code>\r\nHierarchyBoundsListener</code> interface.) The {@code HIERARCHY_CHANGED} events are\r\ndispatched to every <code>HierarchyListener</code> object which registered\r\nto receive such events using the Component's <code>addHierarchyListener\r\n</code> method. Each such listener object gets this <code>HierarchyEvent\r\n</code> when the event occurs.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code HierarchyEvent} instance is not\r\nin the range from {@code HIERARCHY_FIRST} to {@code HIERARCHY_LAST}.\r\n<br>\r\nThe {@code changeFlags} parameter of any {@code HierarchyEvent} instance takes one of the following\r\nvalues:\r\n<ul>\r\n<li> {@code HierarchyEvent.PARENT_CHANGED}\r\n<li> {@code HierarchyEvent.DISPLAYABILITY_CHANGED}\r\n<li> {@code HierarchyEvent.SHOWING_CHANGED}\r\n</ul>\r\nAssigning the value different from listed above will cause unspecified behavior.","inherit":["java.awt.AWTEvent"],"name":"java.awt.event.HierarchyEvent","type":false},{"description":"The listener interface for receiving hierarchy changed events.\r\nThe class that is interested in processing a hierarchy changed event\r\nshould implement this interface.\r\nThe listener object created from that class is then registered with a\r\nComponent using the Component's <code>addHierarchyListener</code>\r\nmethod. When the hierarchy to which the Component belongs changes, the\r\n<code>hierarchyChanged</code> method in the listener object is invoked,\r\nand the <code>HierarchyEvent</code> is passed to it.\r\n<p>\r\nHierarchy events are provided for notification purposes ONLY;\r\nThe AWT will automatically handle changes to the hierarchy internally so\r\nthat GUI layout, displayability, and visibility work properly regardless\r\nof whether a program registers a <code>HierarchyListener</code> or not.","inherit":["java.util.EventListener"],"name":"java.awt.event.HierarchyListener","type":true},{"description":"The root event class for all component-level input events.\r\n\r\nInput events are delivered to listeners before they are\r\nprocessed normally by the source where they originated.\r\nThis allows listeners and component subclasses to \"consume\"\r\nthe event so that the source will not process them in their\r\ndefault manner.  For example, consuming mousePressed events\r\non a Button component will prevent the Button from being\r\nactivated.","inherit":["java.awt.event.ComponentEvent"],"name":"java.awt.event.InputEvent","type":false},{"description":"Input method events contain information about text that is being\r\ncomposed using an input method. Whenever the text changes, the\r\ninput method sends an event. If the text component that's currently\r\nusing the input method is an active client, the event is dispatched\r\nto that component. Otherwise, it is dispatched to a separate\r\ncomposition window.\r\n\r\n<p>\r\nThe text included with the input method event consists of two parts:\r\ncommitted text and composed text. Either part may be empty. The two\r\nparts together replace any uncommitted composed text sent in previous events,\r\nor the currently selected committed text.\r\nCommitted text should be integrated into the text component's persistent\r\ndata, it will not be sent again. Composed text may be sent repeatedly,\r\nwith changes to reflect the user's editing operations. Committed text\r\nalways precedes composed text.","inherit":["java.awt.AWTEvent"],"name":"java.awt.event.InputMethodEvent","type":false},{"description":"","inherit":["java.util.EventListener"],"name":"java.awt.event.InputMethodListener","type":true},{"description":"An event which executes the <code>run()</code> method on a <code>Runnable\r\n</code> when dispatched by the AWT event dispatcher thread. This class can\r\nbe used as a reference implementation of <code>ActiveEvent</code> rather\r\nthan declaring a new class and defining <code>dispatch()</code>.<p>\r\n\r\nInstances of this class are placed on the <code>EventQueue</code> by calls\r\nto <code>invokeLater</code> and <code>invokeAndWait</code>. Client code\r\ncan use this fact to write replacement functions for <code>invokeLater\r\n</code> and <code>invokeAndWait</code> without writing special-case code\r\nin any <code>AWTEventListener</code> objects.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code InvocationEvent} instance is not\r\nin the range from {@code INVOCATION_FIRST} to {@code INVOCATION_LAST}.","inherit":["java.awt.AWTEvent","java.awt.ActiveEvent"],"name":"java.awt.event.InvocationEvent","type":false},{"description":"A semantic event which indicates that an item was selected or deselected.\r\nThis high-level event is generated by an ItemSelectable object (such as a\r\nList) when an item is selected or deselected by the user.\r\nThe event is passed to every <code>ItemListener</code> object which\r\nregistered to receive such events using the component's\r\n<code>addItemListener</code> method.\r\n<P>\r\nThe object that implements the <code>ItemListener</code> interface gets\r\nthis <code>ItemEvent</code> when the event occurs. The listener is\r\nspared the details of processing individual mouse movements and mouse\r\nclicks, and can instead process a \"meaningful\" (semantic) event like\r\n\"item selected\" or \"item deselected\".\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code ItemEvent} instance is not\r\nin the range from {@code ITEM_FIRST} to {@code ITEM_LAST}.\r\n<p>\r\nThe {@code stateChange} of any {@code ItemEvent} instance takes one of the following\r\nvalues:\r\n                    <ul>\r\n                    <li> {@code ItemEvent.SELECTED}\r\n                    <li> {@code ItemEvent.DESELECTED}\r\n                    </ul>\r\nAssigning the value different from listed above will cause an unspecified behavior.","inherit":["java.awt.AWTEvent"],"name":"java.awt.event.ItemEvent","type":false},{"description":"The listener interface for receiving item events.\r\nThe class that is interested in processing an item event\r\nimplements this interface. The object created with that\r\nclass is then registered with a component using the\r\ncomponent's <code>addItemListener</code> method. When an\r\nitem-selection event occurs, the listener object's\r\n<code>itemStateChanged</code> method is invoked.","inherit":["java.util.EventListener"],"name":"java.awt.event.ItemListener","type":true},{"description":"An abstract adapter class for receiving keyboard events.\r\nThe methods in this class are empty. This class exists as\r\nconvenience for creating listener objects.\r\n<P>\r\nExtend this class to create a <code>KeyEvent</code> listener\r\nand override the methods for the events of interest. (If you implement the\r\n<code>KeyListener</code> interface, you have to define all of\r\nthe methods in it. This abstract class defines null methods for them\r\nall, so you can only have to define methods for events you care about.)\r\n<P>\r\nCreate a listener object using the extended class and then register it with\r\na component using the component's <code>addKeyListener</code>\r\nmethod. When a key is pressed, released, or typed,\r\nthe relevant method in the listener object is invoked,\r\nand the <code>KeyEvent</code> is passed to it.","inherit":["java.awt.event.KeyListener"],"name":"java.awt.event.KeyAdapter","type":false},{"description":"An event which indicates that a keystroke occurred in a component.\r\n<p>\r\nThis low-level event is generated by a component object (such as a text\r\nfield) when a key is pressed, released, or typed.\r\nThe event is passed to every <code>KeyListener</code>\r\nor <code>KeyAdapter</code> object which registered to receive such\r\nevents using the component's <code>addKeyListener</code> method.\r\n(<code>KeyAdapter</code> objects implement the\r\n<code>KeyListener</code> interface.)  Each such listener object\r\ngets this <code>KeyEvent</code> when the event occurs.\r\n<p>\r\n<em>\"Key typed\" events</em> are higher-level and generally do not depend on\r\nthe platform or keyboard layout.  They are generated when a Unicode character\r\nis entered, and are the preferred way to find out about character input.\r\nIn the simplest case, a key typed event is produced by a single key press\r\n(e.g., 'a').  Often, however, characters are produced by series of key\r\npresses (e.g., 'shift' + 'a'), and the mapping from key pressed events to\r\nkey typed events may be many-to-one or many-to-many.  Key releases are not\r\nusually necessary to generate a key typed event, but there are some cases\r\nwhere the key typed event is not generated until a key is released (e.g.,\r\nentering ASCII sequences via the Alt-Numpad method in Windows).\r\nNo key typed events are generated for keys that don't generate Unicode\r\ncharacters (e.g., action keys, modifier keys, etc.).\r\n<p>\r\nThe getKeyChar method always returns a valid Unicode character or\r\nCHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:\r\nKEY_PRESSED and KEY_RELEASED events are not necessarily associated\r\nwith character input.  Therefore, the result of the getKeyChar method\r\nis guaranteed to be meaningful only for KEY_TYPED events.\r\n<p>\r\nFor key pressed and key released events, the getKeyCode method returns\r\nthe event's keyCode.  For key typed events, the getKeyCode method\r\nalways returns {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method\r\nmay also be used with many international keyboard layouts.\r\n\r\n<p>\r\n<em>\"Key pressed\" and \"key released\" events</em> are lower-level and depend\r\non the platform and keyboard layout. They are generated whenever a key is\r\npressed or released, and are the only way to find out about keys that don't\r\ngenerate character input (e.g., action keys, modifier keys, etc.). The key\r\nbeing pressed or released is indicated by the {@code getKeyCode} and {@code getExtendedKeyCode}\r\nmethods, which return a virtual key code.\r\n\r\n<p>\r\n<em>Virtual key codes</em> are used to report which keyboard key has\r\nbeen pressed, rather than a character generated by the combination\r\nof one or more keystrokes (such as \"A\", which comes from shift and \"a\").\r\n\r\n<p>\r\nFor example, pressing the Shift key will cause a KEY_PRESSED event\r\nwith a VK_SHIFT keyCode, while pressing the 'a' key will result in\r\na VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event\r\nwill be fired with VK_A. Separately, a KEY_TYPED event with a keyChar\r\nvalue of 'A' is generated.\r\n\r\n<p>\r\nPressing and releasing a key on the keyboard results in the generating\r\nthe following key events (in order):\r\n<PRE>\r\n   {@code KEY_PRESSED}\r\n   {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)\r\n   {@code KEY_RELEASED}\r\n</PRE>\r\n\r\nBut in some cases (e.g. auto-repeat or input method is activated) the order\r\ncould be different (and platform dependent).\r\n\r\n<p>\r\nNotes:\r\n<ul>\r\n<li>Key combinations which do not result in Unicode characters, such as action\r\nkeys like F1 and the HELP key, do not generate KEY_TYPED events.\r\n<li>Not all keyboards or systems are capable of generating all\r\nvirtual key codes.  No attempt is made in Java to generate these keys\r\nartificially.\r\n<li>Virtual key codes do not identify a physical key: they depend on the\r\nplatform and keyboard layout. For example, the key that generates VK_Q\r\nwhen using a U.S. keyboard layout will generate VK_A when using a French\r\nkeyboard layout.\r\n<li>The key that generates {@code VK_Q} when using a U.S. keyboard layout also\r\ngenerates a unique code for Russian or Hebrew layout. There is no a\r\n{@code VK_} constant for these and many other codes in various layouts. These codes\r\nmay be obtained by using {@code getExtendedKeyCode} and are used whenever\r\na {@code VK_} constant is used.\r\n<li>Not all characters have a keycode associated with them.  For example,\r\nthere is no keycode for the question mark because there is no keyboard\r\nfor which it appears on the primary layer.\r\n<li>In order to support the platform-independent handling of action keys,\r\nthe Java platform uses a few additional virtual key constants for functions\r\nthat would otherwise have to be recognized by interpreting virtual key codes\r\nand modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES\r\nis returned instead of VK_CONVERT with the ALT modifier.\r\n<li>As specified in <a href=\"../doc-files/FocusSpec.html\">Focus Specification</a>\r\nkey events are dispatched to the focus owner by default.\r\n</ul>\r\n\r\n<p>\r\nWARNING: Aside from those keys that are defined by the Java language\r\n(VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_\r\nconstants.  Sun reserves the right to change these values as needed\r\nto accommodate a wider range of keyboards in the future.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code KeyEvent} instance is not\r\nin the range from {@code KEY_FIRST} to {@code KEY_LAST}.","inherit":["java.awt.event.InputEvent"],"name":"java.awt.event.KeyEvent","type":false},{"description":"The listener interface for receiving keyboard events (keystrokes).\r\nThe class that is interested in processing a keyboard event\r\neither implements this interface (and all the methods it\r\ncontains) or extends the abstract <code>KeyAdapter</code> class\r\n(overriding only the methods of interest).\r\n<P>\r\nThe listener object created from that class is then registered with a\r\ncomponent using the component's <code>addKeyListener</code>\r\nmethod. A keyboard event is generated when a key is pressed, released,\r\nor typed. The relevant method in the listener\r\nobject is then invoked, and the <code>KeyEvent</code> is passed to it.","inherit":["java.util.EventListener"],"name":"java.awt.event.KeyListener","type":true},{"description":"An abstract adapter class for receiving mouse events.\r\nThe methods in this class are empty. This class exists as\r\nconvenience for creating listener objects.\r\n<P>\r\nMouse events let you track when a mouse is pressed, released, clicked,\r\nmoved, dragged, when it enters a component, when it exits and\r\nwhen a mouse wheel is moved.\r\n<P>\r\nExtend this class to create a {@code MouseEvent}\r\n(including drag and motion events) or/and {@code MouseWheelEvent}\r\nlistener and override the methods for the events of interest. (If you implement the\r\n{@code MouseListener},\r\n{@code MouseMotionListener}\r\ninterface, you have to define all of\r\nthe methods in it. This abstract class defines null methods for them\r\nall, so you can only have to define methods for events you care about.)\r\n<P>\r\nCreate a listener object using the extended class and then register it with\r\na component using the component's {@code addMouseListener}\r\n{@code addMouseMotionListener}, {@code addMouseWheelListener}\r\nmethods.\r\nThe relevant method in the listener object is invoked  and the {@code MouseEvent}\r\nor {@code MouseWheelEvent}  is passed to it in following cases:\r\n<ul>\r\n<li>when a mouse button is pressed, released, or clicked (pressed and  released)\r\n<li>when the mouse cursor enters or exits the component\r\n<li>when the mouse wheel rotated, or mouse moved or dragged\r\n</ul>","inherit":["java.awt.event.MouseListener","java.awt.event.MouseWheelListener","java.awt.event.MouseMotionListener"],"name":"java.awt.event.MouseAdapter","type":false},{"description":"An event which indicates that a mouse action occurred in a component.\r\nA mouse action is considered to occur in a particular component if and only\r\nif the mouse cursor is over the unobscured part of the component's bounds\r\nwhen the action happens.\r\nFor lightweight components, such as Swing's components, mouse events\r\nare only dispatched to the component if the mouse event type has been\r\nenabled on the component. A mouse event type is enabled by adding the\r\nappropriate mouse-based {@code EventListener} to the component\r\n({@link MouseListener} or {@link MouseMotionListener}), or by invoking\r\n{@link Component#enableEvents(long)} with the appropriate mask parameter\r\n({@code AWTEvent.MOUSE_EVENT_MASK} or {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}).\r\nIf the mouse event type has not been enabled on the component, the\r\ncorresponding mouse events are dispatched to the first ancestor that\r\nhas enabled the mouse event type.\r\n<p>\r\nFor example, if a {@code MouseListener} has been added to a component, or\r\n{@code enableEvents(AWTEvent.MOUSE_EVENT_MASK)} has been invoked, then all\r\nthe events defined by {@code MouseListener} are dispatched to the component.\r\nOn the other hand, if a {@code MouseMotionListener} has not been added and\r\n{@code enableEvents} has not been invoked with\r\n{@code AWTEvent.MOUSE_MOTION_EVENT_MASK}, then mouse motion events are not\r\ndispatched to the component. Instead the mouse motion events are\r\ndispatched to the first ancestors that has enabled mouse motion\r\nevents.\r\n<P>\r\nThis low-level event is generated by a component object for:\r\n<ul>\r\n<li>Mouse Events\r\n    <ul>\r\n    <li>a mouse button is pressed\r\n    <li>a mouse button is released\r\n    <li>a mouse button is clicked (pressed and released)\r\n    <li>the mouse cursor enters the unobscured part of component's geometry\r\n    <li>the mouse cursor exits the unobscured part of component's geometry\r\n    </ul>\r\n<li> Mouse Motion Events\r\n    <ul>\r\n    <li>the mouse is moved\r\n    <li>the mouse is dragged\r\n    </ul>\r\n</ul>\r\n<P>\r\nA <code>MouseEvent</code> object is passed to every\r\n<code>MouseListener</code>\r\nor <code>MouseAdapter</code> object which is registered to receive\r\nthe \"interesting\" mouse events using the component's\r\n<code>addMouseListener</code> method.\r\n(<code>MouseAdapter</code> objects implement the\r\n<code>MouseListener</code> interface.) Each such listener object\r\ngets a <code>MouseEvent</code> containing the mouse event.\r\n<P>\r\nA <code>MouseEvent</code> object is also passed to every\r\n<code>MouseMotionListener</code> or\r\n<code>MouseMotionAdapter</code> object which is registered to receive\r\nmouse motion events using the component's\r\n<code>addMouseMotionListener</code>\r\nmethod. (<code>MouseMotionAdapter</code> objects implement the\r\n<code>MouseMotionListener</code> interface.) Each such listener object\r\ngets a <code>MouseEvent</code> containing the mouse motion event.\r\n<P>\r\nWhen a mouse button is clicked, events are generated and sent to the\r\nregistered <code>MouseListener</code>s.\r\nThe state of modal keys can be retrieved using {@link InputEvent#getModifiers}\r\nand {@link InputEvent#getModifiersEx}.\r\nThe button mask returned by {@link InputEvent#getModifiers} reflects\r\nonly the button that changed state, not the current state of all buttons.\r\n(Note: Due to overlap in the values of ALT_MASK/BUTTON2_MASK and\r\nMETA_MASK/BUTTON3_MASK, this is not always true for mouse events involving\r\nmodifier keys).\r\nTo get the state of all buttons and modifier keys, use\r\n{@link InputEvent#getModifiersEx}.\r\nThe button which has changed state is returned by {@link MouseEvent#getButton}\r\n<P>\r\nFor example, if the first mouse button is pressed, events are sent in the\r\nfollowing order:\r\n<PRE>\r\n   <b   >id           </b   >   <b   >modifiers   </b   > <b   >button </b   >\r\n   <code>MOUSE_PRESSED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>\r\n   <code>MOUSE_RELEASED</code>: <code>BUTTON1_MASK</code> <code>BUTTON1</code>\r\n   <code>MOUSE_CLICKED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>\r\n</PRE>\r\nWhen multiple mouse buttons are pressed, each press, release, and click\r\nresults in a separate event.\r\n<P>\r\nFor example, if the user presses <b>button 1</b> followed by\r\n<b>button 2</b>, and then releases them in the same order,\r\nthe following sequence of events is generated:\r\n<PRE>\r\n   <b   >id           </b   >   <b   >modifiers   </b   > <b   >button </b   >\r\n   <code>MOUSE_PRESSED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>\r\n   <code>MOUSE_PRESSED</code>:  <code>BUTTON2_MASK</code> <code>BUTTON2</code>\r\n   <code>MOUSE_RELEASED</code>: <code>BUTTON1_MASK</code> <code>BUTTON1</code>\r\n   <code>MOUSE_CLICKED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>\r\n   <code>MOUSE_RELEASED</code>: <code>BUTTON2_MASK</code> <code>BUTTON2</code>\r\n   <code>MOUSE_CLICKED</code>:  <code>BUTTON2_MASK</code> <code>BUTTON2</code>\r\n</PRE>\r\nIf <b>button 2</b> is released first, the\r\n<code>MOUSE_RELEASED</code>/<code>MOUSE_CLICKED</code> pair\r\nfor <code>BUTTON2_MASK</code> arrives first,\r\nfollowed by the pair for <code>BUTTON1_MASK</code>.\r\n<p>\r\nSome extra mouse buttons are added to extend the standard set of buttons\r\nrepresented by the following constants:{@code BUTTON1}, {@code BUTTON2}, and {@code BUTTON3}.\r\nExtra buttons have no assigned {@code BUTTONx}\r\nconstants as well as their button masks have no assigned {@code BUTTONx_DOWN_MASK}\r\nconstants. Nevertheless, ordinal numbers starting from 4 may be\r\nused as button numbers (button ids). Values obtained by the\r\n{@link InputEvent#getMaskForButton(int) getMaskForButton(button)} method may be used\r\nas button masks.\r\n<p>\r\n{@code MOUSE_DRAGGED} events are delivered to the {@code Component}\r\nin which the mouse button was pressed until the mouse button is released\r\n(regardless of whether the mouse position is within the bounds of the\r\n{@code Component}).  Due to platform-dependent Drag&amp;Drop implementations,\r\n{@code MOUSE_DRAGGED} events may not be delivered during a native\r\nDrag&amp;Drop operation.\r\n\r\nIn a multi-screen environment mouse drag events are delivered to the\r\n<code>Component</code> even if the mouse position is outside the bounds of the\r\n<code>GraphicsConfiguration</code> associated with that\r\n<code>Component</code>. However, the reported position for mouse drag events\r\nin this case may differ from the actual mouse position:\r\n<ul>\r\n<li>In a multi-screen environment without a virtual device:\r\n<br>\r\nThe reported coordinates for mouse drag events are clipped to fit within the\r\nbounds of the <code>GraphicsConfiguration</code> associated with\r\nthe <code>Component</code>.\r\n<li>In a multi-screen environment with a virtual device:\r\n<br>\r\nThe reported coordinates for mouse drag events are clipped to fit within the\r\nbounds of the virtual device associated with the <code>Component</code>.\r\n</ul>\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code MouseEvent} instance is not\r\nin the range from {@code MOUSE_FIRST} to {@code MOUSE_LAST}-1\r\n({@code MOUSE_WHEEL} is not acceptable).","inherit":["java.awt.event.InputEvent"],"name":"java.awt.event.MouseEvent","type":false},{"description":"The listener interface for receiving \"interesting\" mouse events\r\n(press, release, click, enter, and exit) on a component.\r\n(To track mouse moves and mouse drags, use the\r\n<code>MouseMotionListener</code>.)\r\n<P>\r\nThe class that is interested in processing a mouse event\r\neither implements this interface (and all the methods it\r\ncontains) or extends the abstract <code>MouseAdapter</code> class\r\n(overriding only the methods of interest).\r\n<P>\r\nThe listener object created from that class is then registered with a\r\ncomponent using the component's <code>addMouseListener</code>\r\nmethod. A mouse event is generated when the mouse is pressed, released\r\nclicked (pressed and released). A mouse event is also generated when\r\nthe mouse cursor enters or leaves a component. When a mouse event\r\noccurs, the relevant method in the listener object is invoked, and\r\nthe <code>MouseEvent</code> is passed to it.","inherit":["java.util.EventListener"],"name":"java.awt.event.MouseListener","type":true},{"description":"An abstract adapter class for receiving mouse motion events.\r\nThe methods in this class are empty. This class exists as\r\nconvenience for creating listener objects.\r\n<P>\r\nMouse motion events occur when a mouse is moved or dragged.\r\n(Many such events will be generated in a normal program.\r\nTo track clicks and other mouse events, use the MouseAdapter.)\r\n<P>\r\nExtend this class to create a <code>MouseEvent</code> listener\r\nand override the methods for the events of interest. (If you implement the\r\n<code>MouseMotionListener</code> interface, you have to define all of\r\nthe methods in it. This abstract class defines null methods for them\r\nall, so you can only have to define methods for events you care about.)\r\n<P>\r\nCreate a listener object using the extended class and then register it with\r\na component using the component's <code>addMouseMotionListener</code>\r\nmethod. When the mouse is moved or dragged, the relevant method in the\r\nlistener object is invoked and the <code>MouseEvent</code> is passed to it.","inherit":["java.awt.event.MouseMotionListener"],"name":"java.awt.event.MouseMotionAdapter","type":false},{"description":"The listener interface for receiving mouse motion events on a component.\r\n(For clicks and other mouse events, use the <code>MouseListener</code>.)\r\n<P>\r\nThe class that is interested in processing a mouse motion event\r\neither implements this interface (and all the methods it\r\ncontains) or extends the abstract <code>MouseMotionAdapter</code> class\r\n(overriding only the methods of interest).\r\n<P>\r\nThe listener object created from that class is then registered with a\r\ncomponent using the component's <code>addMouseMotionListener</code>\r\nmethod. A mouse motion event is generated when the mouse is moved\r\nor dragged. (Many such events will be generated). When a mouse motion event\r\noccurs, the relevant method in the listener object is invoked, and\r\nthe <code>MouseEvent</code> is passed to it.","inherit":["java.util.EventListener"],"name":"java.awt.event.MouseMotionListener","type":true},{"description":"","inherit":["java.awt.event.MouseEvent"],"name":"java.awt.event.MouseWheelEvent","type":false},{"description":"The listener interface for receiving mouse wheel events on a component.\r\n(For clicks and other mouse events, use the <code>MouseListener</code>.\r\nFor mouse movement and drags, use the <code>MouseMotionListener</code>.)\r\n<P>\r\nThe class that is interested in processing a mouse wheel event\r\nimplements this interface (and all the methods it contains).\r\n<P>\r\nThe listener object created from that class is then registered with a\r\ncomponent using the component's <code>addMouseWheelListener</code>\r\nmethod. A mouse wheel event is generated when the mouse wheel is rotated.\r\nWhen a mouse wheel event occurs, that object's <code>mouseWheelMoved</code>\r\nmethod is invoked.\r\n<p>\r\nFor information on how mouse wheel events are dispatched, see\r\nthe class description for {@link MouseWheelEvent}.","inherit":["java.util.EventListener"],"name":"java.awt.event.MouseWheelListener","type":true},{"description":"","inherit":[],"name":"java.awt.event.NativeLibLoader","type":false},{"description":"The component-level paint event.\r\nThis event is a special type which is used to ensure that\r\npaint/update method calls are serialized along with the other\r\nevents delivered from the event queue.  This event is not\r\ndesigned to be used with the Event Listener model; programs\r\nshould continue to override paint/update methods in order\r\nrender themselves properly.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code PaintEvent} instance is not\r\nin the range from {@code PAINT_FIRST} to {@code PAINT_LAST}.","inherit":["java.awt.event.ComponentEvent"],"name":"java.awt.event.PaintEvent","type":false},{"description":"","inherit":["java.awt.AWTEvent"],"name":"java.awt.event.TextEvent","type":false},{"description":"The listener interface for receiving text events.\r\n\r\nThe class that is interested in processing a text event\r\nimplements this interface. The object created with that\r\nclass is then registered with a component using the\r\ncomponent's <code>addTextListener</code> method. When the\r\ncomponent's text changes, the listener object's\r\n<code>textValueChanged</code> method is invoked.","inherit":["java.util.EventListener"],"name":"java.awt.event.TextListener","type":true},{"description":"An abstract adapter class for receiving window events.\r\nThe methods in this class are empty. This class exists as\r\nconvenience for creating listener objects.\r\n<P>\r\nExtend this class to create a <code>WindowEvent</code> listener\r\nand override the methods for the events of interest. (If you implement the\r\n<code>WindowListener</code> interface, you have to define all of\r\nthe methods in it. This abstract class defines null methods for them\r\nall, so you can only have to define methods for events you care about.)\r\n<P>\r\nCreate a listener object using the extended class and then register it with\r\na Window using the window's <code>addWindowListener</code>\r\nmethod. When the window's status changes by virtue of being opened,\r\nclosed, activated or deactivated, iconified or deiconified,\r\nthe relevant method in the listener\r\nobject is invoked, and the <code>WindowEvent</code> is passed to it.","inherit":["java.awt.event.WindowListener","java.awt.event.WindowStateListener","java.awt.event.WindowFocusListener"],"name":"java.awt.event.WindowAdapter","type":false},{"description":"A low-level event that indicates that a window has changed its status. This\r\nlow-level event is generated by a Window object when it is opened, closed,\r\nactivated, deactivated, iconified, or deiconified, or when focus is\r\ntransfered into or out of the Window.\r\n<P>\r\nThe event is passed to every <code>WindowListener</code>\r\nor <code>WindowAdapter</code> object which registered to receive such\r\nevents using the window's <code>addWindowListener</code> method.\r\n(<code>WindowAdapter</code> objects implement the\r\n<code>WindowListener</code> interface.) Each such listener object\r\ngets this <code>WindowEvent</code> when the event occurs.\r\n<p>\r\nAn unspecified behavior will be caused if the {@code id} parameter\r\nof any particular {@code WindowEvent} instance is not\r\nin the range from {@code WINDOW_FIRST} to {@code WINDOW_LAST}.","inherit":["java.awt.event.ComponentEvent"],"name":"java.awt.event.WindowEvent","type":false},{"description":"The listener interface for receiving <code>WindowEvents</code>, including\r\n<code>WINDOW_GAINED_FOCUS</code> and <code>WINDOW_LOST_FOCUS</code> events.\r\nThe class that is interested in processing a <code>WindowEvent</code>\r\neither implements this interface (and\r\nall the methods it contains) or extends the abstract\r\n<code>WindowAdapter</code> class (overriding only the methods of interest).\r\nThe listener object created from that class is then registered with a\r\n<code>Window</code>\r\nusing the <code>Window</code>'s <code>addWindowFocusListener</code> method.\r\nWhen the <code>Window</code>'s\r\nstatus changes by virtue of it being opened, closed, activated, deactivated,\r\niconified, or deiconified, or by focus being transfered into or out of the\r\n<code>Window</code>, the relevant method in the listener object is invoked,\r\nand the <code>WindowEvent</code> is passed to it.","inherit":["java.util.EventListener"],"name":"java.awt.event.WindowFocusListener","type":true},{"description":"The listener interface for receiving window events.\r\nThe class that is interested in processing a window event\r\neither implements this interface (and all the methods it\r\ncontains) or extends the abstract <code>WindowAdapter</code> class\r\n(overriding only the methods of interest).\r\nThe listener object created from that class is then registered with a\r\nWindow using the window's <code>addWindowListener</code>\r\nmethod. When the window's status changes by virtue of being opened,\r\nclosed, activated or deactivated, iconified or deiconified,\r\nthe relevant method in the listener object is invoked, and the\r\n<code>WindowEvent</code> is passed to it.","inherit":["java.util.EventListener"],"name":"java.awt.event.WindowListener","type":true},{"description":"The listener interface for receiving window state events.\r\n<p>\r\nThe class that is interested in processing a window state event\r\neither implements this interface (and all the methods it contains)\r\nor extends the abstract <code>WindowAdapter</code> class\r\n(overriding only the methods of interest).\r\n<p>\r\nThe listener object created from that class is then registered with\r\na window using the <code>Window</code>'s\r\n<code>addWindowStateListener</code> method.  When the window's\r\nstate changes by virtue of being iconified, maximized etc., the\r\n<code>windowStateChanged</code> method in the listener object is\r\ninvoked, and the <code>WindowEvent</code> is passed to it.","inherit":["java.util.EventListener"],"name":"java.awt.event.WindowStateListener","type":true},{"description":"<b>NOTE:</b> The <code>Event</code> class is obsolete and is\r\navailable only for backwards compatibility.  It has been replaced\r\nby the <code>AWTEvent</code> class and its subclasses.\r\n<p>\r\n<code>Event</code> is a platform-independent class that\r\nencapsulates events from the platform's Graphical User\r\nInterface in the Java&nbsp;1.0 event model. In Java&nbsp;1.1\r\nand later versions, the <code>Event</code> class is maintained\r\nonly for backwards compatibility. The information in this\r\nclass description is provided to assist programmers in\r\nconverting Java&nbsp;1.0 programs to the new event model.\r\n<p>\r\nIn the Java&nbsp;1.0 event model, an event contains an\r\n{@link Event#id} field\r\nthat indicates what type of event it is and which other\r\n<code>Event</code> variables are relevant for the event.\r\n<p>\r\nFor keyboard events, {@link Event#key}\r\ncontains a value indicating which key was activated, and\r\n{@link Event#modifiers} contains the\r\nmodifiers for that event.  For the KEY_PRESS and KEY_RELEASE\r\nevent ids, the value of <code>key</code> is the unicode\r\ncharacter code for the key. For KEY_ACTION and\r\nKEY_ACTION_RELEASE, the value of <code>key</code> is\r\none of the defined action-key identifiers in the\r\n<code>Event</code> class (<code>PGUP</code>,\r\n<code>PGDN</code>, <code>F1</code>, <code>F2</code>, etc).","inherit":["java.io.Serializable"],"name":"java.awt.Event","type":false},{"description":"EventDispatchThread is a package-private AWT class which takes\r\nevents off the EventQueue and dispatches them to the appropriate\r\nAWT components.\r\n\r\nThe Thread starts a \"permanent\" event pump with a call to\r\npumpEvents(Conditional) in its run() method. Event handlers can choose to\r\nblock this event pump at any time, but should start a new pump (<b>not</b>\r\na new EventDispatchThread) by again calling pumpEvents(Conditional). This\r\nsecondary event pump will exit automatically as soon as the Condtional\r\nevaluate()s to false and an additional Event is pumped and dispatched.","inherit":["java.lang.Thread"],"name":"java.awt.EventDispatchThread","type":false},{"description":"","inherit":["java.awt.EventFilter"],"name":"java.awt.EventDispatchThread.HierarchyEventFilter","type":false},{"description":"","inherit":[],"name":"java.awt.EventFilter","type":true},{"description":"<code>EventQueue</code> is a platform-independent class\r\nthat queues events, both from the underlying peer classes\r\nand from trusted application classes.\r\n<p>\r\nIt encapsulates asynchronous event dispatch machinery which\r\nextracts events from the queue and dispatches them by calling\r\n{@link #dispatchEvent(AWTEvent) dispatchEvent(AWTEvent)} method\r\non this <code>EventQueue</code> with the event to be dispatched\r\nas an argument.  The particular behavior of this machinery is\r\nimplementation-dependent.  The only requirements are that events\r\nwhich were actually enqueued to this queue (note that events\r\nbeing posted to the <code>EventQueue</code> can be coalesced)\r\nare dispatched:\r\n<dl>\r\n  <dt> Sequentially.\r\n  <dd> That is, it is not permitted that several events from\r\n       this queue are dispatched simultaneously.\r\n  <dt> In the same order as they are enqueued.\r\n  <dd> That is, if <code>AWTEvent</code>&nbsp;A is enqueued\r\n       to the <code>EventQueue</code> before\r\n       <code>AWTEvent</code>&nbsp;B then event B will not be\r\n       dispatched before event A.\r\n</dl>\r\n<p>\r\nSome browsers partition applets in different code bases into\r\nseparate contexts, and establish walls between these contexts.\r\nIn such a scenario, there will be one <code>EventQueue</code>\r\nper context. Other browsers place all applets into the same\r\ncontext, implying that there will be only a single, global\r\n<code>EventQueue</code> for all applets. This behavior is\r\nimplementation-dependent.  Consult your browser's documentation\r\nfor more information.\r\n<p>\r\nFor information on the threading issues of the event dispatch\r\nmachinery, see <a href=\"doc-files/AWTThreadIssues.html#Autoshutdown\"\r\n>AWT Threading Issues</a>.","inherit":[],"name":"java.awt.EventQueue","type":false},{"description":"","inherit":["java.awt.SecondaryLoop"],"name":"java.awt.EventQueue.FwSecondaryLoopWrapper","type":false},{"description":"","inherit":[],"name":"","type":false},{"description":"The Queue object holds pointers to the beginning and end of one internal\r\nqueue. An EventQueue object is composed of multiple internal Queues, one\r\nfor each priority supported by the EventQueue. All Events on a particular\r\ninternal Queue have identical priority.","inherit":[],"name":"java.awt.Queue","type":false},{"description":"The <code>FileDialog</code> class displays a dialog window\r\nfrom which the user can select a file.\r\n<p>\r\nSince it is a modal dialog, when the application calls\r\nits <code>show</code> method to display the dialog,\r\nit blocks the rest of the application until the user has\r\nchosen a file.","inherit":["java.awt.Dialog"],"name":"java.awt.FileDialog","type":false},{"description":"A flow layout arranges components in a directional flow, much\r\nlike lines of text in a paragraph. The flow direction is\r\ndetermined by the container's <code>componentOrientation</code>\r\nproperty and may be one of two values:\r\n<ul>\r\n<li><code>ComponentOrientation.LEFT_TO_RIGHT</code>\r\n<li><code>ComponentOrientation.RIGHT_TO_LEFT</code>\r\n</ul>\r\nFlow layouts are typically used\r\nto arrange buttons in a panel. It arranges buttons\r\nhorizontally until no more buttons fit on the same line.\r\nThe line alignment is determined by the <code>align</code>\r\nproperty. The possible values are:\r\n<ul>\r\n<li>{@link #LEFT LEFT}\r\n<li>{@link #RIGHT RIGHT}\r\n<li>{@link #CENTER CENTER}\r\n<li>{@link #LEADING LEADING}\r\n<li>{@link #TRAILING TRAILING}\r\n</ul>\r\n<p>\r\nFor example, the following picture shows an applet using the flow\r\nlayout manager (its default layout manager) to position three buttons:\r\n<p>\r\n<img src=\"doc-files/FlowLayout-1.gif\"\r\nALT=\"Graphic of Layout for Three Buttons\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nHere is the code for this applet:\r\n\r\n<hr><blockquote><pre>\r\nimport java.awt.*;\r\nimport java.applet.Applet;\r\n\r\npublic class myButtons extends Applet {\r\n    Button button1, button2, button3;\r\n    public void init() {\r\n        button1 = new Button(\"Ok\");\r\n        button2 = new Button(\"Open\");\r\n        button3 = new Button(\"Close\");\r\n        add(button1);\r\n        add(button2);\r\n        add(button3);\r\n    }\r\n}\r\n</pre></blockquote><hr>\r\n<p>\r\nA flow layout lets each component assume its natural (preferred) size.","inherit":["java.awt.LayoutManager","java.io.Serializable"],"name":"java.awt.FlowLayout","type":false},{"description":"A FocusTraversalPolicy defines the order in which Components with a\r\nparticular focus cycle root are traversed. Instances can apply the policy to\r\narbitrary focus cycle roots, allowing themselves to be shared across\r\nContainers. They do not need to be reinitialized when the focus cycle roots\r\nof a Component hierarchy change.\r\n<p>\r\nThe core responsibility of a FocusTraversalPolicy is to provide algorithms\r\ndetermining the next and previous Components to focus when traversing\r\nforward or backward in a UI. Each FocusTraversalPolicy must also provide\r\nalgorithms for determining the first, last, and default Components in a\r\ntraversal cycle. First and last Components are used when normal forward and\r\nbackward traversal, respectively, wraps. The default Component is the first\r\nto receive focus when traversing down into a new focus traversal cycle.\r\nA FocusTraversalPolicy can optionally provide an algorithm for determining\r\na Window's initial Component. The initial Component is the first to receive\r\nfocus when a Window is first made visible.\r\n<p>\r\nFocusTraversalPolicy takes into account <a\r\nhref=\"doc-files/FocusSpec.html#FocusTraversalPolicyProviders\">focus traversal\r\npolicy providers</a>.  When searching for first/last/next/previous Component,\r\nif a focus traversal policy provider is encountered, its focus traversal\r\npolicy is used to perform the search operation.\r\n<p>\r\nPlease see\r\n<a href=\"https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html\">\r\nHow to Use the Focus Subsystem</a>,\r\na section in <em>The Java Tutorial</em>, and the\r\n<a href=\"../../java/awt/doc-files/FocusSpec.html\">Focus Specification</a>\r\nfor more information.","inherit":[],"name":"java.awt.FocusTraversalPolicy","type":false},{"description":"","inherit":["java.text.CharacterIterator"],"name":"java.awt.font.CharArrayIterator","type":false},{"description":"","inherit":[],"name":"java.awt.font.FontRenderContext","type":false},{"description":"","inherit":[],"name":"java.awt.font.GlyphJustificationInfo","type":false},{"description":"","inherit":[],"name":"java.awt.font.GlyphMetrics","type":false},{"description":"","inherit":["java.lang.Cloneable"],"name":"java.awt.font.GlyphVector","type":false},{"description":"This class is used with the CHAR_REPLACEMENT attribute.\r\n<p>\r\nThe <code>GraphicAttribute</code> class represents a graphic embedded\r\nin text. Clients subclass this class to implement their own char\r\nreplacement graphics.  Clients wishing to embed shapes and images in\r\ntext need not subclass this class.  Instead, clients can use the\r\n{@link ShapeGraphicAttribute} and {@link ImageGraphicAttribute}\r\nclasses.\r\n<p>\r\nSubclasses must ensure that their objects are immutable once they\r\nare constructed.  Mutating a <code>GraphicAttribute</code> that\r\nis used in a {@link TextLayout} results in undefined behavior from the\r\n<code>TextLayout</code>.","inherit":[],"name":"java.awt.font.GraphicAttribute","type":false},{"description":"","inherit":["java.awt.font.GraphicAttribute"],"name":"java.awt.font.ImageGraphicAttribute","type":false},{"description":"LayoutPath provides a mapping between locations relative to the\r\nbaseline and points in user space.  Locations consist of an advance\r\nalong the baseline, and an offset perpendicular to the baseline at\r\nthe advance.  Positive values along the perpendicular are in the\r\ndirection that is 90 degrees clockwise from the baseline vector.\r\nLocations are represented as a <code>Point2D</code>, where x is the advance and\r\ny is the offset.","inherit":[],"name":"java.awt.font.LayoutPath","type":false},{"description":"","inherit":[],"name":"java.awt.font.LineBreakMeasurer","type":false},{"description":"","inherit":[],"name":"java.awt.font.LineMetrics","type":false},{"description":"The <code>MultipleMaster</code> interface represents Type 1\r\nMultiple Master fonts.\r\nA particular {@link Font} object can implement this interface.","inherit":[],"name":"java.awt.font.MultipleMaster","type":true},{"description":"","inherit":["java.io.Serializable"],"name":"java.awt.font.NumericShaper","type":false},{"description":"The <code>OpenType</code> interface represents OpenType and\r\nTrueType fonts.  This interface makes it possible to obtain\r\n<i>sfnt</i> tables from the font.  A particular\r\n<code>Font</code> object can implement this interface.\r\n<p>\r\nFor more information on TrueType and OpenType fonts, see the\r\nOpenType specification.\r\n( <a href=\"http://www.microsoft.com/typography/otspec/\">http://www.microsoft.com/typography/otspec/</a> ).","inherit":[],"name":"java.awt.font.OpenType","type":true},{"description":"The <code>ShapeGraphicAttribute</code> class is an implementation of\r\n{@link GraphicAttribute} that draws shapes in a {@link TextLayout}.","inherit":["java.awt.font.GraphicAttribute"],"name":"java.awt.font.ShapeGraphicAttribute","type":false},{"description":"This class stores Font, GraphicAttribute, and Decoration intervals\r\non a paragraph of styled text.\r\n<p>\r\nCurrently, this class is optimized for a small number of intervals\r\n(preferrably 1).","inherit":[],"name":"java.awt.font.StyledParagraph","type":false},{"description":"The <code>TextAttribute</code> class defines attribute keys and\r\nattribute values used for text rendering.\r\n<p>\r\n<code>TextAttribute</code> instances are used as attribute keys to\r\nidentify attributes in\r\n{@link java.awt.Font Font},\r\n{@link java.awt.font.TextLayout TextLayout},\r\n{@link java.text.AttributedCharacterIterator AttributedCharacterIterator},\r\nand other classes handling text attributes. Other constants defined\r\nin this class can be used as attribute values.\r\n<p>\r\nFor each text attribute, the documentation provides:\r\n<UL>\r\n  <LI>the type of its value,\r\n  <LI>the relevant predefined constants, if any\r\n  <LI>the default effect if the attribute is absent\r\n  <LI>the valid values if there are limitations\r\n  <LI>a description of the effect.\r\n</UL>\r\n<p>\r\n<H3>Values</H3>\r\n<UL>\r\n  <LI>The values of attributes must always be immutable.\r\n  <LI>Where value limitations are given, any value outside of that\r\n  set is reserved for future use; the value will be treated as\r\n  the default.\r\n  <LI>The value <code>null</code> is treated the same as the\r\n  default value and results in the default behavior.\r\n  <li>If the value is not of the proper type, the attribute\r\n  will be ignored.\r\n  <li>The identity of the value does not matter, only the actual\r\n  value.  For example, <code>TextAttribute.WEIGHT_BOLD</code> and\r\n  <code>new Float(2.0)</code>\r\n  indicate the same <code>WEIGHT</code>.\r\n  <li>Attribute values of type <code>Number</code> (used for\r\n  <code>WEIGHT</code>, <code>WIDTH</code>, <code>POSTURE</code>,\r\n  <code>SIZE</code>, <code>JUSTIFICATION</code>, and\r\n  <code>TRACKING</code>) can vary along their natural range and are\r\n  not restricted to the predefined constants.\r\n  <code>Number.floatValue()</code> is used to get the actual value\r\n  from the <code>Number</code>.\r\n  <li>The values for <code>WEIGHT</code>, <code>WIDTH</code>, and\r\n  <code>POSTURE</code> are interpolated by the system, which\r\n  can select the 'nearest available' font or use other techniques to\r\n  approximate the user's request.\r\n\r\n</UL>\r\n\r\n<h4>Summary of attributes</h4>\r\n<p>\r\n<table style=\"float:center\" border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"%95\"\r\n    summary=\"Key, value type, principal constants, and default value\r\n    behavior of all TextAttributes\">\r\n<tr style=\"background-color:#ccccff\">\r\n<th valign=\"TOP\" align=\"CENTER\">Key</th>\r\n<th valign=\"TOP\" align=\"CENTER\">Value Type</th>\r\n<th valign=\"TOP\" align=\"CENTER\">Principal Constants</th>\r\n<th valign=\"TOP\" align=\"CENTER\">Default Value</th>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #FAMILY}</td>\r\n<td valign=\"TOP\">String</td>\r\n<td valign=\"TOP\">See Font {@link java.awt.Font#DIALOG DIALOG},\r\n{@link java.awt.Font#DIALOG_INPUT DIALOG_INPUT},<br> {@link java.awt.Font#SERIF SERIF},\r\n{@link java.awt.Font#SANS_SERIF SANS_SERIF}, and {@link java.awt.Font#MONOSPACED MONOSPACED}.\r\n</td>\r\n<td valign=\"TOP\">\"Default\" (use platform default)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #WEIGHT}</td>\r\n<td valign=\"TOP\">Number</td>\r\n<td valign=\"TOP\">WEIGHT_REGULAR, WEIGHT_BOLD</td>\r\n<td valign=\"TOP\">WEIGHT_REGULAR</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #WIDTH}</td>\r\n<td valign=\"TOP\">Number</td>\r\n<td valign=\"TOP\">WIDTH_CONDENSED, WIDTH_REGULAR,<br>WIDTH_EXTENDED</td>\r\n<td valign=\"TOP\">WIDTH_REGULAR</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #POSTURE}</td>\r\n<td valign=\"TOP\">Number</td>\r\n<td valign=\"TOP\">POSTURE_REGULAR, POSTURE_OBLIQUE</td>\r\n<td valign=\"TOP\">POSTURE_REGULAR</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #SIZE}</td>\r\n<td valign=\"TOP\">Number</td>\r\n<td valign=\"TOP\">none</td>\r\n<td valign=\"TOP\">12.0</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #TRANSFORM}</td>\r\n<td valign=\"TOP\">{@link TransformAttribute}</td>\r\n<td valign=\"TOP\">See TransformAttribute {@link TransformAttribute#IDENTITY IDENTITY}</td>\r\n<td valign=\"TOP\">TransformAttribute.IDENTITY</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #SUPERSCRIPT}</td>\r\n<td valign=\"TOP\">Integer</td>\r\n<td valign=\"TOP\">SUPERSCRIPT_SUPER, SUPERSCRIPT_SUB</td>\r\n<td valign=\"TOP\">0 (use the standard glyphs and metrics)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #FONT}</td>\r\n<td valign=\"TOP\">{@link java.awt.Font}</td>\r\n<td valign=\"TOP\">none</td>\r\n<td valign=\"TOP\">null (do not override font resolution)</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #CHAR_REPLACEMENT}</td>\r\n<td valign=\"TOP\">{@link GraphicAttribute}</td>\r\n<td valign=\"TOP\">none</td>\r\n<td valign=\"TOP\">null (draw text using font glyphs)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #FOREGROUND}</td>\r\n<td valign=\"TOP\">{@link java.awt.Paint}</td>\r\n<td valign=\"TOP\">none</td>\r\n<td valign=\"TOP\">null (use current graphics paint)</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #BACKGROUND}</td>\r\n<td valign=\"TOP\">{@link java.awt.Paint}</td>\r\n<td valign=\"TOP\">none</td>\r\n<td valign=\"TOP\">null (do not render background)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #UNDERLINE}</td>\r\n<td valign=\"TOP\">Integer</td>\r\n<td valign=\"TOP\">UNDERLINE_ON</td>\r\n<td valign=\"TOP\">-1 (do not render underline)</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #STRIKETHROUGH}</td>\r\n<td valign=\"TOP\">Boolean</td>\r\n<td valign=\"TOP\">STRIKETHROUGH_ON</td>\r\n<td valign=\"TOP\">false (do not render strikethrough)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #RUN_DIRECTION}</td>\r\n<td valign=\"TOP\">Boolean</td>\r\n<td valign=\"TOP\">RUN_DIRECTION_LTR<br>RUN_DIRECTION_RTL</td>\r\n<td valign=\"TOP\">null (use {@link java.text.Bidi} standard default)</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #BIDI_EMBEDDING}</td>\r\n<td valign=\"TOP\">Integer</td>\r\n<td valign=\"TOP\">none</td>\r\n<td valign=\"TOP\">0 (use base line direction)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #JUSTIFICATION}</td>\r\n<td valign=\"TOP\">Number</td>\r\n<td valign=\"TOP\">JUSTIFICATION_FULL</td>\r\n<td valign=\"TOP\">JUSTIFICATION_FULL</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #INPUT_METHOD_HIGHLIGHT}</td>\r\n<td valign=\"TOP\">{@link java.awt.im.InputMethodHighlight},<br>{@link java.text.Annotation}</td>\r\n<td valign=\"TOP\">(see class)</td>\r\n<td valign=\"TOP\">null (do not apply input highlighting)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #INPUT_METHOD_UNDERLINE}</td>\r\n<td valign=\"TOP\">Integer</td>\r\n<td valign=\"TOP\">UNDERLINE_LOW_ONE_PIXEL,<br>UNDERLINE_LOW_TWO_PIXEL</td>\r\n<td valign=\"TOP\">-1 (do not render underline)</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #SWAP_COLORS}</td>\r\n<td valign=\"TOP\">Boolean</td>\r\n<td valign=\"TOP\">SWAP_COLORS_ON</td>\r\n<td valign=\"TOP\">false (do not swap colors)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #NUMERIC_SHAPING}</td>\r\n<td valign=\"TOP\">{@link java.awt.font.NumericShaper}</td>\r\n<td valign=\"TOP\">none</td>\r\n<td valign=\"TOP\">null (do not shape digits)</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #KERNING}</td>\r\n<td valign=\"TOP\">Integer</td>\r\n<td valign=\"TOP\">KERNING_ON</td>\r\n<td valign=\"TOP\">0 (do not request kerning)</td>\r\n</tr>\r\n<tr style=\"background-color:#eeeeff\">\r\n<td valign=\"TOP\">{@link #LIGATURES}</td>\r\n<td valign=\"TOP\">Integer</td>\r\n<td valign=\"TOP\">LIGATURES_ON</td>\r\n<td valign=\"TOP\">0 (do not form optional ligatures)</td>\r\n</tr>\r\n<tr>\r\n<td valign=\"TOP\">{@link #TRACKING}</td>\r\n<td valign=\"TOP\">Number</td>\r\n<td valign=\"TOP\">TRACKING_LOOSE, TRACKING_TIGHT</td>\r\n<td valign=\"TOP\">0 (do not add tracking)</td>\r\n</tr>\r\n</table>","inherit":["java.text.AttributedCharacterIterator.Attribute"],"name":"java.awt.font.TextAttribute","type":false},{"description":"","inherit":[],"name":"java.awt.font.TextHitInfo","type":false},{"description":"","inherit":[],"name":"java.awt.font.TextJustifier","type":false},{"description":"<code>TextLayout</code> is an immutable graphical representation of styled\r\ncharacter data.\r\n<p>\r\nIt provides the following capabilities:\r\n<ul>\r\n<li>implicit bidirectional analysis and reordering,\r\n<li>cursor positioning and movement, including split cursors for\r\nmixed directional text,\r\n<li>highlighting, including both logical and visual highlighting\r\nfor mixed directional text,\r\n<li>multiple baselines (roman, hanging, and centered),\r\n<li>hit testing,\r\n<li>justification,\r\n<li>default font substitution,\r\n<li>metric information such as ascent, descent, and advance, and\r\n<li>rendering\r\n</ul>\r\n<p>\r\nA <code>TextLayout</code> object can be rendered using\r\nits <code>draw</code> method.\r\n<p>\r\n<code>TextLayout</code> can be constructed either directly or through\r\nthe use of a {@link LineBreakMeasurer}.  When constructed directly, the\r\nsource text represents a single paragraph.  <code>LineBreakMeasurer</code>\r\nallows styled text to be broken into lines that fit within a particular\r\nwidth.  See the <code>LineBreakMeasurer</code> documentation for more\r\ninformation.\r\n<p>\r\n<code>TextLayout</code> construction logically proceeds as follows:\r\n<ul>\r\n<li>paragraph attributes are extracted and examined,\r\n<li>text is analyzed for bidirectional reordering, and reordering\r\ninformation is computed if needed,\r\n<li>text is segmented into style runs\r\n<li>fonts are chosen for style runs, first by using a font if the\r\nattribute {@link TextAttribute#FONT} is present, otherwise by computing\r\na default font using the attributes that have been defined\r\n<li>if text is on multiple baselines, the runs or subruns are further\r\nbroken into subruns sharing a common baseline,\r\n<li>glyphvectors are generated for each run using the chosen font,\r\n<li>final bidirectional reordering is performed on the glyphvectors\r\n</ul>\r\n<p>\r\nAll graphical information returned from a <code>TextLayout</code>\r\nobject's methods is relative to the origin of the\r\n<code>TextLayout</code>, which is the intersection of the\r\n<code>TextLayout</code> object's baseline with its left edge.  Also,\r\ncoordinates passed into a <code>TextLayout</code> object's methods\r\nare assumed to be relative to the <code>TextLayout</code> object's\r\norigin.  Clients usually need to translate between a\r\n<code>TextLayout</code> object's coordinate system and the coordinate\r\nsystem in another object (such as a\r\n{@link java.awt.Graphics Graphics} object).\r\n<p>\r\n<code>TextLayout</code> objects are constructed from styled text,\r\nbut they do not retain a reference to their source text.  Thus,\r\nchanges in the text previously used to generate a <code>TextLayout</code>\r\ndo not affect the <code>TextLayout</code>.\r\n<p>\r\nThree methods on a <code>TextLayout</code> object\r\n(<code>getNextRightHit</code>, <code>getNextLeftHit</code>, and\r\n<code>hitTestChar</code>) return instances of {@link TextHitInfo}.\r\nThe offsets contained in these <code>TextHitInfo</code> objects\r\nare relative to the start of the <code>TextLayout</code>, <b>not</b>\r\nto the text used to create the <code>TextLayout</code>.  Similarly,\r\n<code>TextLayout</code> methods that accept <code>TextHitInfo</code>\r\ninstances as parameters expect the <code>TextHitInfo</code> object's\r\noffsets to be relative to the <code>TextLayout</code>, not to any\r\nunderlying text storage model.\r\n<p>\r\n<strong>Examples</strong>:<p>\r\nConstructing and drawing a <code>TextLayout</code> and its bounding\r\nrectangle:\r\n<blockquote><pre>\r\n  Graphics2D g = ...;\r\n  Point2D loc = ...;\r\n  Font font = Font.getFont(\"Helvetica-bold-italic\");\r\n  FontRenderContext frc = g.getFontRenderContext();\r\n  TextLayout layout = new TextLayout(\"This is a string\", font, frc);\r\n  layout.draw(g, (float)loc.getX(), (float)loc.getY());\r\n\r\n  Rectangle2D bounds = layout.getBounds();\r\n  bounds.setRect(bounds.getX()+loc.getX(),\r\n                 bounds.getY()+loc.getY(),\r\n                 bounds.getWidth(),\r\n                 bounds.getHeight());\r\n  g.draw(bounds);\r\n</pre>\r\n</blockquote>\r\n<p>\r\nHit-testing a <code>TextLayout</code> (determining which character is at\r\na particular graphical location):\r\n<blockquote><pre>\r\n  Point2D click = ...;\r\n  TextHitInfo hit = layout.hitTestChar(\r\n                        (float) (click.getX() - loc.getX()),\r\n                        (float) (click.getY() - loc.getY()));\r\n</pre>\r\n</blockquote>\r\n<p>\r\nResponding to a right-arrow key press:\r\n<blockquote><pre>\r\n  int insertionIndex = ...;\r\n  TextHitInfo next = layout.getNextRightHit(insertionIndex);\r\n  if (next != null) {\r\n      // translate graphics to origin of layout on screen\r\n      g.translate(loc.getX(), loc.getY());\r\n      Shape[] carets = layout.getCaretShapes(next.getInsertionIndex());\r\n      g.draw(carets[0]);\r\n      if (carets[1] != null) {\r\n          g.draw(carets[1]);\r\n      }\r\n  }\r\n</pre></blockquote>\r\n<p>\r\nDrawing a selection range corresponding to a substring in the source text.\r\nThe selected area may not be visually contiguous:\r\n<blockquote><pre>\r\n  // selStart, selLimit should be relative to the layout,\r\n  // not to the source text\r\n\r\n  int selStart = ..., selLimit = ...;\r\n  Color selectionColor = ...;\r\n  Shape selection = layout.getLogicalHighlightShape(selStart, selLimit);\r\n  // selection may consist of disjoint areas\r\n  // graphics is assumed to be tranlated to origin of layout\r\n  g.setColor(selectionColor);\r\n  g.fill(selection);\r\n</pre></blockquote>\r\n<p>\r\nDrawing a visually contiguous selection range.  The selection range may\r\ncorrespond to more than one substring in the source text.  The ranges of\r\nthe corresponding source text substrings can be obtained with\r\n<code>getLogicalRangesForVisualSelection()</code>:\r\n<blockquote><pre>\r\n  TextHitInfo selStart = ..., selLimit = ...;\r\n  Shape selection = layout.getVisualHighlightShape(selStart, selLimit);\r\n  g.setColor(selectionColor);\r\n  g.fill(selection);\r\n  int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);\r\n  // ranges[0], ranges[1] is the first selection range,\r\n  // ranges[2], ranges[3] is the second selection range, etc.\r\n</pre></blockquote>\r\n<p>\r\nNote: Font rotations can cause text baselines to be rotated, and\r\nmultiple runs with different rotations can cause the baseline to\r\nbend or zig-zag.  In order to account for this (rare) possibility,\r\nsome APIs are specified to return metrics and take parameters 'in\r\nbaseline-relative coordinates' (e.g. ascent, advance), and others\r\nare in 'in standard coordinates' (e.g. getBounds).  Values in\r\nbaseline-relative coordinates map the 'x' coordinate to the\r\ndistance along the baseline, (positive x is forward along the\r\nbaseline), and the 'y' coordinate to a distance along the\r\nperpendicular to the baseline at 'x' (positive y is 90 degrees\r\nclockwise from the baseline vector).  Values in standard\r\ncoordinates are measured along the x and y axes, with 0,0 at the\r\norigin of the TextLayout.  Documentation for each relevant API\r\nindicates what values are in what coordinate system.  In general,\r\nmeasurement-related APIs are in baseline-relative coordinates,\r\nwhile display-related APIs are in standard coordinates.","inherit":["java.lang.Cloneable"],"name":"java.awt.font.TextLayout","type":false},{"description":"Defines a policy for determining the strong caret location.\r\nThis class contains one method, <code>getStrongCaret</code>, which\r\nis used to specify the policy that determines the strong caret in\r\ndual-caret text.  The strong caret is used to move the caret to the\r\nleft or right. Instances of this class can be passed to\r\n<code>getCaretShapes</code>, <code>getNextLeftHit</code> and\r\n<code>getNextRightHit</code> to customize strong caret\r\nselection.\r\n<p>\r\nTo specify alternate caret policies, subclass <code>CaretPolicy</code>\r\nand override <code>getStrongCaret</code>.  <code>getStrongCaret</code>\r\nshould inspect the two <code>TextHitInfo</code> arguments and choose\r\none of them as the strong caret.\r\n<p>\r\nMost clients do not need to use this class.","inherit":[],"name":"java.awt.font.TextLayout.CaretPolicy","type":false},{"description":"","inherit":[],"name":"java.awt.font.TextLine","type":false},{"description":"","inherit":[],"name":"java.awt.font.TextLine.TextLineMetrics","type":false},{"description":"","inherit":[],"name":"java.awt.font.TextLine.Function","type":false},{"description":"","inherit":["java.lang.Cloneable"],"name":"java.awt.font.TextMeasurer","type":false},{"description":"The <code>TransformAttribute</code> class provides an immutable\r\nwrapper for a transform so that it is safe to use as an attribute.","inherit":["java.io.Serializable"],"name":"java.awt.font.TransformAttribute","type":false},{"description":"The <code>Font</code> class represents fonts, which are used to\r\nrender text in a visible way.\r\nA font provides the information needed to map sequences of\r\n<em>characters</em> to sequences of <em>glyphs</em>\r\nand to render sequences of glyphs on <code>Graphics</code> and\r\n<code>Component</code> objects.\r\n\r\n<h3>Characters and Glyphs</h3>\r\n\r\nA <em>character</em> is a symbol that represents an item such as a letter,\r\na digit, or punctuation in an abstract way. For example, <code>'g'</code>,\r\nLATIN SMALL LETTER G, is a character.\r\n<p>\r\nA <em>glyph</em> is a shape used to render a character or a sequence of\r\ncharacters. In simple writing systems, such as Latin, typically one glyph\r\nrepresents one character. In general, however, characters and glyphs do not\r\nhave one-to-one correspondence. For example, the character '&aacute;'\r\nLATIN SMALL LETTER A WITH ACUTE, can be represented by\r\ntwo glyphs: one for 'a' and one for '&acute;'. On the other hand, the\r\ntwo-character string \"fi\" can be represented by a single glyph, an\r\n\"fi\" ligature. In complex writing systems, such as Arabic or the South\r\nand South-East Asian writing systems, the relationship between characters\r\nand glyphs can be more complicated and involve context-dependent selection\r\nof glyphs as well as glyph reordering.\r\n\r\nA font encapsulates the collection of glyphs needed to render a selected set\r\nof characters as well as the tables needed to map sequences of characters to\r\ncorresponding sequences of glyphs.\r\n\r\n<h3>Physical and Logical Fonts</h3>\r\n\r\nThe Java Platform distinguishes between two kinds of fonts:\r\n<em>physical</em> fonts and <em>logical</em> fonts.\r\n<p>\r\n<em>Physical</em> fonts are the actual font libraries containing glyph data\r\nand tables to map from character sequences to glyph sequences, using a font\r\ntechnology such as TrueType or PostScript Type 1.\r\nAll implementations of the Java Platform must support TrueType fonts;\r\nsupport for other font technologies is implementation dependent.\r\nPhysical fonts may use names such as Helvetica, Palatino, HonMincho, or\r\nany number of other font names.\r\nTypically, each physical font supports only a limited set of writing\r\nsystems, for example, only Latin characters or only Japanese and Basic\r\nLatin.\r\nThe set of available physical fonts varies between configurations.\r\nApplications that require specific fonts can bundle them and instantiate\r\nthem using the {@link #createFont createFont} method.\r\n<p>\r\n<em>Logical</em> fonts are the five font families defined by the Java\r\nplatform which must be supported by any Java runtime environment:\r\nSerif, SansSerif, Monospaced, Dialog, and DialogInput.\r\nThese logical fonts are not actual font libraries. Instead, the logical\r\nfont names are mapped to physical fonts by the Java runtime environment.\r\nThe mapping is implementation and usually locale dependent, so the look\r\nand the metrics provided by them vary.\r\nTypically, each logical font name maps to several physical fonts in order to\r\ncover a large range of characters.\r\n<p>\r\nPeered AWT components, such as {@link Label Label} and\r\n{@link TextField TextField}, can only use logical fonts.\r\n<p>\r\nFor a discussion of the relative advantages and disadvantages of using\r\nphysical or logical fonts, see the\r\n<a href=\"http://www.oracle.com/technetwork/java/javase/tech/faq-jsp-138165.html\">Internationalization FAQ</a>\r\ndocument.\r\n\r\n<h3>Font Faces and Names</h3>\r\n\r\nA <code>Font</code>\r\ncan have many faces, such as heavy, medium, oblique, gothic and\r\nregular. All of these faces have similar typographic design.\r\n<p>\r\nThere are three different names that you can get from a\r\n<code>Font</code> object.  The <em>logical font name</em> is simply the\r\nname that was used to construct the font.\r\nThe <em>font face name</em>, or just <em>font name</em> for\r\nshort, is the name of a particular font face, like Helvetica Bold. The\r\n<em>family name</em> is the name of the font family that determines the\r\ntypographic design across several faces, like Helvetica.\r\n<p>\r\nThe <code>Font</code> class represents an instance of a font face from\r\na collection of  font faces that are present in the system resources\r\nof the host system.  As examples, Arial Bold and Courier Bold Italic\r\nare font faces.  There can be several <code>Font</code> objects\r\nassociated with a font face, each differing in size, style, transform\r\nand font features.\r\n<p>\r\nThe {@link GraphicsEnvironment#getAllFonts() getAllFonts} method\r\nof the <code>GraphicsEnvironment</code> class returns an\r\narray of all font faces available in the system. These font faces are\r\nreturned as <code>Font</code> objects with a size of 1, identity\r\ntransform and default font features. These\r\nbase fonts can then be used to derive new <code>Font</code> objects\r\nwith varying sizes, styles, transforms and font features via the\r\n<code>deriveFont</code> methods in this class.\r\n\r\n<h3>Font and TextAttribute</h3>\r\n\r\n<p><code>Font</code> supports most\r\n<code>TextAttribute</code>s.  This makes some operations, such as\r\nrendering underlined text, convenient since it is not\r\nnecessary to explicitly construct a <code>TextLayout</code> object.\r\nAttributes can be set on a Font by constructing or deriving it\r\nusing a <code>Map</code> of <code>TextAttribute</code> values.\r\n\r\n<p>The values of some <code>TextAttributes</code> are not\r\nserializable, and therefore attempting to serialize an instance of\r\n<code>Font</code> that has such values will not serialize them.\r\nThis means a Font deserialized from such a stream will not compare\r\nequal to the original Font that contained the non-serializable\r\nattributes.  This should very rarely pose a problem\r\nsince these attributes are typically used only in special\r\ncircumstances and are unlikely to be serialized.\r\n\r\n<ul>\r\n<li><code>FOREGROUND</code> and <code>BACKGROUND</code> use\r\n<code>Paint</code> values. The subclass <code>Color</code> is\r\nserializable, while <code>GradientPaint</code> and\r\n<code>TexturePaint</code> are not.</li>\r\n<li><code>CHAR_REPLACEMENT</code> uses\r\n<code>GraphicAttribute</code> values.  The subclasses\r\n<code>ShapeGraphicAttribute</code> and\r\n<code>ImageGraphicAttribute</code> are not serializable.</li>\r\n<li><code>INPUT_METHOD_HIGHLIGHT</code> uses\r\n<code>InputMethodHighlight</code> values, which are\r\nnot serializable.  See {@link java.awt.im.InputMethodHighlight}.</li>\r\n</ul>\r\n\r\n<p>Clients who create custom subclasses of <code>Paint</code> and\r\n<code>GraphicAttribute</code> can make them serializable and\r\navoid this problem.  Clients who use input method highlights can\r\nconvert these to the platform-specific attributes for that\r\nhighlight on the current platform and set them on the Font as\r\na workaround.\r\n\r\n<p>The <code>Map</code>-based constructor and\r\n<code>deriveFont</code> APIs ignore the FONT attribute, and it is\r\nnot retained by the Font; the static {@link #getFont} method should\r\nbe used if the FONT attribute might be present.  See {@link\r\njava.awt.font.TextAttribute#FONT} for more information.</p>\r\n\r\n<p>Several attributes will cause additional rendering overhead\r\nand potentially invoke layout.  If a <code>Font</code> has such\r\nattributes, the <code>{@link #hasLayoutAttributes()}</code> method\r\nwill return true.</p>\r\n\r\n<p>Note: Font rotations can cause text baselines to be rotated.  In\r\norder to account for this (rare) possibility, font APIs are\r\nspecified to return metrics and take parameters 'in\r\nbaseline-relative coordinates'.  This maps the 'x' coordinate to\r\nthe advance along the baseline, (positive x is forward along the\r\nbaseline), and the 'y' coordinate to a distance along the\r\nperpendicular to the baseline at 'x' (positive y is 90 degrees\r\nclockwise from the baseline vector).  APIs for which this is\r\nespecially important are called out as having 'baseline-relative\r\ncoordinates.'","inherit":["java.io.Serializable"],"name":"java.awt.Font","type":false},{"description":"","inherit":["sun.font.FontAccess"],"name":"java.awt.Font.FontAccessImpl","type":false},{"description":"Thrown by method createFont in the <code>Font</code> class to indicate\r\nthat the specified font is bad.","inherit":["java.lang.Exception"],"name":"java.awt.FontFormatException","type":false},{"description":"The <code>FontMetrics</code> class defines a font metrics object, which\r\nencapsulates information about the rendering of a particular font on a\r\nparticular screen.\r\n<p>\r\n<b>Note to subclassers</b>: Since many of these methods form closed,\r\nmutually recursive loops, you must take care that you implement\r\nat least one of the methods in each such loop to prevent\r\ninfinite recursion when your subclass is used.\r\nIn particular, the following is the minimal suggested set of methods\r\nto override in order to ensure correctness and prevent infinite\r\nrecursion (though other subsets are equally feasible):\r\n<ul>\r\n<li>{@link #getAscent()}\r\n<li>{@link #getLeading()}\r\n<li>{@link #getMaxAdvance()}\r\n<li>{@link #charWidth(char)}\r\n<li>{@link #charsWidth(char[], int, int)}\r\n</ul>\r\n<p>\r\n<img src=\"doc-files/FontMetrics-1.gif\" alt=\"The letter 'p' showing its 'reference point'\"\r\nstyle=\"border:15px; float:right; margin: 7px 10px;\">\r\nNote that the implementations of these methods are\r\ninefficient, so they are usually overridden with more efficient\r\ntoolkit-specific implementations.\r\n<p>\r\nWhen an application asks to place a character at the position\r\n(<i>x</i>,&nbsp;<i>y</i>), the character is placed so that its\r\nreference point (shown as the dot in the accompanying image) is\r\nput at that position. The reference point specifies a horizontal\r\nline called the <i>baseline</i> of the character. In normal\r\nprinting, the baselines of characters should align.\r\n<p>\r\nIn addition, every character in a font has an <i>ascent</i>, a\r\n<i>descent</i>, and an <i>advance width</i>. The ascent is the\r\namount by which the character ascends above the baseline. The\r\ndescent is the amount by which the character descends below the\r\nbaseline. The advance width indicates the position at which AWT\r\nshould place the next character.\r\n<p>\r\nAn array of characters or a string can also have an ascent, a\r\ndescent, and an advance width. The ascent of the array is the\r\nmaximum ascent of any character in the array. The descent is the\r\nmaximum descent of any character in the array. The advance width\r\nis the sum of the advance widths of each of the characters in the\r\ncharacter array.  The advance of a <code>String</code> is the\r\ndistance along the baseline of the <code>String</code>.  This\r\ndistance is the width that should be used for centering or\r\nright-aligning the <code>String</code>.\r\n<p>Note that the advance of a <code>String</code> is not necessarily\r\nthe sum of the advances of its characters measured in isolation\r\nbecause the width of a character can vary depending on its context.\r\nFor example, in Arabic text, the shape of a character can change\r\nin order to connect to other characters.  Also, in some scripts,\r\ncertain character sequences can be represented by a single shape,\r\ncalled a <em>ligature</em>.  Measuring characters individually does\r\nnot account for these transformations.\r\n<p>Font metrics are baseline-relative, meaning that they are\r\ngenerally independent of the rotation applied to the font (modulo\r\npossible grid hinting effects).  See {@link java.awt.Font Font}.","inherit":["java.io.Serializable"],"name":"java.awt.FontMetrics","type":false},{"description":"A <code>Frame</code> is a top-level window with a title and a border.\r\n<p>\r\nThe size of the frame includes any area designated for the\r\nborder.  The dimensions of the border area may be obtained\r\nusing the <code>getInsets</code> method, however, since\r\nthese dimensions are platform-dependent, a valid insets\r\nvalue cannot be obtained until the frame is made displayable\r\nby either calling <code>pack</code> or <code>show</code>.\r\nSince the border area is included in the overall size of the\r\nframe, the border effectively obscures a portion of the frame,\r\nconstraining the area available for rendering and/or displaying\r\nsubcomponents to the rectangle which has an upper-left corner\r\nlocation of <code>(insets.left, insets.top)</code>, and has a size of\r\n<code>width - (insets.left + insets.right)</code> by\r\n<code>height - (insets.top + insets.bottom)</code>.\r\n<p>\r\nThe default layout for a frame is <code>BorderLayout</code>.\r\n<p>\r\nA frame may have its native decorations (i.e. <code>Frame</code>\r\nand <code>Titlebar</code>) turned off\r\nwith <code>setUndecorated</code>. This can only be done while the frame\r\nis not {@link Component#isDisplayable() displayable}.\r\n<p>\r\nIn a multi-screen environment, you can create a <code>Frame</code>\r\non a different screen device by constructing the <code>Frame</code>\r\nwith {@link #Frame(GraphicsConfiguration)} or\r\n{@link #Frame(String title, GraphicsConfiguration)}.  The\r\n<code>GraphicsConfiguration</code> object is one of the\r\n<code>GraphicsConfiguration</code> objects of the target screen\r\ndevice.\r\n<p>\r\nIn a virtual device multi-screen environment in which the desktop\r\narea could span multiple physical screen devices, the bounds of all\r\nconfigurations are relative to the virtual-coordinate system.  The\r\norigin of the virtual-coordinate system is at the upper left-hand\r\ncorner of the primary physical screen.  Depending on the location\r\nof the primary screen in the virtual device, negative coordinates\r\nare possible, as shown in the following figure.\r\n<p>\r\n<img src=\"doc-files/MultiScreen.gif\"\r\nalt=\"Diagram of virtual device encompassing three physical screens and one primary physical screen. The primary physical screen\r\nshows (0,0) coords while a different physical screen shows (-80,-100) coords.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nIn such an environment, when calling <code>setLocation</code>,\r\nyou must pass a virtual coordinate to this method.  Similarly,\r\ncalling <code>getLocationOnScreen</code> on a <code>Frame</code>\r\nreturns virtual device coordinates.  Call the <code>getBounds</code>\r\nmethod of a <code>GraphicsConfiguration</code> to find its origin in\r\nthe virtual coordinate system.\r\n<p>\r\nThe following code sets the\r\nlocation of the <code>Frame</code> at (10, 10) relative\r\nto the origin of the physical screen of the corresponding\r\n<code>GraphicsConfiguration</code>.  If the bounds of the\r\n<code>GraphicsConfiguration</code> is not taken into account, the\r\n<code>Frame</code> location would be set at (10, 10) relative to the\r\nvirtual-coordinate system and would appear on the primary physical\r\nscreen, which might be different from the physical screen of the\r\nspecified <code>GraphicsConfiguration</code>.\r\n\r\n<pre>\r\n     Frame f = new Frame(GraphicsConfiguration gc);\r\n     Rectangle bounds = gc.getBounds();\r\n     f.setLocation(10 + bounds.x, 10 + bounds.y);\r\n</pre>\r\n\r\n<p>\r\nFrames are capable of generating the following types of\r\n<code>WindowEvent</code>s:\r\n<ul>\r\n<li><code>WINDOW_OPENED</code>\r\n<li><code>WINDOW_CLOSING</code>:\r\n    <br>If the program doesn't\r\n    explicitly hide or dispose the window while processing\r\n    this event, the window close operation is canceled.\r\n<li><code>WINDOW_CLOSED</code>\r\n<li><code>WINDOW_ICONIFIED</code>\r\n<li><code>WINDOW_DEICONIFIED</code>\r\n<li><code>WINDOW_ACTIVATED</code>\r\n<li><code>WINDOW_DEACTIVATED</code>\r\n<li><code>WINDOW_GAINED_FOCUS</code>\r\n<li><code>WINDOW_LOST_FOCUS</code>\r\n<li><code>WINDOW_STATE_CHANGED</code>\r\n</ul>","inherit":["java.awt.Window","java.awt.MenuContainer"],"name":"java.awt.Frame","type":false},{"description":"This class implements accessibility support for the\r\n<code>Frame</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to frame user-interface elements.","inherit":["java.awt.Window.AccessibleAWTWindow"],"name":"java.awt.Frame.AccessibleAWTFrame","type":false},{"description":"The <code>AffineTransform</code> class represents a 2D affine transform\r\nthat performs a linear mapping from 2D coordinates to other 2D\r\ncoordinates that preserves the \"straightness\" and\r\n\"parallelness\" of lines.  Affine transformations can be constructed\r\nusing sequences of translations, scales, flips, rotations, and shears.\r\n<p>\r\nSuch a coordinate transformation can be represented by a 3 row by\r\n3 column matrix with an implied last row of [ 0 0 1 ].  This matrix\r\ntransforms source coordinates {@code (x,y)} into\r\ndestination coordinates {@code (x',y')} by considering\r\nthem to be a column vector and multiplying the coordinate vector\r\nby the matrix according to the following process:\r\n<pre>\r\n     [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]\r\n     [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]\r\n     [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]\r\n</pre>\r\n<h3><a name=\"quadrantapproximation\">Handling 90-Degree Rotations</a></h3>\r\n<p>\r\nIn some variations of the <code>rotate</code> methods in the\r\n<code>AffineTransform</code> class, a double-precision argument\r\nspecifies the angle of rotation in radians.\r\nThese methods have special handling for rotations of approximately\r\n90 degrees (including multiples such as 180, 270, and 360 degrees),\r\nso that the common case of quadrant rotation is handled more\r\nefficiently.\r\nThis special handling can cause angles very close to multiples of\r\n90 degrees to be treated as if they were exact multiples of\r\n90 degrees.\r\nFor small multiples of 90 degrees the range of angles treated\r\nas a quadrant rotation is approximately 0.00000121 degrees wide.\r\nThis section explains why such special care is needed and how\r\nit is implemented.\r\n<p>\r\nSince 90 degrees is represented as <code>PI/2</code> in radians,\r\nand since PI is a transcendental (and therefore irrational) number,\r\nit is not possible to exactly represent a multiple of 90 degrees as\r\nan exact double precision value measured in radians.\r\nAs a result it is theoretically impossible to describe quadrant\r\nrotations (90, 180, 270 or 360 degrees) using these values.\r\nDouble precision floating point values can get very close to\r\nnon-zero multiples of <code>PI/2</code> but never close enough\r\nfor the sine or cosine to be exactly 0.0, 1.0 or -1.0.\r\nThe implementations of <code>Math.sin()</code> and\r\n<code>Math.cos()</code> correspondingly never return 0.0\r\nfor any case other than <code>Math.sin(0.0)</code>.\r\nThese same implementations do, however, return exactly 1.0 and\r\n-1.0 for some range of numbers around each multiple of 90\r\ndegrees since the correct answer is so close to 1.0 or -1.0 that\r\nthe double precision significand cannot represent the difference\r\nas accurately as it can for numbers that are near 0.0.\r\n<p>\r\nThe net result of these issues is that if the\r\n<code>Math.sin()</code> and <code>Math.cos()</code> methods\r\nare used to directly generate the values for the matrix modifications\r\nduring these radian-based rotation operations then the resulting\r\ntransform is never strictly classifiable as a quadrant rotation\r\neven for a simple case like <code>rotate(Math.PI/2.0)</code>,\r\ndue to minor variations in the matrix caused by the non-0.0 values\r\nobtained for the sine and cosine.\r\nIf these transforms are not classified as quadrant rotations then\r\nsubsequent code which attempts to optimize further operations based\r\nupon the type of the transform will be relegated to its most general\r\nimplementation.\r\n<p>\r\nBecause quadrant rotations are fairly common,\r\nthis class should handle these cases reasonably quickly, both in\r\napplying the rotations to the transform and in applying the resulting\r\ntransform to the coordinates.\r\nTo facilitate this optimal handling, the methods which take an angle\r\nof rotation measured in radians attempt to detect angles that are\r\nintended to be quadrant rotations and treat them as such.\r\nThese methods therefore treat an angle <em>theta</em> as a quadrant\r\nrotation if either <code>Math.sin(<em>theta</em>)</code> or\r\n<code>Math.cos(<em>theta</em>)</code> returns exactly 1.0 or -1.0.\r\nAs a rule of thumb, this property holds true for a range of\r\napproximately 0.0000000211 radians (or 0.00000121 degrees) around\r\nsmall multiples of <code>Math.PI/2.0</code>.","inherit":["java.lang.Cloneable","java.io.Serializable"],"name":"java.awt.geom.AffineTransform","type":false},{"description":"<CODE>Arc2D</CODE> is the abstract superclass for all objects that\r\nstore a 2D arc defined by a framing rectangle,\r\nstart angle, angular extent (length of the arc), and a closure type\r\n(<CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>).\r\n<p>\r\n<a name=\"inscribes\">\r\nThe arc is a partial section of a full ellipse which\r\ninscribes the framing rectangle of its parent {@link RectangularShape}.\r\n</a>\r\n<a name=\"angles\">\r\nThe angles are specified relative to the non-square\r\nframing rectangle such that 45 degrees always falls on the line from\r\nthe center of the ellipse to the upper right corner of the framing\r\nrectangle.\r\nAs a result, if the framing rectangle is noticeably longer along one\r\naxis than the other, the angles to the start and end of the arc segment\r\nwill be skewed farther along the longer axis of the frame.\r\n</a>\r\n<p>\r\nThe actual storage representation of the coordinates is left to\r\nthe subclass.","inherit":["java.awt.geom.RectangularShape"],"name":"java.awt.geom.Arc2D","type":false},{"description":"This class defines an arc specified in {@code float} precision.","inherit":["java.awt.geom.Arc2D","java.io.Serializable"],"name":"java.awt.geom.Arc2D.Float","type":false},{"description":"This class defines an arc specified in {@code double} precision.","inherit":["java.awt.geom.Arc2D","java.io.Serializable"],"name":"java.awt.geom.Arc2D.Double","type":false},{"description":"A utility class to iterate over the path segments of an arc\r\nthrough the PathIterator interface.","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.ArcIterator","type":false},{"description":"An <code>Area</code> object stores and manipulates a\r\nresolution-independent description of an enclosed area of\r\n2-dimensional space.\r\n<code>Area</code> objects can be transformed and can perform\r\nvarious Constructive Area Geometry (CAG) operations when combined\r\nwith other <code>Area</code> objects.\r\nThe CAG operations include area\r\n{@link #add addition}, {@link #subtract subtraction},\r\n{@link #intersect intersection}, and {@link #exclusiveOr exclusive or}.\r\nSee the linked method documentation for examples of the various\r\noperations.\r\n<p>\r\nThe <code>Area</code> class implements the <code>Shape</code>\r\ninterface and provides full support for all of its hit-testing\r\nand path iteration facilities, but an <code>Area</code> is more\r\nspecific than a generalized path in a number of ways:\r\n<ul>\r\n<li>Only closed paths and sub-paths are stored.\r\n    <code>Area</code> objects constructed from unclosed paths\r\n    are implicitly closed during construction as if those paths\r\n    had been filled by the <code>Graphics2D.fill</code> method.\r\n<li>The interiors of the individual stored sub-paths are all\r\n    non-empty and non-overlapping.  Paths are decomposed during\r\n    construction into separate component non-overlapping parts,\r\n    empty pieces of the path are discarded, and then these\r\n    non-empty and non-overlapping properties are maintained\r\n    through all subsequent CAG operations.  Outlines of different\r\n    component sub-paths may touch each other, as long as they\r\n    do not cross so that their enclosed areas overlap.\r\n<li>The geometry of the path describing the outline of the\r\n    <code>Area</code> resembles the path from which it was\r\n    constructed only in that it describes the same enclosed\r\n    2-dimensional area, but may use entirely different types\r\n    and ordering of the path segments to do so.\r\n</ul>\r\nInteresting issues which are not always obvious when using\r\nthe <code>Area</code> include:\r\n<ul>\r\n<li>Creating an <code>Area</code> from an unclosed (open)\r\n    <code>Shape</code> results in a closed outline in the\r\n    <code>Area</code> object.\r\n<li>Creating an <code>Area</code> from a <code>Shape</code>\r\n    which encloses no area (even when \"closed\") produces an\r\n    empty <code>Area</code>.  A common example of this issue\r\n    is that producing an <code>Area</code> from a line will\r\n    be empty since the line encloses no area.  An empty\r\n    <code>Area</code> will iterate no geometry in its\r\n    <code>PathIterator</code> objects.\r\n<li>A self-intersecting <code>Shape</code> may be split into\r\n    two (or more) sub-paths each enclosing one of the\r\n    non-intersecting portions of the original path.\r\n<li>An <code>Area</code> may take more path segments to\r\n    describe the same geometry even when the original\r\n    outline is simple and obvious.  The analysis that the\r\n    <code>Area</code> class must perform on the path may\r\n    not reflect the same concepts of \"simple and obvious\"\r\n    as a human being perceives.\r\n</ul>","inherit":["java.awt.Shape","java.lang.Cloneable"],"name":"java.awt.geom.Area","type":false},{"description":"","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.AreaIterator","type":false},{"description":"The <code>CubicCurve2D</code> class defines a cubic parametric curve\r\nsegment in {@code (x,y)} coordinate space.\r\n<p>\r\nThis class is only the abstract superclass for all objects which\r\nstore a 2D cubic curve segment.\r\nThe actual storage representation of the coordinates is left to\r\nthe subclass.","inherit":["java.awt.Shape","java.lang.Cloneable"],"name":"java.awt.geom.CubicCurve2D","type":false},{"description":"A cubic parametric curve segment specified with\r\n{@code float} coordinates.","inherit":["java.awt.geom.CubicCurve2D","java.io.Serializable"],"name":"java.awt.geom.CubicCurve2D.Float","type":false},{"description":"A cubic parametric curve segment specified with\r\n{@code double} coordinates.","inherit":["java.awt.geom.CubicCurve2D","java.io.Serializable"],"name":"java.awt.geom.CubicCurve2D.Double","type":false},{"description":"A utility class to iterate over the path segments of a cubic curve\r\nsegment through the PathIterator interface.","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.CubicIterator","type":false},{"description":"The <code>Dimension2D</code> class is to encapsulate a width\r\nand a height dimension.\r\n<p>\r\nThis class is only the abstract superclass for all objects that\r\nstore a 2D dimension.\r\nThe actual storage representation of the sizes is left to\r\nthe subclass.","inherit":["java.lang.Cloneable"],"name":"java.awt.geom.Dimension2D","type":false},{"description":"The <code>Ellipse2D</code> class describes an ellipse that is defined\r\nby a framing rectangle.\r\n<p>\r\nThis class is only the abstract superclass for all objects which\r\nstore a 2D ellipse.\r\nThe actual storage representation of the coordinates is left to\r\nthe subclass.","inherit":["java.awt.geom.RectangularShape"],"name":"java.awt.geom.Ellipse2D","type":false},{"description":"The <code>Float</code> class defines an ellipse specified\r\nin <code>float</code> precision.","inherit":["java.awt.geom.Ellipse2D","java.io.Serializable"],"name":"java.awt.geom.Ellipse2D.Float","type":false},{"description":"The <code>Double</code> class defines an ellipse specified\r\nin <code>double</code> precision.","inherit":["java.awt.geom.Ellipse2D","java.io.Serializable"],"name":"java.awt.geom.Ellipse2D.Double","type":false},{"description":"A utility class to iterate over the path segments of an ellipse\r\nthrough the PathIterator interface.","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.EllipseIterator","type":false},{"description":"The <code>FlatteningPathIterator</code> class returns a flattened view of\r\nanother {@link PathIterator} object.  Other {@link java.awt.Shape Shape}\r\nclasses can use this class to provide flattening behavior for their paths\r\nwithout having to perform the interpolation calculations themselves.","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.FlatteningPathIterator","type":false},{"description":"The {@code GeneralPath} class represents a geometric path\r\nconstructed from straight lines, and quadratic and cubic\r\n(B&eacute;zier) curves.  It can contain multiple subpaths.\r\n<p>\r\n{@code GeneralPath} is a legacy final class which exactly\r\nimplements the behavior of its superclass {@link Path2D.Float}.\r\nTogether with {@link Path2D.Double}, the {@link Path2D} classes\r\nprovide full implementations of a general geometric path that\r\nsupport all of the functionality of the {@link Shape} and\r\n{@link PathIterator} interfaces with the ability to explicitly\r\nselect different levels of internal coordinate precision.\r\n<p>\r\nUse {@code Path2D.Float} (or this legacy {@code GeneralPath}\r\nsubclass) when dealing with data that can be represented\r\nand used with floating point precision.  Use {@code Path2D.Double}\r\nfor data that requires the accuracy or range of double precision.","inherit":["java.awt.geom.Path2D.Float"],"name":"java.awt.geom.GeneralPath","type":false},{"description":"","inherit":["java.lang.RuntimeException"],"name":"java.awt.geom.IllegalPathStateException","type":false},{"description":"This <code>Line2D</code> represents a line segment in {@code (x,y)}\r\ncoordinate space.  This class, like all of the Java 2D API, uses a\r\ndefault coordinate system called <i>user space</i> in which the y-axis\r\nvalues increase downward and x-axis values increase to the right.  For\r\nmore information on the user space coordinate system, see the\r\n<a href=\"https://docs.oracle.com/javase/1.3/docs/guide/2d/spec/j2d-intro.fm2.html#61857\">\r\nCoordinate Systems</a> section of the Java 2D Programmer's Guide.\r\n<p>\r\nThis class is only the abstract superclass for all objects that\r\nstore a 2D line segment.\r\nThe actual storage representation of the coordinates is left to\r\nthe subclass.","inherit":["java.awt.Shape","java.lang.Cloneable"],"name":"java.awt.geom.Line2D","type":false},{"description":"A line segment specified with float coordinates.","inherit":["java.awt.geom.Line2D","java.io.Serializable"],"name":"java.awt.geom.Line2D.Float","type":false},{"description":"A line segment specified with double coordinates.","inherit":["java.awt.geom.Line2D","java.io.Serializable"],"name":"java.awt.geom.Line2D.Double","type":false},{"description":"A utility class to iterate over the path segments of a line segment\r\nthrough the PathIterator interface.","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.LineIterator","type":false},{"description":"","inherit":["java.lang.Exception"],"name":"java.awt.geom.NoninvertibleTransformException","type":false},{"description":"The {@code Path2D} class provides a simple, yet flexible\r\nshape which represents an arbitrary geometric path.\r\nIt can fully represent any path which can be iterated by the\r\n{@link PathIterator} interface including all of its segment\r\ntypes and winding rules and it implements all of the\r\nbasic hit testing methods of the {@link Shape} interface.\r\n<p>\r\nUse {@link Path2D.Float} when dealing with data that can be represented\r\nand used with floating point precision.  Use {@link Path2D.Double}\r\nfor data that requires the accuracy or range of double precision.\r\n<p>\r\n{@code Path2D} provides exactly those facilities required for\r\nbasic construction and management of a geometric path and\r\nimplementation of the above interfaces with little added\r\ninterpretation.\r\nIf it is useful to manipulate the interiors of closed\r\ngeometric shapes beyond simple hit testing then the\r\n{@link Area} class provides additional capabilities\r\nspecifically targeted at closed figures.\r\nWhile both classes nominally implement the {@code Shape}\r\ninterface, they differ in purpose and together they provide\r\ntwo useful views of a geometric shape where {@code Path2D}\r\ndeals primarily with a trajectory formed by path segments\r\nand {@code Area} deals more with interpretation and manipulation\r\nof enclosed regions of 2D geometric space.\r\n<p>\r\nThe {@link PathIterator} interface has more detailed descriptions\r\nof the types of segments that make up a path and the winding rules\r\nthat control how to determine which regions are inside or outside\r\nthe path.","inherit":["java.awt.Shape","java.lang.Cloneable"],"name":"java.awt.geom.Path2D","type":false},{"description":"The {@code Float} class defines a geometric path with\r\ncoordinates stored in single precision floating point.","inherit":["java.awt.geom.Path2D","java.io.Serializable"],"name":"java.awt.geom.Path2D.Float","type":false},{"description":"","inherit":["java.awt.geom.Path2D.Iterator"],"name":"java.awt.geom.Path2D.Float.CopyIterator","type":false},{"description":"","inherit":["java.awt.geom.Path2D.Iterator"],"name":"java.awt.geom.Path2D.Float.TxIterator","type":false},{"description":"The {@code Double} class defines a geometric path with\r\ncoordinates stored in double precision floating point.","inherit":["java.awt.geom.Path2D","java.io.Serializable"],"name":"java.awt.geom.Path2D.Double","type":false},{"description":"","inherit":["java.awt.geom.Path2D.Iterator"],"name":"java.awt.geom.Path2D.Double.CopyIterator","type":false},{"description":"","inherit":["java.awt.geom.Path2D.Iterator"],"name":"java.awt.geom.Path2D.Double.TxIterator","type":false},{"description":"","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.Path2D.Iterator","type":false},{"description":"The <code>PathIterator</code> interface provides the mechanism\r\nfor objects that implement the {@link java.awt.Shape Shape}\r\ninterface to return the geometry of their boundary by allowing\r\na caller to retrieve the path of that boundary a segment at a\r\ntime.  This interface allows these objects to retrieve the path of\r\ntheir boundary a segment at a time by using 1st through 3rd order\r\nB&eacute;zier curves, which are lines and quadratic or cubic\r\nB&eacute;zier splines.\r\n<p>\r\nMultiple subpaths can be expressed by using a \"MOVETO\" segment to\r\ncreate a discontinuity in the geometry to move from the end of\r\none subpath to the beginning of the next.\r\n<p>\r\nEach subpath can be closed manually by ending the last segment in\r\nthe subpath on the same coordinate as the beginning \"MOVETO\" segment\r\nfor that subpath or by using a \"CLOSE\" segment to append a line\r\nsegment from the last point back to the first.\r\nBe aware that manually closing an outline as opposed to using a\r\n\"CLOSE\" segment to close the path might result in different line\r\nstyle decorations being used at the end points of the subpath.\r\nFor example, the {@link java.awt.BasicStroke BasicStroke} object\r\nuses a line \"JOIN\" decoration to connect the first and last points\r\nif a \"CLOSE\" segment is encountered, whereas simply ending the path\r\non the same coordinate as the beginning coordinate results in line\r\n\"CAP\" decorations being used at the ends.","inherit":[],"name":"java.awt.geom.PathIterator","type":true},{"description":"The <code>Point2D</code> class defines a point representing a location\r\nin {@code (x,y)} coordinate space.\r\n<p>\r\nThis class is only the abstract superclass for all objects that\r\nstore a 2D coordinate.\r\nThe actual storage representation of the coordinates is left to\r\nthe subclass.","inherit":["java.lang.Cloneable"],"name":"java.awt.geom.Point2D","type":false},{"description":"The <code>Float</code> class defines a point specified in float\r\nprecision.","inherit":["java.awt.geom.Point2D","java.io.Serializable"],"name":"java.awt.geom.Point2D.Float","type":false},{"description":"The <code>Double</code> class defines a point specified in\r\n<code>double</code> precision.","inherit":["java.awt.geom.Point2D","java.io.Serializable"],"name":"java.awt.geom.Point2D.Double","type":false},{"description":"The <code>QuadCurve2D</code> class defines a quadratic parametric curve\r\nsegment in {@code (x,y)} coordinate space.\r\n<p>\r\nThis class is only the abstract superclass for all objects that\r\nstore a 2D quadratic curve segment.\r\nThe actual storage representation of the coordinates is left to\r\nthe subclass.","inherit":["java.awt.Shape","java.lang.Cloneable"],"name":"java.awt.geom.QuadCurve2D","type":false},{"description":"A quadratic parametric curve segment specified with\r\n{@code float} coordinates.","inherit":["java.awt.geom.QuadCurve2D","java.io.Serializable"],"name":"java.awt.geom.QuadCurve2D.Float","type":false},{"description":"A quadratic parametric curve segment specified with\r\n{@code double} coordinates.","inherit":["java.awt.geom.QuadCurve2D","java.io.Serializable"],"name":"java.awt.geom.QuadCurve2D.Double","type":false},{"description":"A utility class to iterate over the path segments of a quadratic curve\r\nsegment through the PathIterator interface.","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.QuadIterator","type":false},{"description":"The <code>Rectangle2D</code> class describes a rectangle\r\ndefined by a location {@code (x,y)} and dimension\r\n{@code (w x h)}.\r\n<p>\r\nThis class is only the abstract superclass for all objects that\r\nstore a 2D rectangle.\r\nThe actual storage representation of the coordinates is left to\r\nthe subclass.","inherit":["java.awt.geom.RectangularShape"],"name":"java.awt.geom.Rectangle2D","type":false},{"description":"The <code>Float</code> class defines a rectangle specified in float\r\ncoordinates.","inherit":["java.awt.geom.Rectangle2D","java.io.Serializable"],"name":"java.awt.geom.Rectangle2D.Float","type":false},{"description":"The <code>Double</code> class defines a rectangle specified in\r\ndouble coordinates.","inherit":["java.awt.geom.Rectangle2D","java.io.Serializable"],"name":"java.awt.geom.Rectangle2D.Double","type":false},{"description":"<code>RectangularShape</code> is the base class for a number of\r\n{@link Shape} objects whose geometry is defined by a rectangular frame.\r\nThis class does not directly specify any specific geometry by\r\nitself, but merely provides manipulation methods inherited by\r\na whole category of <code>Shape</code> objects.\r\nThe manipulation methods provided by this class can be used to\r\nquery and modify the rectangular frame, which provides a reference\r\nfor the subclasses to define their geometry.","inherit":["java.awt.Shape","java.lang.Cloneable"],"name":"java.awt.geom.RectangularShape","type":false},{"description":"A utility class to iterate over the path segments of a rectangle\r\nthrough the PathIterator interface.","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.RectIterator","type":false},{"description":"The <code>RoundRectangle2D</code> class defines a rectangle with\r\nrounded corners defined by a location {@code (x,y)}, a\r\ndimension {@code (w x h)}, and the width and height of an arc\r\nwith which to round the corners.\r\n<p>\r\nThis class is the abstract superclass for all objects that\r\nstore a 2D rounded rectangle.\r\nThe actual storage representation of the coordinates is left to\r\nthe subclass.","inherit":["java.awt.geom.RectangularShape"],"name":"java.awt.geom.RoundRectangle2D","type":false},{"description":"The <code>Float</code> class defines a rectangle with rounded\r\ncorners all specified in <code>float</code> coordinates.","inherit":["java.awt.geom.RoundRectangle2D","java.io.Serializable"],"name":"java.awt.geom.RoundRectangle2D.Float","type":false},{"description":"The <code>Double</code> class defines a rectangle with rounded\r\ncorners all specified in <code>double</code> coordinates.","inherit":["java.awt.geom.RoundRectangle2D","java.io.Serializable"],"name":"java.awt.geom.RoundRectangle2D.Double","type":false},{"description":"A utility class to iterate over the path segments of an rounded rectangle\r\nthrough the PathIterator interface.","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.geom.RoundRectIterator","type":false},{"description":"","inherit":["java.awt.Paint"],"name":"java.awt.GradientPaint","type":false},{"description":"","inherit":["java.awt.PaintContext"],"name":"java.awt.GradientPaintContext","type":false},{"description":"The <code>Graphics</code> class is the abstract base class for\r\nall graphics contexts that allow an application to draw onto\r\ncomponents that are realized on various devices, as well as\r\nonto off-screen images.\r\n<p>\r\nA <code>Graphics</code> object encapsulates state information needed\r\nfor the basic rendering operations that Java supports.  This\r\nstate information includes the following properties:\r\n\r\n<ul>\r\n<li>The <code>Component</code> object on which to draw.\r\n<li>A translation origin for rendering and clipping coordinates.\r\n<li>The current clip.\r\n<li>The current color.\r\n<li>The current font.\r\n<li>The current logical pixel operation function (XOR or Paint).\r\n<li>The current XOR alternation color\r\n    (see {@link Graphics#setXORMode}).\r\n</ul>\r\n<p>\r\nCoordinates are infinitely thin and lie between the pixels of the\r\noutput device.\r\nOperations that draw the outline of a figure operate by traversing\r\nan infinitely thin path between pixels with a pixel-sized pen that hangs\r\ndown and to the right of the anchor point on the path.\r\nOperations that fill a figure operate by filling the interior\r\nof that infinitely thin path.\r\nOperations that render horizontal text render the ascending\r\nportion of character glyphs entirely above the baseline coordinate.\r\n<p>\r\nThe graphics pen hangs down and to the right from the path it traverses.\r\nThis has the following implications:\r\n<ul>\r\n<li>If you draw a figure that covers a given rectangle, that\r\nfigure occupies one extra row of pixels on the right and bottom edges\r\nas compared to filling a figure that is bounded by that same rectangle.\r\n<li>If you draw a horizontal line along the same <i>y</i> coordinate as\r\nthe baseline of a line of text, that line is drawn entirely below\r\nthe text, except for any descenders.\r\n</ul><p>\r\nAll coordinates that appear as arguments to the methods of this\r\n<code>Graphics</code> object are considered relative to the\r\ntranslation origin of this <code>Graphics</code> object prior to\r\nthe invocation of the method.\r\n<p>\r\nAll rendering operations modify only pixels which lie within the\r\narea bounded by the current clip, which is specified by a {@link Shape}\r\nin user space and is controlled by the program using the\r\n<code>Graphics</code> object.  This <i>user clip</i>\r\nis transformed into device space and combined with the\r\n<i>device clip</i>, which is defined by the visibility of windows and\r\ndevice extents.  The combination of the user clip and device clip\r\ndefines the <i>composite clip</i>, which determines the final clipping\r\nregion.  The user clip cannot be modified by the rendering\r\nsystem to reflect the resulting composite clip. The user clip can only\r\nbe changed through the <code>setClip</code> or <code>clipRect</code>\r\nmethods.\r\nAll drawing or writing is done in the current color,\r\nusing the current paint mode, and in the current font.","inherit":[],"name":"java.awt.Graphics","type":false},{"description":"This <code>Graphics2D</code> class extends the\r\n{@link Graphics} class to provide more sophisticated\r\ncontrol over geometry, coordinate transformations, color management,\r\nand text layout.  This is the fundamental class for rendering\r\n2-dimensional shapes, text and images on the  Java(tm) platform.\r\n<p>\r\n<h2>Coordinate Spaces</h2>\r\nAll coordinates passed to a <code>Graphics2D</code> object are specified\r\nin a device-independent coordinate system called User Space, which is\r\nused by applications.  The <code>Graphics2D</code> object contains\r\nan {@link AffineTransform} object as part of its rendering state\r\nthat defines how to convert coordinates from user space to\r\ndevice-dependent coordinates in Device Space.\r\n<p>\r\nCoordinates in device space usually refer to individual device pixels\r\nand are aligned on the infinitely thin gaps between these pixels.\r\nSome <code>Graphics2D</code> objects can be used to capture rendering\r\noperations for storage into a graphics metafile for playback on a\r\nconcrete device of unknown physical resolution at a later time.  Since\r\nthe resolution might not be known when the rendering operations are\r\ncaptured, the <code>Graphics2D</code> <code>Transform</code> is set up\r\nto transform user coordinates to a virtual device space that\r\napproximates the expected resolution of the target device. Further\r\ntransformations might need to be applied at playback time if the\r\nestimate is incorrect.\r\n<p>\r\nSome of the operations performed by the rendering attribute objects\r\noccur in the device space, but all <code>Graphics2D</code> methods take\r\nuser space coordinates.\r\n<p>\r\nEvery <code>Graphics2D</code> object is associated with a target that\r\ndefines where rendering takes place. A\r\n{@link GraphicsConfiguration} object defines the characteristics\r\nof the rendering target, such as pixel format and resolution.\r\nThe same rendering target is used throughout the life of a\r\n<code>Graphics2D</code> object.\r\n<p>\r\nWhen creating a <code>Graphics2D</code> object,  the\r\n<code>GraphicsConfiguration</code>\r\nspecifies the <a name=\"deftransform\">default transform</a> for\r\nthe target of the <code>Graphics2D</code> (a\r\n{@link Component} or {@link Image}).  This default transform maps the\r\nuser space coordinate system to screen and printer device coordinates\r\nsuch that the origin maps to the upper left hand corner of the\r\ntarget region of the device with increasing X coordinates extending\r\nto the right and increasing Y coordinates extending downward.\r\nThe scaling of the default transform is set to identity for those devices\r\nthat are close to 72 dpi, such as screen devices.\r\nThe scaling of the default transform is set to approximately 72 user\r\nspace coordinates per square inch for high resolution devices, such as\r\nprinters.  For image buffers, the default transform is the\r\n<code>Identity</code> transform.\r\n\r\n<h2>Rendering Process</h2>\r\nThe Rendering Process can be broken down into four phases that are\r\ncontrolled by the <code>Graphics2D</code> rendering attributes.\r\nThe renderer can optimize many of these steps, either by caching the\r\nresults for future calls, by collapsing multiple virtual steps into\r\na single operation, or by recognizing various attributes as common\r\nsimple cases that can be eliminated by modifying other parts of the\r\noperation.\r\n<p>\r\nThe steps in the rendering process are:\r\n<ol>\r\n<li>\r\nDetermine what to render.\r\n<li>\r\nConstrain the rendering operation to the current <code>Clip</code>.\r\nThe <code>Clip</code> is specified by a {@link Shape} in user\r\nspace and is controlled by the program using the various clip\r\nmanipulation methods of <code>Graphics</code> and\r\n<code>Graphics2D</code>.  This <i>user clip</i>\r\nis transformed into device space by the current\r\n<code>Transform</code> and combined with the\r\n<i>device clip</i>, which is defined by the visibility of windows and\r\ndevice extents.  The combination of the user clip and device clip\r\ndefines the <i>composite clip</i>, which determines the final clipping\r\nregion.  The user clip is not modified by the rendering\r\nsystem to reflect the resulting composite clip.\r\n<li>\r\nDetermine what colors to render.\r\n<li>\r\nApply the colors to the destination drawing surface using the current\r\n{@link Composite} attribute in the <code>Graphics2D</code> context.\r\n</ol>\r\n<br>\r\nThe three types of rendering operations, along with details of each\r\nof their particular rendering processes are:\r\n<ol>\r\n<li>\r\n<b><a name=\"rendershape\"><code>Shape</code> operations</a></b>\r\n<ol>\r\n<li>\r\nIf the operation is a <code>draw(Shape)</code> operation, then\r\nthe  {@link Stroke#createStrokedShape(Shape) createStrokedShape}\r\nmethod on the current {@link Stroke} attribute in the\r\n<code>Graphics2D</code> context is used to construct a new\r\n<code>Shape</code> object that contains the outline of the specified\r\n<code>Shape</code>.\r\n<li>\r\nThe <code>Shape</code> is transformed from user space to device space\r\nusing the current <code>Transform</code>\r\nin the <code>Graphics2D</code> context.\r\n<li>\r\nThe outline of the <code>Shape</code> is extracted using the\r\n{@link Shape#getPathIterator(AffineTransform) getPathIterator} method of\r\n<code>Shape</code>, which returns a\r\n{@link java.awt.geom.PathIterator PathIterator}\r\nobject that iterates along the boundary of the <code>Shape</code>.\r\n<li>\r\nIf the <code>Graphics2D</code> object cannot handle the curved segments\r\nthat the <code>PathIterator</code> object returns then it can call the\r\nalternate\r\n{@link Shape#getPathIterator(AffineTransform, double) getPathIterator}\r\nmethod of <code>Shape</code>, which flattens the <code>Shape</code>.\r\n<li>\r\nThe current {@link Paint} in the <code>Graphics2D</code> context\r\nis queried for a {@link PaintContext}, which specifies the\r\ncolors to render in device space.\r\n</ol>\r\n<li>\r\n<b><a name=rendertext>Text operations</a></b>\r\n<ol>\r\n<li>\r\nThe following steps are used to determine the set of glyphs required\r\nto render the indicated <code>String</code>:\r\n<ol>\r\n<li>\r\nIf the argument is a <code>String</code>, then the current\r\n<code>Font</code> in the <code>Graphics2D</code> context is asked to\r\nconvert the Unicode characters in the <code>String</code> into a set of\r\nglyphs for presentation with whatever basic layout and shaping\r\nalgorithms the font implements.\r\n<li>\r\nIf the argument is an\r\n{@link AttributedCharacterIterator},\r\nthe iterator is asked to convert itself to a\r\n{@link java.awt.font.TextLayout TextLayout}\r\nusing its embedded font attributes. The <code>TextLayout</code>\r\nimplements more sophisticated glyph layout algorithms that\r\nperform Unicode bi-directional layout adjustments automatically\r\nfor multiple fonts of differing writing directions.\r\n<li>\r\nIf the argument is a\r\n{@link GlyphVector}, then the\r\n<code>GlyphVector</code> object already contains the appropriate\r\nfont-specific glyph codes with explicit coordinates for the position of\r\neach glyph.\r\n</ol>\r\n<li>\r\nThe current <code>Font</code> is queried to obtain outlines for the\r\nindicated glyphs.  These outlines are treated as shapes in user space\r\nrelative to the position of each glyph that was determined in step 1.\r\n<li>\r\nThe character outlines are filled as indicated above\r\nunder <a href=\"#rendershape\"><code>Shape</code> operations</a>.\r\n<li>\r\nThe current <code>Paint</code> is queried for a\r\n<code>PaintContext</code>, which specifies\r\nthe colors to render in device space.\r\n</ol>\r\n<li>\r\n<b><a name= renderingimage><code>Image</code> Operations</a></b>\r\n<ol>\r\n<li>\r\nThe region of interest is defined by the bounding box of the source\r\n<code>Image</code>.\r\nThis bounding box is specified in Image Space, which is the\r\n<code>Image</code> object's local coordinate system.\r\n<li>\r\nIf an <code>AffineTransform</code> is passed to\r\n{@link #drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver) drawImage(Image, AffineTransform, ImageObserver)},\r\nthe <code>AffineTransform</code> is used to transform the bounding\r\nbox from image space to user space. If no <code>AffineTransform</code>\r\nis supplied, the bounding box is treated as if it is already in user space.\r\n<li>\r\nThe bounding box of the source <code>Image</code> is transformed from user\r\nspace into device space using the current <code>Transform</code>.\r\nNote that the result of transforming the bounding box does not\r\nnecessarily result in a rectangular region in device space.\r\n<li>\r\nThe <code>Image</code> object determines what colors to render,\r\nsampled according to the source to destination\r\ncoordinate mapping specified by the current <code>Transform</code> and the\r\noptional image transform.\r\n</ol>\r\n</ol>\r\n\r\n<h2>Default Rendering Attributes</h2>\r\nThe default values for the <code>Graphics2D</code> rendering attributes are:\r\n<dl compact>\r\n<dt><i><code>Paint</code></i>\r\n<dd>The color of the <code>Component</code>.\r\n<dt><i><code>Font</code></i>\r\n<dd>The <code>Font</code> of the <code>Component</code>.\r\n<dt><i><code>Stroke</code></i>\r\n<dd>A square pen with a linewidth of 1, no dashing, miter segment joins\r\nand square end caps.\r\n<dt><i><code>Transform</code></i>\r\n<dd>The\r\n{@link GraphicsConfiguration#getDefaultTransform() getDefaultTransform}\r\nfor the <code>GraphicsConfiguration</code> of the <code>Component</code>.\r\n<dt><i><code>Composite</code></i>\r\n<dd>The {@link AlphaComposite#SRC_OVER} rule.\r\n<dt><i><code>Clip</code></i>\r\n<dd>No rendering <code>Clip</code>, the output is clipped to the\r\n<code>Component</code>.\r\n</dl>\r\n\r\n<h2>Rendering Compatibility Issues</h2>\r\nThe JDK(tm) 1.1 rendering model is based on a pixelization model\r\nthat specifies that coordinates\r\nare infinitely thin, lying between the pixels.  Drawing operations are\r\nperformed using a one-pixel wide pen that fills the\r\npixel below and to the right of the anchor point on the path.\r\nThe JDK 1.1 rendering model is consistent with the\r\ncapabilities of most of the existing class of platform\r\nrenderers that need  to resolve integer coordinates to a\r\ndiscrete pen that must fall completely on a specified number of pixels.\r\n<p>\r\nThe Java 2D(tm) (Java(tm) 2 platform) API supports antialiasing renderers.\r\nA pen with a width of one pixel does not need to fall\r\ncompletely on pixel N as opposed to pixel N+1.  The pen can fall\r\npartially on both pixels. It is not necessary to choose a bias\r\ndirection for a wide pen since the blending that occurs along the\r\npen traversal edges makes the sub-pixel position of the pen\r\nvisible to the user.  On the other hand, when antialiasing is\r\nturned off by setting the\r\n{@link RenderingHints#KEY_ANTIALIASING KEY_ANTIALIASING} hint key\r\nto the\r\n{@link RenderingHints#VALUE_ANTIALIAS_OFF VALUE_ANTIALIAS_OFF}\r\nhint value, the renderer might need\r\nto apply a bias to determine which pixel to modify when the pen\r\nis straddling a pixel boundary, such as when it is drawn\r\nalong an integer coordinate in device space.  While the capabilities\r\nof an antialiasing renderer make it no longer necessary for the\r\nrendering model to specify a bias for the pen, it is desirable for the\r\nantialiasing and non-antialiasing renderers to perform similarly for\r\nthe common cases of drawing one-pixel wide horizontal and vertical\r\nlines on the screen.  To ensure that turning on antialiasing by\r\nsetting the\r\n{@link RenderingHints#KEY_ANTIALIASING KEY_ANTIALIASING} hint\r\nkey to\r\n{@link RenderingHints#VALUE_ANTIALIAS_ON VALUE_ANTIALIAS_ON}\r\ndoes not cause such lines to suddenly become twice as wide and half\r\nas opaque, it is desirable to have the model specify a path for such\r\nlines so that they completely cover a particular set of pixels to help\r\nincrease their crispness.\r\n<p>\r\nJava 2D API maintains compatibility with JDK 1.1 rendering\r\nbehavior, such that legacy operations and existing renderer\r\nbehavior is unchanged under Java 2D API.  Legacy\r\nmethods that map onto general <code>draw</code> and\r\n<code>fill</code> methods are defined, which clearly indicates\r\nhow <code>Graphics2D</code> extends <code>Graphics</code> based\r\non settings of <code>Stroke</code> and <code>Transform</code>\r\nattributes and rendering hints.  The definition\r\nperforms identically under default attribute settings.\r\nFor example, the default <code>Stroke</code> is a\r\n<code>BasicStroke</code> with a width of 1 and no dashing and the\r\ndefault Transform for screen drawing is an Identity transform.\r\n<p>\r\nThe following two rules provide predictable rendering behavior whether\r\naliasing or antialiasing is being used.\r\n<ul>\r\n<li> Device coordinates are defined to be between device pixels which\r\navoids any inconsistent results between aliased and antialiased\r\nrendering.  If coordinates were defined to be at a pixel's center, some\r\nof the pixels covered by a shape, such as a rectangle, would only be\r\nhalf covered.\r\nWith aliased rendering, the half covered pixels would either be\r\nrendered inside the shape or outside the shape.  With anti-aliased\r\nrendering, the pixels on the entire edge of the shape would be half\r\ncovered.  On the other hand, since coordinates are defined to be\r\nbetween pixels, a shape like a rectangle would have no half covered\r\npixels, whether or not it is rendered using antialiasing.\r\n<li> Lines and paths stroked using the <code>BasicStroke</code>\r\nobject may be \"normalized\" to provide consistent rendering of the\r\noutlines when positioned at various points on the drawable and\r\nwhether drawn with aliased or antialiased rendering.  This\r\nnormalization process is controlled by the\r\n{@link RenderingHints#KEY_STROKE_CONTROL KEY_STROKE_CONTROL} hint.\r\nThe exact normalization algorithm is not specified, but the goals\r\nof this normalization are to ensure that lines are rendered with\r\nconsistent visual appearance regardless of how they fall on the\r\npixel grid and to promote more solid horizontal and vertical\r\nlines in antialiased mode so that they resemble their non-antialiased\r\ncounterparts more closely.  A typical normalization step might\r\npromote antialiased line endpoints to pixel centers to reduce the\r\namount of blending or adjust the subpixel positioning of\r\nnon-antialiased lines so that the floating point line widths\r\nround to even or odd pixel counts with equal likelihood.  This\r\nprocess can move endpoints by up to half a pixel (usually towards\r\npositive infinity along both axes) to promote these consistent\r\nresults.\r\n</ul>\r\n<p>\r\nThe following definitions of general legacy methods\r\nperform identically to previously specified behavior under default\r\nattribute settings:\r\n<ul>\r\n<li>\r\nFor <code>fill</code> operations, including <code>fillRect</code>,\r\n<code>fillRoundRect</code>, <code>fillOval</code>,\r\n<code>fillArc</code>, <code>fillPolygon</code>, and\r\n<code>clearRect</code>, {@link #fill(Shape) fill} can now be called\r\nwith the desired <code>Shape</code>.  For example, when filling a\r\nrectangle:\r\n<pre>\r\nfill(new Rectangle(x, y, w, h));\r\n</pre>\r\nis called.\r\n<p>\r\n<li>\r\nSimilarly, for draw operations, including <code>drawLine</code>,\r\n<code>drawRect</code>, <code>drawRoundRect</code>,\r\n<code>drawOval</code>, <code>drawArc</code>, <code>drawPolyline</code>,\r\nand <code>drawPolygon</code>, {@link #draw(Shape) draw} can now be\r\ncalled with the desired <code>Shape</code>.  For example, when drawing a\r\nrectangle:\r\n<pre>\r\ndraw(new Rectangle(x, y, w, h));\r\n</pre>\r\nis called.\r\n<p>\r\n<li>\r\nThe <code>draw3DRect</code> and <code>fill3DRect</code> methods were\r\nimplemented in terms of the <code>drawLine</code> and\r\n<code>fillRect</code> methods in the <code>Graphics</code> class which\r\nwould predicate their behavior upon the current <code>Stroke</code>\r\nand <code>Paint</code> objects in a <code>Graphics2D</code> context.\r\nThis class overrides those implementations with versions that use\r\nthe current <code>Color</code> exclusively, overriding the current\r\n<code>Paint</code> and which uses <code>fillRect</code> to describe\r\nthe exact same behavior as the preexisting methods regardless of the\r\nsetting of the current <code>Stroke</code>.\r\n</ul>\r\nThe <code>Graphics</code> class defines only the <code>setColor</code>\r\nmethod to control the color to be painted.  Since the Java 2D API extends\r\nthe <code>Color</code> object to implement the new <code>Paint</code>\r\ninterface, the existing\r\n<code>setColor</code> method is now a convenience method for setting the\r\ncurrent <code>Paint</code> attribute to a <code>Color</code> object.\r\n<code>setColor(c)</code> is equivalent to <code>setPaint(c)</code>.\r\n<p>\r\nThe <code>Graphics</code> class defines two methods for controlling\r\nhow colors are applied to the destination.\r\n<ol>\r\n<li>\r\nThe <code>setPaintMode</code> method is implemented as a convenience\r\nmethod to set the default <code>Composite</code>, equivalent to\r\n<code>setComposite(new AlphaComposite.SrcOver)</code>.\r\n<li>\r\nThe <code>setXORMode(Color xorcolor)</code> method is implemented\r\nas a convenience method to set a special <code>Composite</code> object that\r\nignores the <code>Alpha</code> components of source colors and sets the\r\ndestination color to the value:\r\n<pre>\r\ndstpixel = (PixelOf(srccolor) ^ PixelOf(xorcolor) ^ dstpixel);\r\n</pre>\r\n</ol>","inherit":["java.awt.Graphics"],"name":"java.awt.Graphics2D","type":false},{"description":"","inherit":["sun.awt.SunGraphicsCallback"],"name":"java.awt.GraphicsCallback","type":false},{"description":"","inherit":["java.awt.GraphicsCallback"],"name":"java.awt.GraphicsCallback.PaintCallback","type":false},{"description":"","inherit":["java.awt.GraphicsCallback"],"name":"java.awt.GraphicsCallback.PrintCallback","type":false},{"description":"","inherit":["java.awt.GraphicsCallback"],"name":"java.awt.GraphicsCallback.PaintAllCallback","type":false},{"description":"","inherit":["java.awt.GraphicsCallback"],"name":"java.awt.GraphicsCallback.PrintAllCallback","type":false},{"description":"","inherit":["java.awt.GraphicsCallback"],"name":"java.awt.GraphicsCallback.PeerPaintCallback","type":false},{"description":"","inherit":["java.awt.GraphicsCallback"],"name":"java.awt.GraphicsCallback.PeerPrintCallback","type":false},{"description":"","inherit":["java.awt.GraphicsCallback"],"name":"java.awt.GraphicsCallback.PaintHeavyweightComponentsCallback","type":false},{"description":"","inherit":["java.awt.GraphicsCallback"],"name":"java.awt.GraphicsCallback.PrintHeavyweightComponentsCallback","type":false},{"description":"The <code>GraphicsConfigTemplate</code> class is used to obtain a valid\r\n{@link GraphicsConfiguration}.  A user instantiates one of these\r\nobjects and then sets all non-default attributes as desired.  The\r\n{@link GraphicsDevice#getBestConfiguration} method found in the\r\n{@link GraphicsDevice} class is then called with this\r\n<code>GraphicsConfigTemplate</code>.  A valid\r\n<code>GraphicsConfiguration</code> is returned that meets or exceeds\r\nwhat was requested in the <code>GraphicsConfigTemplate</code>.","inherit":["java.io.Serializable"],"name":"java.awt.GraphicsConfigTemplate","type":false},{"description":"","inherit":[],"name":"java.awt.GraphicsConfiguration","type":false},{"description":"","inherit":["java.awt.BufferCapabilities"],"name":"java.awt.GraphicsConfiguration.DefaultBufferCapabilities","type":false},{"description":"The <code>GraphicsDevice</code> class describes the graphics devices\r\nthat might be available in a particular graphics environment.  These\r\ninclude screen and printer devices. Note that there can be many screens\r\nand many printers in an instance of {@link GraphicsEnvironment}. Each\r\ngraphics device has one or more {@link GraphicsConfiguration} objects\r\nassociated with it.  These objects specify the different configurations\r\nin which the <code>GraphicsDevice</code> can be used.\r\n<p>\r\nIn a multi-screen environment, the <code>GraphicsConfiguration</code>\r\nobjects can be used to render components on multiple screens.  The\r\nfollowing code sample demonstrates how to create a <code>JFrame</code>\r\nobject for each <code>GraphicsConfiguration</code> on each screen\r\ndevice in the <code>GraphicsEnvironment</code>:\r\n<pre>{@code\r\n  GraphicsEnvironment ge = GraphicsEnvironment.\r\n  getLocalGraphicsEnvironment();\r\n  GraphicsDevice[] gs = ge.getScreenDevices();\r\n  for (int j = 0; j < gs.length; j++) {\r\n     GraphicsDevice gd = gs[j];\r\n     GraphicsConfiguration[] gc =\r\n     gd.getConfigurations();\r\n     for (int i=0; i < gc.length; i++) {\r\n        JFrame f = new\r\n        JFrame(gs[j].getDefaultConfiguration());\r\n        Canvas c = new Canvas(gc[i]);\r\n        Rectangle gcBounds = gc[i].getBounds();\r\n        int xoffs = gcBounds.x;\r\n        int yoffs = gcBounds.y;\r\n        f.getContentPane().add(c);\r\n        f.setLocation((i*50)+xoffs, (i*60)+yoffs);\r\n        f.show();\r\n     }\r\n  }\r\n}</pre>\r\n<p>\r\nFor more information on full-screen exclusive mode API, see the\r\n<a href=\"https://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html\">\r\nFull-Screen Exclusive Mode API Tutorial</a>.","inherit":[],"name":"java.awt.GraphicsDevice","type":false},{"description":"","inherit":[],"name":"java.awt.GraphicsEnvironment","type":false},{"description":"The <code>GridBagConstraints</code> class specifies constraints\r\nfor components that are laid out using the\r\n<code>GridBagLayout</code> class.","inherit":["java.lang.Cloneable","java.io.Serializable"],"name":"java.awt.GridBagConstraints","type":false},{"description":"The <code>GridBagLayout</code> class is a flexible layout\r\nmanager that aligns components vertically, horizontally or along their\r\nbaseline without requiring that the components be of the same size.\r\nEach <code>GridBagLayout</code> object maintains a dynamic,\r\nrectangular grid of cells, with each component occupying\r\none or more cells, called its <em>display area</em>.\r\n<p>\r\nEach component managed by a <code>GridBagLayout</code> is associated with\r\nan instance of {@link GridBagConstraints}.  The constraints object\r\nspecifies where a component's display area should be located on the grid\r\nand how the component should be positioned within its display area.  In\r\naddition to its constraints object, the <code>GridBagLayout</code> also\r\nconsiders each component's minimum and preferred sizes in order to\r\ndetermine a component's size.\r\n<p>\r\nThe overall orientation of the grid depends on the container's\r\n{@link ComponentOrientation} property.  For horizontal left-to-right\r\norientations, grid coordinate (0,0) is in the upper left corner of the\r\ncontainer with x increasing to the right and y increasing downward.  For\r\nhorizontal right-to-left orientations, grid coordinate (0,0) is in the upper\r\nright corner of the container with x increasing to the left and y\r\nincreasing downward.\r\n<p>\r\nTo use a grid bag layout effectively, you must customize one or more\r\nof the <code>GridBagConstraints</code> objects that are associated\r\nwith its components. You customize a <code>GridBagConstraints</code>\r\nobject by setting one or more of its instance variables:\r\n\r\n<dl>\r\n<dt>{@link GridBagConstraints#gridx},\r\n{@link GridBagConstraints#gridy}\r\n<dd>Specifies the cell containing the leading corner of the component's\r\ndisplay area, where the cell at the origin of the grid has address\r\n<code>gridx&nbsp;=&nbsp;0</code>,\r\n<code>gridy&nbsp;=&nbsp;0</code>.  For horizontal left-to-right layout,\r\na component's leading corner is its upper left.  For horizontal\r\nright-to-left layout, a component's leading corner is its upper right.\r\nUse <code>GridBagConstraints.RELATIVE</code> (the default value)\r\nto specify that the component be placed immediately following\r\n(along the x axis for <code>gridx</code> or the y axis for\r\n<code>gridy</code>) the component that was added to the container\r\njust before this component was added.\r\n<dt>{@link GridBagConstraints#gridwidth},\r\n{@link GridBagConstraints#gridheight}\r\n<dd>Specifies the number of cells in a row (for <code>gridwidth</code>)\r\nor column (for <code>gridheight</code>)\r\nin the component's display area.\r\nThe default value is 1.\r\nUse <code>GridBagConstraints.REMAINDER</code> to specify\r\nthat the component's display area will be from <code>gridx</code>\r\nto the last cell in the row (for <code>gridwidth</code>)\r\nor from <code>gridy</code> to the last cell in the column\r\n(for <code>gridheight</code>).\r\n\r\nUse <code>GridBagConstraints.RELATIVE</code> to specify\r\nthat the component's display area will be from <code>gridx</code>\r\nto the next to the last cell in its row (for <code>gridwidth</code>\r\nor from <code>gridy</code> to the next to the last cell in its\r\ncolumn (for <code>gridheight</code>).\r\n\r\n<dt>{@link GridBagConstraints#fill}\r\n<dd>Used when the component's display area\r\nis larger than the component's requested size\r\nto determine whether (and how) to resize the component.\r\nPossible values are\r\n<code>GridBagConstraints.NONE</code> (the default),\r\n<code>GridBagConstraints.HORIZONTAL</code>\r\n(make the component wide enough to fill its display area\r\nhorizontally, but don't change its height),\r\n<code>GridBagConstraints.VERTICAL</code>\r\n(make the component tall enough to fill its display area\r\nvertically, but don't change its width), and\r\n<code>GridBagConstraints.BOTH</code>\r\n(make the component fill its display area entirely).\r\n<dt>{@link GridBagConstraints#ipadx},\r\n{@link GridBagConstraints#ipady}\r\n<dd>Specifies the component's internal padding within the layout,\r\nhow much to add to the minimum size of the component.\r\nThe width of the component will be at least its minimum width\r\nplus <code>ipadx</code> pixels. Similarly, the height of\r\nthe component will be at least the minimum height plus\r\n<code>ipady</code> pixels.\r\n<dt>{@link GridBagConstraints#insets}\r\n<dd>Specifies the component's external padding, the minimum\r\namount of space between the component and the edges of its display area.\r\n<dt>{@link GridBagConstraints#anchor}\r\n<dd>Specifies where the component should be positioned in its display area.\r\nThere are three kinds of possible values: absolute, orientation-relative,\r\nand baseline-relative\r\nOrientation relative values are interpreted relative to the container's\r\n<code>ComponentOrientation</code> property while absolute values\r\nare not.  Baseline relative values are calculated relative to the\r\nbaseline.  Valid values are:\r\n\r\n<center><table BORDER=0 WIDTH=800\r\n       SUMMARY=\"absolute, relative and baseline values as described above\">\r\n<tr>\r\n<th><P style=\"text-align:left\">Absolute Values</th>\r\n<th><P style=\"text-align:left\">Orientation Relative Values</th>\r\n<th><P style=\"text-align:left\">Baseline Relative Values</th>\r\n</tr>\r\n<tr>\r\n<td>\r\n<ul style=\"list-style-type:none\">\r\n<li><code>GridBagConstraints.NORTH</code></li>\r\n<li><code>GridBagConstraints.SOUTH</code></li>\r\n<li><code>GridBagConstraints.WEST</code></li>\r\n<li><code>GridBagConstraints.EAST</code></li>\r\n<li><code>GridBagConstraints.NORTHWEST</code></li>\r\n<li><code>GridBagConstraints.NORTHEAST</code></li>\r\n<li><code>GridBagConstraints.SOUTHWEST</code></li>\r\n<li><code>GridBagConstraints.SOUTHEAST</code></li>\r\n<li><code>GridBagConstraints.CENTER</code> (the default)</li>\r\n</ul>\r\n</td>\r\n<td>\r\n<ul style=\"list-style-type:none\">\r\n<li><code>GridBagConstraints.PAGE_START</code></li>\r\n<li><code>GridBagConstraints.PAGE_END</code></li>\r\n<li><code>GridBagConstraints.LINE_START</code></li>\r\n<li><code>GridBagConstraints.LINE_END</code></li>\r\n<li><code>GridBagConstraints.FIRST_LINE_START</code></li>\r\n<li><code>GridBagConstraints.FIRST_LINE_END</code></li>\r\n<li><code>GridBagConstraints.LAST_LINE_START</code></li>\r\n<li><code>GridBagConstraints.LAST_LINE_END</code></li>\r\n</ul>\r\n</td>\r\n<td>\r\n<ul style=\"list-style-type:none\">\r\n<li><code>GridBagConstraints.BASELINE</code></li>\r\n<li><code>GridBagConstraints.BASELINE_LEADING</code></li>\r\n<li><code>GridBagConstraints.BASELINE_TRAILING</code></li>\r\n<li><code>GridBagConstraints.ABOVE_BASELINE</code></li>\r\n<li><code>GridBagConstraints.ABOVE_BASELINE_LEADING</code></li>\r\n<li><code>GridBagConstraints.ABOVE_BASELINE_TRAILING</code></li>\r\n<li><code>GridBagConstraints.BELOW_BASELINE</code></li>\r\n<li><code>GridBagConstraints.BELOW_BASELINE_LEADING</code></li>\r\n<li><code>GridBagConstraints.BELOW_BASELINE_TRAILING</code></li>\r\n</ul>\r\n</td>\r\n</tr>\r\n</table></center>\r\n<dt>{@link GridBagConstraints#weightx},\r\n{@link GridBagConstraints#weighty}\r\n<dd>Used to determine how to distribute space, which is\r\nimportant for specifying resizing behavior.\r\nUnless you specify a weight for at least one component\r\nin a row (<code>weightx</code>) and column (<code>weighty</code>),\r\nall the components clump together in the center of their container.\r\nThis is because when the weight is zero (the default),\r\nthe <code>GridBagLayout</code> object puts any extra space\r\nbetween its grid of cells and the edges of the container.\r\n</dl>\r\n<p>\r\nEach row may have a baseline; the baseline is determined by the\r\ncomponents in that row that have a valid baseline and are aligned\r\nalong the baseline (the component's anchor value is one of {@code\r\nBASELINE}, {@code BASELINE_LEADING} or {@code BASELINE_TRAILING}).\r\nIf none of the components in the row has a valid baseline, the row\r\ndoes not have a baseline.\r\n<p>\r\nIf a component spans rows it is aligned either to the baseline of\r\nthe start row (if the baseline-resize behavior is {@code\r\nCONSTANT_ASCENT}) or the end row (if the baseline-resize behavior\r\nis {@code CONSTANT_DESCENT}).  The row that the component is\r\naligned to is called the <em>prevailing row</em>.\r\n<p>\r\nThe following figure shows a baseline layout and includes a\r\ncomponent that spans rows:\r\n<center><table summary=\"Baseline Layout\">\r\n<tr ALIGN=CENTER>\r\n<td>\r\n<img src=\"doc-files/GridBagLayout-baseline.png\"\r\n alt=\"The following text describes this graphic (Figure 1).\" style=\"float:center\">\r\n</td>\r\n</table></center>\r\nThis layout consists of three components:\r\n<ul><li>A panel that starts in row 0 and ends in row 1.  The panel\r\n  has a baseline-resize behavior of <code>CONSTANT_DESCENT</code> and has\r\n  an anchor of <code>BASELINE</code>.  As the baseline-resize behavior\r\n  is <code>CONSTANT_DESCENT</code> the prevailing row for the panel is\r\n  row 1.\r\n<li>Two buttons, each with a baseline-resize behavior of\r\n  <code>CENTER_OFFSET</code> and an anchor of <code>BASELINE</code>.\r\n</ul>\r\nBecause the second button and the panel share the same prevailing row,\r\nthey are both aligned along their baseline.\r\n<p>\r\nComponents positioned using one of the baseline-relative values resize\r\ndifferently than when positioned using an absolute or orientation-relative\r\nvalue.  How components change is dictated by how the baseline of the\r\nprevailing row changes.  The baseline is anchored to the\r\nbottom of the display area if any components with the same prevailing row\r\nhave a baseline-resize behavior of <code>CONSTANT_DESCENT</code>,\r\notherwise the baseline is anchored to the top of the display area.\r\nThe following rules dictate the resize behavior:\r\n<ul>\r\n<li>Resizable components positioned above the baseline can only\r\ngrow as tall as the baseline.  For example, if the baseline is at 100\r\nand anchored at the top, a resizable component positioned above the\r\nbaseline can never grow more than 100 units.\r\n<li>Similarly, resizable components positioned below the baseline can\r\nonly grow as high as the difference between the display height and the\r\nbaseline.\r\n<li>Resizable components positioned on the baseline with a\r\nbaseline-resize behavior of <code>OTHER</code> are only resized if\r\nthe baseline at the resized size fits within the display area.  If\r\nthe baseline is such that it does not fit within the display area\r\nthe component is not resized.\r\n<li>Components positioned on the baseline that do not have a\r\nbaseline-resize behavior of <code>OTHER</code>\r\ncan only grow as tall as {@code display height - baseline + baseline of component}.\r\n</ul>\r\nIf you position a component along the baseline, but the\r\ncomponent does not have a valid baseline, it will be vertically centered\r\nin its space.  Similarly if you have positioned a component relative\r\nto the baseline and none of the components in the row have a valid\r\nbaseline the component is vertically centered.\r\n<p>\r\nThe following figures show ten components (all buttons)\r\nmanaged by a grid bag layout.  Figure 2 shows the layout for a horizontal,\r\nleft-to-right container and Figure 3 shows the layout for a horizontal,\r\nright-to-left container.\r\n\r\n<center><table WIDTH=600 summary=\"layout\">\r\n<tr ALIGN=CENTER>\r\n<td>\r\n<img src=\"doc-files/GridBagLayout-1.gif\" alt=\"The preceding text describes this graphic (Figure 1).\" style=\"float:center; margin: 7px 10px;\">\r\n</td>\r\n<td>\r\n<img src=\"doc-files/GridBagLayout-2.gif\" alt=\"The preceding text describes this graphic (Figure 2).\" style=\"float:center; margin: 7px 10px;\">\r\n</td>\r\n<tr ALIGN=CENTER>\r\n<td>Figure 2: Horizontal, Left-to-Right</td>\r\n<td>Figure 3: Horizontal, Right-to-Left</td>\r\n</tr>\r\n</table></center>\r\n<p>\r\nEach of the ten components has the <code>fill</code> field\r\nof its associated <code>GridBagConstraints</code> object\r\nset to <code>GridBagConstraints.BOTH</code>.\r\nIn addition, the components have the following non-default constraints:\r\n\r\n<ul>\r\n<li>Button1, Button2, Button3: <code>weightx&nbsp;=&nbsp;1.0</code>\r\n<li>Button4: <code>weightx&nbsp;=&nbsp;1.0</code>,\r\n<code>gridwidth&nbsp;=&nbsp;GridBagConstraints.REMAINDER</code>\r\n<li>Button5: <code>gridwidth&nbsp;=&nbsp;GridBagConstraints.REMAINDER</code>\r\n<li>Button6: <code>gridwidth&nbsp;=&nbsp;GridBagConstraints.RELATIVE</code>\r\n<li>Button7: <code>gridwidth&nbsp;=&nbsp;GridBagConstraints.REMAINDER</code>\r\n<li>Button8: <code>gridheight&nbsp;=&nbsp;2</code>,\r\n<code>weighty&nbsp;=&nbsp;1.0</code>\r\n<li>Button9, Button 10:\r\n<code>gridwidth&nbsp;=&nbsp;GridBagConstraints.REMAINDER</code>\r\n</ul>\r\n<p>\r\nHere is the code that implements the example shown above:\r\n\r\n<hr><blockquote><pre>\r\nimport java.awt.*;\r\nimport java.util.*;\r\nimport java.applet.Applet;\r\n\r\npublic class GridBagEx1 extends Applet {\r\n\r\n    protected void makebutton(String name,\r\n                              GridBagLayout gridbag,\r\n                              GridBagConstraints c) {\r\n        Button button = new Button(name);\r\n        gridbag.setConstraints(button, c);\r\n        add(button);\r\n    }\r\n\r\n    public void init() {\r\n        GridBagLayout gridbag = new GridBagLayout();\r\n        GridBagConstraints c = new GridBagConstraints();\r\n\r\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 14));\r\n        setLayout(gridbag);\r\n\r\n        c.fill = GridBagConstraints.BOTH;\r\n        c.weightx = 1.0;\r\n        makebutton(\"Button1\", gridbag, c);\r\n        makebutton(\"Button2\", gridbag, c);\r\n        makebutton(\"Button3\", gridbag, c);\r\n\r\n        c.gridwidth = GridBagConstraints.REMAINDER; //end row\r\n        makebutton(\"Button4\", gridbag, c);\r\n\r\n        c.weightx = 0.0;                //reset to the default\r\n        makebutton(\"Button5\", gridbag, c); //another row\r\n\r\n        c.gridwidth = GridBagConstraints.RELATIVE; //next-to-last in row\r\n        makebutton(\"Button6\", gridbag, c);\r\n\r\n        c.gridwidth = GridBagConstraints.REMAINDER; //end row\r\n        makebutton(\"Button7\", gridbag, c);\r\n\r\n        c.gridwidth = 1;                //reset to the default\r\n        c.gridheight = 2;\r\n        c.weighty = 1.0;\r\n        makebutton(\"Button8\", gridbag, c);\r\n\r\n        c.weighty = 0.0;                //reset to the default\r\n        c.gridwidth = GridBagConstraints.REMAINDER; //end row\r\n        c.gridheight = 1;               //reset to the default\r\n        makebutton(\"Button9\", gridbag, c);\r\n        makebutton(\"Button10\", gridbag, c);\r\n\r\n        setSize(300, 100);\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        Frame f = new Frame(\"GridBag Layout Example\");\r\n        GridBagEx1 ex1 = new GridBagEx1();\r\n\r\n        ex1.init();\r\n\r\n        f.add(\"Center\", ex1);\r\n        f.pack();\r\n        f.setSize(f.getPreferredSize());\r\n        f.show();\r\n    }\r\n}\r\n</pre></blockquote><hr>\r\n<p>","inherit":["java.awt.LayoutManager2","java.io.Serializable"],"name":"java.awt.GridBagLayout","type":false},{"description":"The {@code GridBagLayoutInfo} is an utility class for\r\n{@code GridBagLayout} layout manager.\r\nIt stores align, size and baseline parameters for every component within a container.\r\n<p>","inherit":["java.io.Serializable"],"name":"java.awt.GridBagLayoutInfo","type":false},{"description":"The <code>GridLayout</code> class is a layout manager that\r\nlays out a container's components in a rectangular grid.\r\nThe container is divided into equal-sized rectangles,\r\nand one component is placed in each rectangle.\r\nFor example, the following is an applet that lays out six buttons\r\ninto three rows and two columns:\r\n\r\n<hr><blockquote>\r\n<pre>\r\nimport java.awt.*;\r\nimport java.applet.Applet;\r\npublic class ButtonGrid extends Applet {\r\n    public void init() {\r\n        setLayout(new GridLayout(3,2));\r\n        add(new Button(\"1\"));\r\n        add(new Button(\"2\"));\r\n        add(new Button(\"3\"));\r\n        add(new Button(\"4\"));\r\n        add(new Button(\"5\"));\r\n        add(new Button(\"6\"));\r\n    }\r\n}\r\n</pre></blockquote><hr>\r\n<p>\r\nIf the container's <code>ComponentOrientation</code> property is horizontal\r\nand left-to-right, the above example produces the output shown in Figure 1.\r\nIf the container's <code>ComponentOrientation</code> property is horizontal\r\nand right-to-left, the example produces the output shown in Figure 2.\r\n\r\n<table style=\"float:center\" WIDTH=600 summary=\"layout\">\r\n<tr ALIGN=CENTER>\r\n<td><img SRC=\"doc-files/GridLayout-1.gif\"\r\n     alt=\"Shows 6 buttons in rows of 2. Row 1 shows buttons 1 then 2.\r\nRow 2 shows buttons 3 then 4. Row 3 shows buttons 5 then 6.\">\r\n</td>\r\n\r\n<td ALIGN=CENTER><img SRC=\"doc-files/GridLayout-2.gif\"\r\n                  alt=\"Shows 6 buttons in rows of 2. Row 1 shows buttons 2 then 1.\r\nRow 2 shows buttons 4 then 3. Row 3 shows buttons 6 then 5.\">\r\n</td>\r\n</tr>\r\n\r\n<tr ALIGN=CENTER>\r\n<td>Figure 1: Horizontal, Left-to-Right</td>\r\n\r\n<td>Figure 2: Horizontal, Right-to-Left</td>\r\n</tr>\r\n</table>\r\n<p>\r\nWhen both the number of rows and the number of columns have\r\nbeen set to non-zero values, either by a constructor or\r\nby the <tt>setRows</tt> and <tt>setColumns</tt> methods, the number of\r\ncolumns specified is ignored.  Instead, the number of\r\ncolumns is determined from the specified number of rows\r\nand the total number of components in the layout. So, for\r\nexample, if three rows and two columns have been specified\r\nand nine components are added to the layout, they will\r\nbe displayed as three rows of three columns.  Specifying\r\nthe number of columns affects the layout only when the\r\nnumber of rows is set to zero.","inherit":["java.awt.LayoutManager","java.io.Serializable"],"name":"java.awt.GridLayout","type":false},{"description":"Thrown when code that is dependent on a keyboard, display, or mouse\r\nis called in an environment that does not support a keyboard, display,\r\nor mouse.","inherit":["java.lang.UnsupportedOperationException"],"name":"java.awt.HeadlessException","type":false},{"description":"Signals that an AWT component is not in an appropriate state for\r\nthe requested operation.","inherit":["java.lang.IllegalStateException"],"name":"java.awt.IllegalComponentStateException","type":false},{"description":"","inherit":[],"name":"java.awt.im.InputContext","type":false},{"description":"","inherit":[],"name":"java.awt.im.InputMethodHighlight","type":false},{"description":"","inherit":[],"name":"java.awt.im.InputMethodRequests","type":true},{"description":"","inherit":["java.lang.Character.Subset"],"name":"java.awt.im.InputSubset","type":false},{"description":"","inherit":[],"name":"java.awt.im.spi.InputMethod","type":true},{"description":"","inherit":["java.awt.im.InputMethodRequests"],"name":"java.awt.im.spi.InputMethodContext","type":true},{"description":"","inherit":[],"name":"java.awt.im.spi.InputMethodDescriptor","type":true},{"description":"This class uses an affine transform to perform a linear mapping from\r\n2D coordinates in the source image or <CODE>Raster</CODE> to 2D coordinates\r\nin the destination image or <CODE>Raster</CODE>.\r\nThe type of interpolation that is used is specified through a constructor,\r\neither by a <CODE>RenderingHints</CODE> object or by one of the integer\r\ninterpolation types defined in this class.\r\n<p>\r\nIf a <CODE>RenderingHints</CODE> object is specified in the constructor, the\r\ninterpolation hint and the rendering quality hint are used to set\r\nthe interpolation type for this operation.  The color rendering hint\r\nand the dithering hint can be used when color conversion is required.\r\n<p>\r\nNote that the following constraints have to be met:\r\n<ul>\r\n<li>The source and destination must be different.\r\n<li>For <CODE>Raster</CODE> objects, the number of bands in the source must\r\nbe equal to the number of bands in the destination.\r\n</ul>","inherit":["java.awt.image.BufferedImageOp","java.awt.image.RasterOp"],"name":"java.awt.image.AffineTransformOp","type":false},{"description":"An ImageFilter class for scaling images using a simple area averaging\r\nalgorithm that produces smoother results than the nearest neighbor\r\nalgorithm.\r\n<p>This class extends the basic ImageFilter Class to scale an existing\r\nimage and provide a source for a new image containing the resampled\r\nimage.  The pixels in the source image are blended to produce pixels\r\nfor an image of the specified size.  The blending process is analogous\r\nto scaling up the source image to a multiple of the destination size\r\nusing pixel replication and then scaling it back down to the destination\r\nsize by simply averaging all the pixels in the supersized image that\r\nfall within a given pixel of the destination image.  If the data from\r\nthe source is not delivered in TopDownLeftRight order then the filter\r\nwill back off to a simple pixel replication behavior and utilize the\r\nrequestTopDownLeftRightResend() method to refilter the pixels in a\r\nbetter way at the end.\r\n<p>It is meant to be used in conjunction with a FilteredImageSource\r\nobject to produce scaled versions of existing images.  Due to\r\nimplementation dependencies, there may be differences in pixel values\r\nof an image filtered on different platforms.","inherit":["java.awt.image.ReplicateScaleFilter"],"name":"java.awt.image.AreaAveragingScaleFilter","type":false},{"description":"This class performs an arbitrary linear combination of the bands\r\nin a <CODE>Raster</CODE>, using a specified matrix.\r\n<p>\r\nThe width of the matrix must be equal to the number of bands in the\r\nsource <CODE>Raster</CODE>, optionally plus one.  If there is one more\r\ncolumn in the matrix than the number of bands, there is an implied 1 at the\r\nend of the vector of band samples representing a pixel.  The height\r\nof the matrix must be equal to the number of bands in the destination.\r\n<p>\r\nFor example, a 3-banded <CODE>Raster</CODE> might have the following\r\ntransformation applied to each pixel in order to invert the second band of\r\nthe <CODE>Raster</CODE>.\r\n<pre>\r\n  [ 1.0   0.0   0.0    0.0  ]     [ b1 ]\r\n  [ 0.0  -1.0   0.0  255.0  ]  x  [ b2 ]\r\n  [ 0.0   0.0   1.0    0.0  ]     [ b3 ]\r\n                                  [ 1 ]\r\n</pre>\r\n\r\n<p>\r\nNote that the source and destination can be the same object.","inherit":["java.awt.image.RasterOp"],"name":"java.awt.image.BandCombineOp","type":false},{"description":"","inherit":["java.awt.image.ComponentSampleModel"],"name":"java.awt.image.BandedSampleModel","type":false},{"description":"The <code>BufferedImage</code> subclass describes an {@link\r\njava.awt.Image Image} with an accessible buffer of image data.\r\nA <code>BufferedImage</code> is comprised of a {@link ColorModel} and a\r\n{@link Raster} of image data.\r\nThe number and types of bands in the {@link SampleModel} of the\r\n<code>Raster</code> must match the number and types required by the\r\n<code>ColorModel</code> to represent its color and alpha components.\r\nAll <code>BufferedImage</code> objects have an upper left corner\r\ncoordinate of (0,&nbsp;0).  Any <code>Raster</code> used to construct a\r\n<code>BufferedImage</code> must therefore have minX=0 and minY=0.\r\n\r\n<p>\r\nThis class relies on the data fetching and setting methods\r\nof <code>Raster</code>,\r\nand on the color characterization methods of <code>ColorModel</code>.","inherit":["java.awt.Image","java.awt.image.WritableRenderedImage","java.awt.Transparency"],"name":"java.awt.image.BufferedImage","type":false},{"description":"","inherit":["java.awt.image.ImageFilter","java.lang.Cloneable"],"name":"java.awt.image.BufferedImageFilter","type":false},{"description":"This interface describes single-input/single-output\r\noperations performed on <CODE>BufferedImage</CODE> objects.\r\nIt is implemented by <CODE>AffineTransformOp</CODE>,\r\n<CODE>ConvolveOp</CODE>, <CODE>ColorConvertOp</CODE>, <CODE>RescaleOp</CODE>,\r\nand <CODE>LookupOp</CODE>.  These objects can be passed into\r\na <CODE>BufferedImageFilter</CODE> to operate on a\r\n<CODE>BufferedImage</CODE> in the\r\nImageProducer-ImageFilter-ImageConsumer paradigm.\r\n<p>\r\nClasses that implement this\r\ninterface must specify whether or not they allow in-place filtering--\r\nfilter operations where the source object is equal to the destination\r\nobject.\r\n<p>\r\nThis interface cannot be used to describe more sophisticated operations\r\nsuch as those that take multiple sources. Note that this restriction also\r\nmeans that the values of the destination pixels prior to the operation are\r\nnot used as input to the filter operation.","inherit":[],"name":"java.awt.image.BufferedImageOp","type":true},{"description":"The <code>BufferStrategy</code> class represents the mechanism with which\r\nto organize complex memory on a particular <code>Canvas</code> or\r\n<code>Window</code>.  Hardware and software limitations determine whether and\r\nhow a particular buffer strategy can be implemented.  These limitations\r\nare detectable through the capabilities of the\r\n<code>GraphicsConfiguration</code> used when creating the\r\n<code>Canvas</code> or <code>Window</code>.\r\n<p>\r\nIt is worth noting that the terms <i>buffer</i> and <i>surface</i> are meant\r\nto be synonymous: an area of contiguous memory, either in video device\r\nmemory or in system memory.\r\n<p>\r\nThere are several types of complex buffer strategies, including\r\nsequential ring buffering and blit buffering.\r\nSequential ring buffering (i.e., double or triple\r\nbuffering) is the most common; an application draws to a single <i>back\r\nbuffer</i> and then moves the contents to the front (display) in a single\r\nstep, either by copying the data or moving the video pointer.\r\nMoving the video pointer exchanges the buffers so that the first buffer\r\ndrawn becomes the <i>front buffer</i>, or what is currently displayed on the\r\ndevice; this is called <i>page flipping</i>.\r\n<p>\r\nAlternatively, the contents of the back buffer can be copied, or\r\n<i>blitted</i> forward in a chain instead of moving the video pointer.\r\n<pre>{@code\r\nDouble buffering:\r\n\r\n                   ***********         ***********\r\n                   *         * ------> *         *\r\n[To display] <---- * Front B *   Show  * Back B. * <---- Rendering\r\n                   *         * <------ *         *\r\n                   ***********         ***********\r\n\r\nTriple buffering:\r\n\r\n[To      ***********         ***********        ***********\r\ndisplay] *         * --------+---------+------> *         *\r\n   <---- * Front B *   Show  * Mid. B. *        * Back B. * <---- Rendering\r\n         *         * <------ *         * <----- *         *\r\n         ***********         ***********        ***********\r\n\r\n}</pre>\r\n<p>\r\nHere is an example of how buffer strategies can be created and used:\r\n<pre><code>\r\n\r\n// Check the capabilities of the GraphicsConfiguration\r\n...\r\n\r\n// Create our component\r\nWindow w = new Window(gc);\r\n\r\n// Show our window\r\nw.setVisible(true);\r\n\r\n// Create a general double-buffering strategy\r\nw.createBufferStrategy(2);\r\nBufferStrategy strategy = w.getBufferStrategy();\r\n\r\n// Main loop\r\nwhile (!done) {\r\n    // Prepare for rendering the next frame\r\n    // ...\r\n\r\n    // Render single frame\r\n    do {\r\n        // The following loop ensures that the contents of the drawing buffer\r\n        // are consistent in case the underlying surface was recreated\r\n        do {\r\n            // Get a new graphics context every time through the loop\r\n            // to make sure the strategy is validated\r\n            Graphics graphics = strategy.getDrawGraphics();\r\n\r\n            // Render to graphics\r\n            // ...\r\n\r\n            // Dispose the graphics\r\n            graphics.dispose();\r\n\r\n            // Repeat the rendering if the drawing buffer contents\r\n            // were restored\r\n        } while (strategy.contentsRestored());\r\n\r\n        // Display the buffer\r\n        strategy.show();\r\n\r\n        // Repeat the rendering if the drawing buffer was lost\r\n    } while (strategy.contentsLost());\r\n}\r\n\r\n// Dispose the window\r\nw.setVisible(false);\r\nw.dispose();\r\n</code></pre>","inherit":[],"name":"java.awt.image.BufferStrategy","type":false},{"description":"This class defines a lookup table object.  The output of a\r\nlookup operation using an object of this class is interpreted\r\nas an unsigned byte quantity.  The lookup table contains byte\r\ndata arrays for one or more bands (or components) of an image,\r\nand it contains an offset which will be subtracted from the\r\ninput values before indexing the arrays.  This allows an array\r\nsmaller than the native data size to be provided for a\r\nconstrained input.  If there is only one array in the lookup\r\ntable, it will be applied to all bands.","inherit":["java.awt.image.LookupTable"],"name":"java.awt.image.ByteLookupTable","type":false},{"description":"This class performs a pixel-by-pixel color conversion of the data in\r\nthe source image.  The resulting color values are scaled to the precision\r\nof the destination image.  Color conversion can be specified\r\nvia an array of ColorSpace objects or an array of ICC_Profile objects.\r\n<p>\r\nIf the source is a BufferedImage with premultiplied alpha, the\r\ncolor components are divided by the alpha component before color conversion.\r\nIf the destination is a BufferedImage with premultiplied alpha, the\r\ncolor components are multiplied by the alpha component after conversion.\r\nRasters are treated as having no alpha channel, i.e. all bands are\r\ncolor bands.\r\n<p>\r\nIf a RenderingHints object is specified in the constructor, the\r\ncolor rendering hint and the dithering hint may be used to control\r\ncolor conversion.\r\n<p>\r\nNote that Source and Destination may be the same object.","inherit":["java.awt.image.BufferedImageOp","java.awt.image.RasterOp"],"name":"java.awt.image.ColorConvertOp","type":false},{"description":"The <code>ColorModel</code> abstract class encapsulates the\r\nmethods for translating a pixel value to color components\r\n(for example, red, green, and blue) and an alpha component.\r\nIn order to render an image to the screen, a printer, or another\r\nimage, pixel values must be converted to color and alpha components.\r\nAs arguments to or return values from methods of this class,\r\npixels are represented as 32-bit ints or as arrays of primitive types.\r\nThe number, order, and interpretation of color components for a\r\n<code>ColorModel</code> is specified by its <code>ColorSpace</code>.\r\nA <code>ColorModel</code> used with pixel data that does not include\r\nalpha information treats all pixels as opaque, which is an alpha\r\nvalue of 1.0.\r\n<p>\r\nThis <code>ColorModel</code> class supports two representations of\r\npixel values.  A pixel value can be a single 32-bit int or an\r\narray of primitive types.  The Java(tm) Platform 1.0 and 1.1 APIs\r\nrepresented pixels as single <code>byte</code> or single\r\n<code>int</code> values.  For purposes of the <code>ColorModel</code>\r\nclass, pixel value arguments were passed as ints.  The Java(tm) 2\r\nPlatform API introduced additional classes for representing images.\r\nWith {@link BufferedImage} or {@link RenderedImage}\r\nobjects, based on {@link Raster} and {@link SampleModel} classes, pixel\r\nvalues might not be conveniently representable as a single int.\r\nConsequently, <code>ColorModel</code> now has methods that accept\r\npixel values represented as arrays of primitive types.  The primitive\r\ntype used by a particular <code>ColorModel</code> object is called its\r\ntransfer type.\r\n<p>\r\n<code>ColorModel</code> objects used with images for which pixel values\r\nare not conveniently representable as a single int throw an\r\n{@link IllegalArgumentException} when methods taking a single int pixel\r\nargument are called.  Subclasses of <code>ColorModel</code> must\r\nspecify the conditions under which this occurs.  This does not\r\noccur with {@link DirectColorModel} or {@link IndexColorModel} objects.\r\n<p>\r\nCurrently, the transfer types supported by the Java 2D(tm) API are\r\nDataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT,\r\nDataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, and DataBuffer.TYPE_DOUBLE.\r\nMost rendering operations will perform much faster when using ColorModels\r\nand images based on the first three of these types.  In addition, some\r\nimage filtering operations are not supported for ColorModels and\r\nimages based on the latter three types.\r\nThe transfer type for a particular <code>ColorModel</code> object is\r\nspecified when the object is created, either explicitly or by default.\r\nAll subclasses of <code>ColorModel</code> must specify what the\r\npossible transfer types are and how the number of elements in the\r\nprimitive arrays representing pixels is determined.\r\n<p>\r\nFor <code>BufferedImages</code>, the transfer type of its\r\n<code>Raster</code> and of the <code>Raster</code> object's\r\n<code>SampleModel</code> (available from the\r\n<code>getTransferType</code> methods of these classes) must match that\r\nof the <code>ColorModel</code>.  The number of elements in an array\r\nrepresenting a pixel for the <code>Raster</code> and\r\n<code>SampleModel</code> (available from the\r\n<code>getNumDataElements</code> methods of these classes) must match\r\nthat of the <code>ColorModel</code>.\r\n<p>\r\nThe algorithm used to convert from pixel values to color and alpha\r\ncomponents varies by subclass.  For example, there is not necessarily\r\na one-to-one correspondence between samples obtained from the\r\n<code>SampleModel</code> of a <code>BufferedImage</code> object's\r\n<code>Raster</code> and color/alpha components.  Even when\r\nthere is such a correspondence, the number of bits in a sample is not\r\nnecessarily the same as the number of bits in the corresponding color/alpha\r\ncomponent.  Each subclass must specify how the translation from\r\npixel values to color/alpha components is done.\r\n<p>\r\nMethods in the <code>ColorModel</code> class use two different\r\nrepresentations of color and alpha components - a normalized form\r\nand an unnormalized form.  In the normalized form, each component is a\r\n<code>float</code> value between some minimum and maximum values.  For\r\nthe alpha component, the minimum is 0.0 and the maximum is 1.0.  For\r\ncolor components the minimum and maximum values for each component can\r\nbe obtained from the <code>ColorSpace</code> object.  These values\r\nwill often be 0.0 and 1.0 (e.g. normalized component values for the\r\ndefault sRGB color space range from 0.0 to 1.0), but some color spaces\r\nhave component values with different upper and lower limits.  These\r\nlimits can be obtained using the <code>getMinValue</code> and\r\n<code>getMaxValue</code> methods of the <code>ColorSpace</code>\r\nclass.  Normalized color component values are not premultiplied.\r\nAll <code>ColorModels</code> must support the normalized form.\r\n<p>\r\nIn the unnormalized\r\nform, each component is an unsigned integral value between 0 and\r\n2<sup>n</sup> - 1, where n is the number of significant bits for a\r\nparticular component.  If pixel values for a particular\r\n<code>ColorModel</code> represent color samples premultiplied by\r\nthe alpha sample, unnormalized color component values are\r\nalso premultiplied.  The unnormalized form is used only with instances\r\nof <code>ColorModel</code> whose <code>ColorSpace</code> has minimum\r\ncomponent values of 0.0 for all components and maximum values of\r\n1.0 for all components.\r\nThe unnormalized form for color and alpha components can be a convenient\r\nrepresentation for <code>ColorModels</code> whose normalized component\r\nvalues all lie\r\nbetween 0.0 and 1.0.  In such cases the integral value 0 maps to 0.0 and\r\nthe value 2<sup>n</sup> - 1 maps to 1.0.  In other cases, such as\r\nwhen the normalized component values can be either negative or positive,\r\nthe unnormalized form is not convenient.  Such <code>ColorModel</code>\r\nobjects throw an {@link IllegalArgumentException} when methods involving\r\nan unnormalized argument are called.  Subclasses of <code>ColorModel</code>\r\nmust specify the conditions under which this occurs.","inherit":["java.awt.Transparency"],"name":"java.awt.image.ColorModel","type":false},{"description":"A <CODE>ColorModel</CODE> class that works with pixel values that\r\nrepresent color and alpha information as separate samples and that\r\nstore each sample in a separate data element.  This class can be\r\nused with an arbitrary <CODE>ColorSpace</CODE>.  The number of\r\ncolor samples in the pixel values must be same as the number of\r\ncolor components in the <CODE>ColorSpace</CODE>. There may be a\r\nsingle alpha sample.\r\n<p>\r\nFor those methods that use\r\na primitive array pixel representation of type <CODE>transferType</CODE>,\r\nthe array length is the same as the number of color and alpha samples.\r\nColor samples are stored first in the array followed by the alpha\r\nsample, if present.  The order of the color samples is specified\r\nby the <CODE>ColorSpace</CODE>.  Typically, this order reflects the\r\nname of the color space type. For example, for <CODE>TYPE_RGB</CODE>,\r\nindex 0 corresponds to red, index 1 to green, and index 2 to blue.\r\n<p>\r\nThe translation from pixel sample values to color/alpha components for\r\ndisplay or processing purposes is based on a one-to-one correspondence of\r\nsamples to components.\r\nDepending on the transfer type used to create an instance of\r\n<code>ComponentColorModel</code>, the pixel sample values\r\nrepresented by that instance may be signed or unsigned and may\r\nbe of integral type or float or double (see below for details).\r\nThe translation from sample values to normalized color/alpha components\r\nmust follow certain rules.  For float and double samples, the translation\r\nis an identity, i.e. normalized component values are equal to the\r\ncorresponding sample values.  For integral samples, the translation\r\nshould be only a simple scale and offset, where the scale and offset\r\nconstants may be different for each component.  The result of\r\napplying the scale and offset constants is a set of color/alpha\r\ncomponent values, which are guaranteed to fall within a certain\r\nrange.  Typically, the range for a color component will be the range\r\ndefined by the <code>getMinValue</code> and <code>getMaxValue</code>\r\nmethods of the <code>ColorSpace</code> class.  The range for an\r\nalpha component should be 0.0 to 1.0.\r\n<p>\r\nInstances of <code>ComponentColorModel</code> created with transfer types\r\n<CODE>DataBuffer.TYPE_BYTE</CODE>, <CODE>DataBuffer.TYPE_USHORT</CODE>,\r\nand <CODE>DataBuffer.TYPE_INT</CODE> have pixel sample values which\r\nare treated as unsigned integral values.\r\nThe number of bits in a color or alpha sample of a pixel value might not\r\nbe the same as the number of bits for the corresponding color or alpha\r\nsample passed to the\r\n<code>ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)</code>\r\nconstructor.  In\r\nthat case, this class assumes that the least significant n bits of a sample\r\nvalue hold the component value, where n is the number of significant bits\r\nfor the component passed to the constructor.  It also assumes that\r\nany higher-order bits in a sample value are zero.  Thus, sample values\r\nrange from 0 to 2<sup>n</sup> - 1.  This class maps these sample values\r\nto normalized color component values such that 0 maps to the value\r\nobtained from the <code>ColorSpace's</code> <code>getMinValue</code>\r\nmethod for each component and 2<sup>n</sup> - 1 maps to the value\r\nobtained from <code>getMaxValue</code>.  To create a\r\n<code>ComponentColorModel</code> with a different color sample mapping\r\nrequires subclassing this class and overriding the\r\n<code>getNormalizedComponents(Object, float[], int)</code> method.\r\nThe mapping for an alpha sample always maps 0 to 0.0 and\r\n2<sup>n</sup> - 1 to 1.0.\r\n<p>\r\nFor instances with unsigned sample values,\r\nthe unnormalized color/alpha component representation is only\r\nsupported if two conditions hold.  First, sample value value 0 must\r\nmap to normalized component value 0.0 and sample value 2<sup>n</sup> - 1\r\nto 1.0.  Second the min/max range of all color components of the\r\n<code>ColorSpace</code> must be 0.0 to 1.0.  In this case, the\r\ncomponent representation is the n least\r\nsignificant bits of the corresponding sample.  Thus each component is\r\nan unsigned integral value between 0 and 2<sup>n</sup> - 1, where\r\nn is the number of significant bits for a particular component.\r\nIf these conditions are not met, any method taking an unnormalized\r\ncomponent argument will throw an <code>IllegalArgumentException</code>.\r\n<p>\r\nInstances of <code>ComponentColorModel</code> created with transfer types\r\n<CODE>DataBuffer.TYPE_SHORT</CODE>, <CODE>DataBuffer.TYPE_FLOAT</CODE>, and\r\n<CODE>DataBuffer.TYPE_DOUBLE</CODE> have pixel sample values which\r\nare treated as signed short, float, or double values.\r\nSuch instances do not support the unnormalized color/alpha component\r\nrepresentation, so any methods taking such a representation as an argument\r\nwill throw an <code>IllegalArgumentException</code> when called on one\r\nof these instances.  The normalized component values of instances\r\nof this class have a range which depends on the transfer\r\ntype as follows: for float samples, the full range of the float data\r\ntype; for double samples, the full range of the float data type\r\n(resulting from casting double to float); for short samples,\r\nfrom approximately -maxVal to +maxVal, where maxVal is the per\r\ncomponent maximum value for the <code>ColorSpace</code>\r\n(-32767 maps to -maxVal, 0 maps to 0.0, and 32767 maps\r\nto +maxVal).  A subclass may override the scaling for short sample\r\nvalues to normalized component values by overriding the\r\n<code>getNormalizedComponents(Object, float[], int)</code> method.\r\nFor float and double samples, the normalized component values are\r\ntaken to be equal to the corresponding sample values, and subclasses\r\nshould not attempt to add any non-identity scaling for these transfer\r\ntypes.\r\n<p>\r\nInstances of <code>ComponentColorModel</code> created with transfer types\r\n<CODE>DataBuffer.TYPE_SHORT</CODE>, <CODE>DataBuffer.TYPE_FLOAT</CODE>, and\r\n<CODE>DataBuffer.TYPE_DOUBLE</CODE>\r\nuse all the bits of all sample values.  Thus all color/alpha components\r\nhave 16 bits when using <CODE>DataBuffer.TYPE_SHORT</CODE>, 32 bits when\r\nusing <CODE>DataBuffer.TYPE_FLOAT</CODE>, and 64 bits when using\r\n<CODE>DataBuffer.TYPE_DOUBLE</CODE>.  When the\r\n<code>ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)</code>\r\nform of constructor is used with one of these transfer types, the\r\nbits array argument is ignored.\r\n<p>\r\nIt is possible to have color/alpha sample values\r\nwhich cannot be reasonably interpreted as component values for rendering.\r\nThis can happen when <code>ComponentColorModel</code> is subclassed to\r\noverride the mapping of unsigned sample values to normalized color\r\ncomponent values or when signed sample values outside a certain range\r\nare used.  (As an example, specifying an alpha component as a signed\r\nshort value outside the range 0 to 32767, normalized range 0.0 to 1.0, can\r\nlead to unexpected results.) It is the\r\nresponsibility of applications to appropriately scale pixel data before\r\nrendering such that color components fall within the normalized range\r\nof the <code>ColorSpace</code> (obtained using the <code>getMinValue</code>\r\nand <code>getMaxValue</code> methods of the <code>ColorSpace</code> class)\r\nand the alpha component is between 0.0 and 1.0.  If color or alpha\r\ncomponent values fall outside these ranges, rendering results are\r\nindeterminate.\r\n<p>\r\nMethods that use a single int pixel representation throw\r\nan <CODE>IllegalArgumentException</CODE>, unless the number of components\r\nfor the <CODE>ComponentColorModel</CODE> is one and the component\r\nvalue is unsigned -- in other words,  a single color component using\r\na transfer type of <CODE>DataBuffer.TYPE_BYTE</CODE>,\r\n<CODE>DataBuffer.TYPE_USHORT</CODE>, or <CODE>DataBuffer.TYPE_INT</CODE>\r\nand no alpha.\r\n<p>\r\nA <CODE>ComponentColorModel</CODE> can be used in conjunction with a\r\n<CODE>ComponentSampleModel</CODE>, a <CODE>BandedSampleModel</CODE>,\r\nor a <CODE>PixelInterleavedSampleModel</CODE> to construct a\r\n<CODE>BufferedImage</CODE>.","inherit":["java.awt.image.ColorModel"],"name":"java.awt.image.ComponentColorModel","type":false},{"description":"","inherit":["java.awt.image.SampleModel"],"name":"java.awt.image.ComponentSampleModel","type":false},{"description":"This class implements a convolution from the source\r\nto the destination.\r\nConvolution using a convolution kernel is a spatial operation that\r\ncomputes the output pixel from an input pixel by multiplying the kernel\r\nwith the surround of the input pixel.\r\nThis allows the output pixel to be affected by the immediate neighborhood\r\nin a way that can be mathematically specified with a kernel.\r\n<p>\r\nThis class operates with BufferedImage data in which color components are\r\npremultiplied with the alpha component.  If the Source BufferedImage has\r\nan alpha component, and the color components are not premultiplied with\r\nthe alpha component, then the data are premultiplied before being\r\nconvolved.  If the Destination has color components which are not\r\npremultiplied, then alpha is divided out before storing into the\r\nDestination (if alpha is 0, the color components are set to 0).  If the\r\nDestination has no alpha component, then the resulting alpha is discarded\r\nafter first dividing it out of the color components.\r\n<p>\r\nRasters are treated as having no alpha channel.  If the above treatment\r\nof the alpha channel in BufferedImages is not desired, it may be avoided\r\nby getting the Raster of a source BufferedImage and using the filter method\r\nof this class which works with Rasters.\r\n<p>\r\nIf a RenderingHints object is specified in the constructor, the\r\ncolor rendering hint and the dithering hint may be used when color\r\nconversion is required.\r\n<p>\r\nNote that the Source and the Destination may not be the same object.","inherit":["java.awt.image.BufferedImageOp","java.awt.image.RasterOp"],"name":"java.awt.image.ConvolveOp","type":false},{"description":"An ImageFilter class for cropping images.\r\nThis class extends the basic ImageFilter Class to extract a given\r\nrectangular region of an existing Image and provide a source for a\r\nnew image containing just the extracted region.  It is meant to\r\nbe used in conjunction with a FilteredImageSource object to produce\r\ncropped versions of existing images.","inherit":["java.awt.image.ImageFilter"],"name":"java.awt.image.CropImageFilter","type":false},{"description":"This class exists to wrap one or more data arrays.  Each data array in\r\nthe DataBuffer is referred to as a bank.  Accessor methods for getting\r\nand setting elements of the DataBuffer's banks exist with and without\r\na bank specifier.  The methods without a bank specifier use the default 0th\r\nbank.  The DataBuffer can optionally take an offset per bank, so that\r\ndata in an existing array can be used even if the interesting data\r\ndoesn't start at array location zero.  Getting or setting the 0th\r\nelement of a bank, uses the (0+offset)th element of the array.  The\r\nsize field specifies how much of the data array is available for\r\nuse.  Size + offset for a given bank should never be greater\r\nthan the length of the associated data array.  The data type of\r\na data buffer indicates the type of the data array(s) and may also\r\nindicate additional semantics, e.g. storing unsigned 8-bit data\r\nin elements of a byte array.  The data type may be TYPE_UNDEFINED\r\nor one of the types defined below.  Other types may be added in\r\nthe future.  Generally, an object of class DataBuffer will be cast down\r\nto one of its data type specific subclasses to access data type specific\r\nmethods for improved performance.  Currently, the Java 2D(tm) API\r\nimage classes use TYPE_BYTE, TYPE_USHORT, TYPE_INT, TYPE_SHORT,\r\nTYPE_FLOAT, and TYPE_DOUBLE DataBuffers to store image data.","inherit":[],"name":"java.awt.image.DataBuffer","type":false},{"description":"This class extends <CODE>DataBuffer</CODE> and stores data internally as bytes.\r\nValues stored in the byte array(s) of this <CODE>DataBuffer</CODE> are treated as\r\nunsigned values.\r\n<p>\r\n<a name=\"optimizations\">\r\nNote that some implementations may function more efficiently\r\nif they can maintain control over how the data for an image is\r\nstored.\r\nFor example, optimizations such as caching an image in video\r\nmemory require that the implementation track all modifications\r\nto that data.\r\nOther implementations may operate better if they can store the\r\ndata in locations other than a Java array.\r\nTo maintain optimum compatibility with various optimizations\r\nit is best to avoid constructors and methods which expose the\r\nunderlying storage as a Java array, as noted below in the\r\ndocumentation for those methods.\r\n</a>","inherit":["java.awt.image.DataBuffer"],"name":"java.awt.image.DataBufferByte","type":false},{"description":"","inherit":["java.awt.image.DataBuffer"],"name":"java.awt.image.DataBufferDouble","type":false},{"description":"","inherit":["java.awt.image.DataBuffer"],"name":"java.awt.image.DataBufferFloat","type":false},{"description":"This class extends <CODE>DataBuffer</CODE> and stores data internally\r\nas integers.\r\n<p>\r\n<a name=\"optimizations\">\r\nNote that some implementations may function more efficiently\r\nif they can maintain control over how the data for an image is\r\nstored.\r\nFor example, optimizations such as caching an image in video\r\nmemory require that the implementation track all modifications\r\nto that data.\r\nOther implementations may operate better if they can store the\r\ndata in locations other than a Java array.\r\nTo maintain optimum compatibility with various optimizations\r\nit is best to avoid constructors and methods which expose the\r\nunderlying storage as a Java array as noted below in the\r\ndocumentation for those methods.\r\n</a>","inherit":["java.awt.image.DataBuffer"],"name":"java.awt.image.DataBufferInt","type":false},{"description":"This class extends <CODE>DataBuffer</CODE> and stores data internally as shorts.\r\n<p>\r\n<a name=\"optimizations\">\r\nNote that some implementations may function more efficiently\r\nif they can maintain control over how the data for an image is\r\nstored.\r\nFor example, optimizations such as caching an image in video\r\nmemory require that the implementation track all modifications\r\nto that data.\r\nOther implementations may operate better if they can store the\r\ndata in locations other than a Java array.\r\nTo maintain optimum compatibility with various optimizations\r\nit is best to avoid constructors and methods which expose the\r\nunderlying storage as a Java array as noted below in the\r\ndocumentation for those methods.\r\n</a>","inherit":["java.awt.image.DataBuffer"],"name":"java.awt.image.DataBufferShort","type":false},{"description":"This class extends <CODE>DataBuffer</CODE> and stores data internally as\r\nshorts.  Values stored in the short array(s) of this <CODE>DataBuffer</CODE>\r\nare treated as unsigned values.\r\n<p>\r\n<a name=\"optimizations\">\r\nNote that some implementations may function more efficiently\r\nif they can maintain control over how the data for an image is\r\nstored.\r\nFor example, optimizations such as caching an image in video\r\nmemory require that the implementation track all modifications\r\nto that data.\r\nOther implementations may operate better if they can store the\r\ndata in locations other than a Java array.\r\nTo maintain optimum compatibility with various optimizations\r\nit is best to avoid constructors and methods which expose the\r\nunderlying storage as a Java array as noted below in the\r\ndocumentation for those methods.\r\n</a>","inherit":["java.awt.image.DataBuffer"],"name":"java.awt.image.DataBufferUShort","type":false},{"description":"The <code>DirectColorModel</code> class is a <code>ColorModel</code>\r\nclass that works with pixel values that represent RGB\r\ncolor and alpha information as separate samples and that pack all\r\nsamples for a single pixel into a single int, short, or byte quantity.\r\nThis class can be used only with ColorSpaces of type ColorSpace.TYPE_RGB.\r\nIn addition, for each component of the ColorSpace, the minimum\r\nnormalized component value obtained via the <code>getMinValue()</code>\r\nmethod of ColorSpace must be 0.0, and the maximum value obtained via\r\nthe <code>getMaxValue()</code> method must be 1.0 (these min/max\r\nvalues are typical for RGB spaces).\r\nThere must be three color samples in the pixel values and there can\r\nbe a single alpha sample.  For those methods that use a primitive array\r\npixel representation of type <code>transferType</code>, the array\r\nlength is always one.  The transfer\r\ntypes supported are DataBuffer.TYPE_BYTE,\r\nDataBuffer.TYPE_USHORT, and DataBuffer.TYPE_INT.\r\nColor and alpha samples are stored in the single\r\nelement of the array in bits indicated by bit masks.  Each bit mask\r\nmust be contiguous and masks must not overlap.  The same masks apply to\r\nthe single int pixel representation used by other methods.  The\r\ncorrespondence of masks and color/alpha samples is as follows:\r\n<ul>\r\n<li> Masks are identified by indices running from 0 through 2\r\nif no alpha is present, or 3 if an alpha is present.\r\n<li> The first three indices refer to color samples;\r\nindex 0 corresponds to red, index 1 to green, and index 2 to blue.\r\n<li> Index 3 corresponds to the alpha sample, if present.\r\n</ul>\r\n<p>\r\nThe translation from pixel values to color/alpha components for\r\ndisplay or processing purposes is a one-to-one correspondence of\r\nsamples to components.  A <code>DirectColorModel</code> is\r\ntypically used with image data which uses masks to define packed\r\nsamples.  For example, a <code>DirectColorModel</code> can be used in\r\nconjunction with a <code>SinglePixelPackedSampleModel</code> to\r\nconstruct a {@link BufferedImage}.  Normally the masks used by the\r\n{@link SampleModel} and the <code>ColorModel</code> would be the\r\nsame.  However, if they are different, the color interpretation\r\nof pixel data will be done according to the masks of the\r\n<code>ColorModel</code>.\r\n<p>\r\nA single int pixel representation is valid for all objects of this\r\nclass, since it is always possible to represent pixel values used with\r\nthis class in a single int.  Therefore, methods which use this\r\nrepresentation will not throw an <code>IllegalArgumentException</code>\r\ndue to an invalid pixel value.\r\n<p>\r\nThis color model is similar to an X11 TrueColor visual.\r\nThe default RGB ColorModel specified by the\r\n{@link ColorModel#getRGBdefault() getRGBdefault} method is a\r\n<code>DirectColorModel</code> with the following parameters:\r\n<pre>\r\nNumber of bits:        32\r\nRed mask:              0x00ff0000\r\nGreen mask:            0x0000ff00\r\nBlue mask:             0x000000ff\r\nAlpha mask:            0xff000000\r\nColor space:           sRGB\r\nisAlphaPremultiplied:  False\r\nTransparency:          Transparency.TRANSLUCENT\r\ntransferType:          DataBuffer.TYPE_INT\r\n</pre>\r\n<p>\r\nMany of the methods in this class are final. This is because the\r\nunderlying native graphics code makes assumptions about the layout\r\nand operation of this class and those assumptions are reflected in\r\nthe implementations of the methods here that are marked final.  You\r\ncan subclass this class for other reasons, but you cannot override\r\nor modify the behavior of those methods.","inherit":["java.awt.image.PackedColorModel"],"name":"java.awt.image.DirectColorModel","type":false},{"description":"This class is an implementation of the ImageProducer interface which\r\ntakes an existing image and a filter object and uses them to produce\r\nimage data for a new filtered version of the original image.\r\nHere is an example which filters an image by swapping the red and\r\nblue compents:\r\n<pre>\r\n\r\n     Image src = getImage(\"doc:///demo/images/duke/T1.gif\");\r\n     ImageFilter colorfilter = new RedBlueSwapFilter();\r\n     Image img = createImage(new FilteredImageSource(src.getSource(),\r\n                                                     colorfilter));\r\n\r\n</pre>","inherit":["java.awt.image.ImageProducer"],"name":"java.awt.image.FilteredImageSource","type":false},{"description":"The interface for objects expressing interest in image data through\r\nthe ImageProducer interfaces.  When a consumer is added to an image\r\nproducer, the producer delivers all of the data about the image\r\nusing the method calls defined in this interface.","inherit":[],"name":"java.awt.image.ImageConsumer","type":true},{"description":"This class implements a filter for the set of interface methods that\r\nare used to deliver data from an ImageProducer to an ImageConsumer.\r\nIt is meant to be used in conjunction with a FilteredImageSource\r\nobject to produce filtered versions of existing images.  It is a\r\nbase class that provides the calls needed to implement a \"Null filter\"\r\nwhich has no effect on the data being passed through.  Filters should\r\nsubclass this class and override the methods which deal with the\r\ndata that needs to be filtered and modify it as necessary.","inherit":["java.awt.image.ImageConsumer","java.lang.Cloneable"],"name":"java.awt.image.ImageFilter","type":false},{"description":"An asynchronous update interface for receiving notifications about\r\nImage information as the Image is constructed.","inherit":[],"name":"java.awt.image.ImageObserver","type":true},{"description":"The interface for objects which can produce the image data for Images.\r\nEach image contains an ImageProducer which is used to reconstruct\r\nthe image whenever it is needed, for example, when a new size of the\r\nImage is scaled, or when the width or height of the Image is being\r\nrequested.","inherit":[],"name":"java.awt.image.ImageProducer","type":true},{"description":"The <code>ImagingOpException</code> is thrown if one of the\r\n{@link BufferedImageOp} or {@link RasterOp} filter methods cannot\r\nprocess the image.","inherit":["java.lang.RuntimeException"],"name":"java.awt.image.ImagingOpException","type":false},{"description":"The <code>IndexColorModel</code> class is a <code>ColorModel</code>\r\nclass that works with pixel values consisting of a\r\nsingle sample that is an index into a fixed colormap in the default\r\nsRGB color space.  The colormap specifies red, green, blue, and\r\noptional alpha components corresponding to each index.  All components\r\nare represented in the colormap as 8-bit unsigned integral values.\r\nSome constructors allow the caller to specify \"holes\" in the colormap\r\nby indicating which colormap entries are valid and which represent\r\nunusable colors via the bits set in a <code>BigInteger</code> object.\r\nThis color model is similar to an X11 PseudoColor visual.\r\n<p>\r\nSome constructors provide a means to specify an alpha component\r\nfor each pixel in the colormap, while others either provide no\r\nsuch means or, in some cases, a flag to indicate whether the\r\ncolormap data contains alpha values.  If no alpha is supplied to\r\nthe constructor, an opaque alpha component (alpha = 1.0) is\r\nassumed for each entry.\r\nAn optional transparent pixel value can be supplied that indicates a\r\npixel to be made completely transparent, regardless of any alpha\r\ncomponent supplied or assumed for that pixel value.\r\nNote that the color components in the colormap of an\r\n<code>IndexColorModel</code> objects are never pre-multiplied with\r\nthe alpha components.\r\n<p>\r\n<a name=\"transparency\">\r\nThe transparency of an <code>IndexColorModel</code> object is\r\ndetermined by examining the alpha components of the colors in the\r\ncolormap and choosing the most specific value after considering\r\nthe optional alpha values and any transparent index specified.\r\nThe transparency value is <code>Transparency.OPAQUE</code>\r\nonly if all valid colors in\r\nthe colormap are opaque and there is no valid transparent pixel.\r\nIf all valid colors\r\nin the colormap are either completely opaque (alpha = 1.0) or\r\ncompletely transparent (alpha = 0.0), which typically occurs when\r\na valid transparent pixel is specified,\r\nthe value is <code>Transparency.BITMASK</code>.\r\nOtherwise, the value is <code>Transparency.TRANSLUCENT</code>, indicating\r\nthat some valid color has an alpha component that is\r\nneither completely transparent nor completely opaque\r\n(0.0 &lt; alpha &lt; 1.0).\r\n</a>\r\n\r\n<p>\r\nIf an <code>IndexColorModel</code> object has\r\na transparency value of <code>Transparency.OPAQUE</code>,\r\nthen the <code>hasAlpha</code>\r\nand <code>getNumComponents</code> methods\r\n(both inherited from <code>ColorModel</code>)\r\nreturn false and 3, respectively.\r\nFor any other transparency value,\r\n<code>hasAlpha</code> returns true\r\nand <code>getNumComponents</code> returns 4.\r\n\r\n<p>\r\n<a name=\"index_values\">\r\nThe values used to index into the colormap are taken from the least\r\nsignificant <em>n</em> bits of pixel representations where\r\n<em>n</em> is based on the pixel size specified in the constructor.\r\nFor pixel sizes smaller than 8 bits, <em>n</em> is rounded up to a\r\npower of two (3 becomes 4 and 5,6,7 become 8).\r\nFor pixel sizes between 8 and 16 bits, <em>n</em> is equal to the\r\npixel size.\r\nPixel sizes larger than 16 bits are not supported by this class.\r\nHigher order bits beyond <em>n</em> are ignored in pixel representations.\r\nIndex values greater than or equal to the map size, but less than\r\n2<sup><em>n</em></sup>, are undefined and return 0 for all color and\r\nalpha components.\r\n</a>\r\n<p>\r\nFor those methods that use a primitive array pixel representation of\r\ntype <code>transferType</code>, the array length is always one.\r\nThe transfer types supported are <code>DataBuffer.TYPE_BYTE</code> and\r\n<code>DataBuffer.TYPE_USHORT</code>.  A single int pixel\r\nrepresentation is valid for all objects of this class, since it is\r\nalways possible to represent pixel values used with this class in a\r\nsingle int.  Therefore, methods that use this representation do\r\nnot throw an <code>IllegalArgumentException</code> due to an invalid\r\npixel value.\r\n<p>\r\nMany of the methods in this class are final.  The reason for\r\nthis is that the underlying native graphics code makes assumptions\r\nabout the layout and operation of this class and those assumptions\r\nare reflected in the implementations of the methods here that are\r\nmarked final.  You can subclass this class for other reasons, but\r\nyou cannot override or modify the behaviour of those methods.","inherit":["java.awt.image.ColorModel"],"name":"java.awt.image.IndexColorModel","type":false},{"description":"The <code>Kernel</code> class defines a matrix that describes how a\r\nspecified pixel and its surrounding pixels affect the value\r\ncomputed for the pixel's position in the output image of a filtering\r\noperation.  The X origin and Y origin indicate the kernel matrix element\r\nthat corresponds to the pixel position for which an output value is\r\nbeing computed.","inherit":["java.lang.Cloneable"],"name":"java.awt.image.Kernel","type":false},{"description":"","inherit":["java.awt.image.BufferedImageOp","java.awt.image.RasterOp"],"name":"java.awt.image.LookupOp","type":false},{"description":"This abstract class defines a lookup table object.  ByteLookupTable\r\nand ShortLookupTable are subclasses, which\r\ncontain byte and short data, respectively.  A lookup table\r\ncontains data arrays for one or more bands (or components) of an image\r\n(for example, separate arrays for R, G, and B),\r\nand it contains an offset which will be subtracted from the\r\ninput values before indexing into the arrays.  This allows an array\r\nsmaller than the native data size to be provided for a\r\nconstrained input.  If there is only one array in the lookup\r\ntable, it will be applied to all bands.  All arrays must be the\r\nsame size.","inherit":["java.lang.Object"],"name":"java.awt.image.LookupTable","type":false},{"description":"This class is an implementation of the ImageProducer interface which\r\nuses an array to produce pixel values for an Image.  Here is an example\r\nwhich calculates a 100x100 image representing a fade from black to blue\r\nalong the X axis and a fade from black to red along the Y axis:\r\n<pre>{@code\r\n\r\n     int w = 100;\r\n     int h = 100;\r\n     int pix[] = new int[w * h];\r\n     int index = 0;\r\n     for (int y = 0; y < h; y++) {\r\n         int red = (y * 255) / (h - 1);\r\n         for (int x = 0; x < w; x++) {\r\n             int blue = (x * 255) / (w - 1);\r\n             pix[index++] = (255 << 24) | (red << 16) | blue;\r\n         }\r\n     }\r\n     Image img = createImage(new MemoryImageSource(w, h, pix, 0, w));\r\n\r\n}</pre>\r\nThe MemoryImageSource is also capable of managing a memory image which\r\nvaries over time to allow animation or custom rendering.  Here is an\r\nexample showing how to set up the animation source and signal changes\r\nin the data (adapted from the MemoryAnimationSourceDemo by Garth Dickie):\r\n<pre>{@code\r\n\r\n     int pixels[];\r\n     MemoryImageSource source;\r\n\r\n     public void init() {\r\n         int width = 50;\r\n         int height = 50;\r\n         int size = width * height;\r\n         pixels = new int[size];\r\n\r\n         int value = getBackground().getRGB();\r\n         for (int i = 0; i < size; i++) {\r\n             pixels[i] = value;\r\n         }\r\n\r\n         source = new MemoryImageSource(width, height, pixels, 0, width);\r\n         source.setAnimated(true);\r\n         image = createImage(source);\r\n     }\r\n\r\n     public void run() {\r\n         Thread me = Thread.currentThread( );\r\n         me.setPriority(Thread.MIN_PRIORITY);\r\n\r\n         while (true) {\r\n             try {\r\n                 Thread.sleep(10);\r\n             } catch( InterruptedException e ) {\r\n                 return;\r\n             }\r\n\r\n             // Modify the values in the pixels array at (x, y, w, h)\r\n\r\n             // Send the new data to the interested ImageConsumers\r\n             source.newPixels(x, y, w, h);\r\n         }\r\n     }\r\n\r\n}</pre>","inherit":["java.awt.image.ImageProducer"],"name":"java.awt.image.MemoryImageSource","type":false},{"description":"","inherit":["java.awt.image.SampleModel"],"name":"java.awt.image.MultiPixelPackedSampleModel","type":false},{"description":"","inherit":["java.awt.image.ColorModel"],"name":"java.awt.image.PackedColorModel","type":false},{"description":"The PixelGrabber class implements an ImageConsumer which can be attached\r\nto an Image or ImageProducer object to retrieve a subset of the pixels\r\nin that image.  Here is an example:\r\n<pre>{@code\r\n\r\npublic void handlesinglepixel(int x, int y, int pixel) {\r\n     int alpha = (pixel >> 24) & 0xff;\r\n     int red   = (pixel >> 16) & 0xff;\r\n     int green = (pixel >>  8) & 0xff;\r\n     int blue  = (pixel      ) & 0xff;\r\n     // Deal with the pixel as necessary...\r\n}\r\n\r\npublic void handlepixels(Image img, int x, int y, int w, int h) {\r\n     int[] pixels = new int[w * h];\r\n     PixelGrabber pg = new PixelGrabber(img, x, y, w, h, pixels, 0, w);\r\n     try {\r\n         pg.grabPixels();\r\n     } catch (InterruptedException e) {\r\n         System.err.println(\"interrupted waiting for pixels!\");\r\n         return;\r\n     }\r\n     if ((pg.getStatus() & ImageObserver.ABORT) != 0) {\r\n         System.err.println(\"image fetch aborted or errored\");\r\n         return;\r\n     }\r\n     for (int j = 0; j < h; j++) {\r\n         for (int i = 0; i < w; i++) {\r\n             handlesinglepixel(x+i, y+j, pixels[j * w + i]);\r\n         }\r\n     }\r\n}\r\n\r\n}</pre>","inherit":["java.awt.image.ImageConsumer"],"name":"java.awt.image.PixelGrabber","type":false},{"description":"","inherit":["java.awt.image.ComponentSampleModel"],"name":"java.awt.image.PixelInterleavedSampleModel","type":false},{"description":"A class representing a rectangular array of pixels.  A Raster\r\nencapsulates a DataBuffer that stores the sample values and a\r\nSampleModel that describes how to locate a given sample value in a\r\nDataBuffer.\r\n<p>\r\nA Raster defines values for pixels occupying a particular\r\nrectangular area of the plane, not necessarily including (0, 0).\r\nThe rectangle, known as the Raster's bounding rectangle and\r\navailable by means of the getBounds method, is defined by minX,\r\nminY, width, and height values.  The minX and minY values define\r\nthe coordinate of the upper left corner of the Raster.  References\r\nto pixels outside of the bounding rectangle may result in an\r\nexception being thrown, or may result in references to unintended\r\nelements of the Raster's associated DataBuffer.  It is the user's\r\nresponsibility to avoid accessing such pixels.\r\n<p>\r\nA SampleModel describes how samples of a Raster\r\nare stored in the primitive array elements of a DataBuffer.\r\nSamples may be stored one per data element, as in a\r\nPixelInterleavedSampleModel or BandedSampleModel, or packed several to\r\nan element, as in a SinglePixelPackedSampleModel or\r\nMultiPixelPackedSampleModel.  The SampleModel is also\r\ncontrols whether samples are sign extended, allowing unsigned\r\ndata to be stored in signed Java data types such as byte, short, and\r\nint.\r\n<p>\r\nAlthough a Raster may live anywhere in the plane, a SampleModel\r\nmakes use of a simple coordinate system that starts at (0, 0).  A\r\nRaster therefore contains a translation factor that allows pixel\r\nlocations to be mapped between the Raster's coordinate system and\r\nthat of the SampleModel.  The translation from the SampleModel\r\ncoordinate system to that of the Raster may be obtained by the\r\ngetSampleModelTranslateX and getSampleModelTranslateY methods.\r\n<p>\r\nA Raster may share a DataBuffer with another Raster either by\r\nexplicit construction or by the use of the createChild and\r\ncreateTranslatedChild methods.  Rasters created by these methods\r\ncan return a reference to the Raster they were created from by\r\nmeans of the getParent method.  For a Raster that was not\r\nconstructed by means of a call to createTranslatedChild or\r\ncreateChild, getParent will return null.\r\n<p>\r\nThe createTranslatedChild method returns a new Raster that\r\nshares all of the data of the current Raster, but occupies a\r\nbounding rectangle of the same width and height but with a\r\ndifferent starting point.  For example, if the parent Raster\r\noccupied the region (10, 10) to (100, 100), and the translated\r\nRaster was defined to start at (50, 50), then pixel (20, 20) of the\r\nparent and pixel (60, 60) of the child occupy the same location in\r\nthe DataBuffer shared by the two Rasters.  In the first case, (-10,\r\n-10) should be added to a pixel coordinate to obtain the\r\ncorresponding SampleModel coordinate, and in the second case (-50,\r\n-50) should be added.\r\n<p>\r\nThe translation between a parent and child Raster may be\r\ndetermined by subtracting the child's sampleModelTranslateX and\r\nsampleModelTranslateY values from those of the parent.\r\n<p>\r\nThe createChild method may be used to create a new Raster\r\noccupying only a subset of its parent's bounding rectangle\r\n(with the same or a translated coordinate system) or\r\nwith a subset of the bands of its parent.\r\n<p>\r\nAll constructors are protected.  The correct way to create a\r\nRaster is to use one of the static create methods defined in this\r\nclass.  These methods create instances of Raster that use the\r\nstandard Interleaved, Banded, and Packed SampleModels and that may\r\nbe processed more efficiently than a Raster created by combining\r\nan externally generated SampleModel and DataBuffer.","inherit":[],"name":"java.awt.image.Raster","type":false},{"description":"The <code>RasterFormatException</code> is thrown if there is\r\ninvalid layout information in the {@link Raster}.","inherit":["java.lang.RuntimeException"],"name":"java.awt.image.RasterFormatException","type":false},{"description":"This interface describes single-input/single-output\r\noperations performed on Raster objects.  It is implemented by such\r\nclasses as AffineTransformOp, ConvolveOp, and LookupOp.  The Source\r\nand Destination objects must contain the appropriate number\r\nof bands for the particular classes implementing this interface.\r\nOtherwise, an exception is thrown.  This interface cannot be used to\r\ndescribe more sophisticated Ops such as ones that take multiple sources.\r\nEach class implementing this interface will specify whether or not it\r\nwill allow an in-place filtering operation (i.e. source object equal\r\nto the destination object).  Note that the restriction to single-input\r\noperations means that the values of destination pixels prior to the\r\noperation are not used as input to the filter operation.","inherit":[],"name":"java.awt.image.RasterOp","type":true},{"description":"ContextualRenderedImageFactory provides an interface for the\r\nfunctionality that may differ between instances of\r\nRenderableImageOp.  Thus different operations on RenderableImages\r\nmay be performed by a single class such as RenderedImageOp through\r\nthe use of multiple instances of ContextualRenderedImageFactory.\r\nThe name ContextualRenderedImageFactory is commonly shortened to\r\n\"CRIF.\"\r\n\r\n<p> All operations that are to be used in a rendering-independent\r\nchain must implement ContextualRenderedImageFactory.\r\n\r\n<p> Classes that implement this interface must provide a\r\nconstructor with no arguments.","inherit":["java.awt.image.renderable.RenderedImageFactory"],"name":"java.awt.image.renderable.ContextualRenderedImageFactory","type":true},{"description":"A <code>ParameterBlock</code> encapsulates all the information about sources and\r\nparameters (Objects) required by a RenderableImageOp, or other\r\nclasses that process images.\r\n\r\n<p> Although it is possible to place arbitrary objects in the\r\nsource Vector, users of this class may impose semantic constraints\r\nsuch as requiring all sources to be RenderedImages or\r\nRenderableImage.  <code>ParameterBlock</code> itself is merely a container and\r\nperforms no checking on source or parameter types.\r\n\r\n<p> All parameters in a <code>ParameterBlock</code> are objects; convenience\r\nadd and set methods are available that take arguments of base type and\r\nconstruct the appropriate subclass of Number (such as\r\nInteger or Float).  Corresponding get methods perform a\r\ndownward cast and have return values of base type; an exception\r\nwill be thrown if the stored values do not have the correct type.\r\nThere is no way to distinguish between the results of\r\n\"short s; add(s)\" and \"add(new Short(s))\".\r\n\r\n<p> Note that the get and set methods operate on references.\r\nTherefore, one must be careful not to share references between\r\n<code>ParameterBlock</code>s when this is inappropriate.  For example, to create\r\na new <code>ParameterBlock</code> that is equal to an old one except for an\r\nadded source, one might be tempted to write:\r\n\r\n<pre>\r\nParameterBlock addSource(ParameterBlock pb, RenderableImage im) {\r\n    ParameterBlock pb1 = new ParameterBlock(pb.getSources());\r\n    pb1.addSource(im);\r\n    return pb1;\r\n}\r\n</pre>\r\n\r\n<p> This code will have the side effect of altering the original\r\n<code>ParameterBlock</code>, since the getSources operation returned a reference\r\nto its source Vector.  Both pb and pb1 share their source Vector,\r\nand a change in either is visible to both.\r\n\r\n<p> A correct way to write the addSource function is to clone\r\nthe source Vector:\r\n\r\n<pre>\r\nParameterBlock addSource (ParameterBlock pb, RenderableImage im) {\r\n    ParameterBlock pb1 = new ParameterBlock(pb.getSources().clone());\r\n    pb1.addSource(im);\r\n    return pb1;\r\n}\r\n</pre>\r\n\r\n<p> The clone method of <code>ParameterBlock</code> has been defined to\r\nperform a clone of both the source and parameter Vectors for\r\nthis reason.  A standard, shallow clone is available as\r\nshallowClone.\r\n\r\n<p> The addSource, setSource, add, and set methods are\r\ndefined to return 'this' after adding their argument.  This allows\r\nuse of syntax like:\r\n\r\n<pre>\r\nParameterBlock pb = new ParameterBlock();\r\nop = new RenderableImageOp(\"operation\", pb.add(arg1).add(arg2));\r\n</pre>","inherit":["java.lang.Cloneable","java.io.Serializable"],"name":"java.awt.image.renderable.ParameterBlock","type":false},{"description":"A RenderableImage is a common interface for rendering-independent\r\nimages (a notion which subsumes resolution independence).  That is,\r\nimages which are described and have operations applied to them\r\nindependent of any specific rendering of the image.  For example, a\r\nRenderableImage can be rotated and cropped in\r\nresolution-independent terms.  Then, it can be rendered for various\r\nspecific contexts, such as a draft preview, a high-quality screen\r\ndisplay, or a printer, each in an optimal fashion.\r\n\r\n<p> A RenderedImage is returned from a RenderableImage via the\r\ncreateRendering() method, which takes a RenderContext.  The\r\nRenderContext specifies how the RenderedImage should be\r\nconstructed.  Note that it is not possible to extract pixels\r\ndirectly from a RenderableImage.\r\n\r\n<p> The createDefaultRendering() and createScaledRendering() methods are\r\nconvenience methods that construct an appropriate RenderContext\r\ninternally.  All of the rendering methods may return a reference to a\r\npreviously produced rendering.","inherit":[],"name":"java.awt.image.renderable.RenderableImage","type":true},{"description":"This class handles the renderable aspects of an operation with help\r\nfrom its associated instance of a ContextualRenderedImageFactory.","inherit":["java.awt.image.renderable.RenderableImage"],"name":"java.awt.image.renderable.RenderableImageOp","type":false},{"description":"An adapter class that implements ImageProducer to allow the\r\nasynchronous production of a RenderableImage.  The size of the\r\nImageConsumer is determined by the scale factor of the usr2dev\r\ntransform in the RenderContext.  If the RenderContext is null, the\r\ndefault rendering of the RenderableImage is used.  This class\r\nimplements an asynchronous production that produces the image in\r\none thread at one resolution.  This class may be subclassed to\r\nimplement versions that will render the image using several\r\nthreads.  These threads could render either the same image at\r\nprogressively better quality, or different sections of the image at\r\na single resolution.","inherit":["java.awt.image.ImageProducer","java.lang.Runnable"],"name":"java.awt.image.renderable.RenderableImageProducer","type":false},{"description":"A RenderContext encapsulates the information needed to produce a\r\nspecific rendering from a RenderableImage.  It contains the area to\r\nbe rendered specified in rendering-independent terms, the\r\nresolution at which the rendering is to be performed, and hints\r\nused to control the rendering process.\r\n\r\n<p> Users create RenderContexts and pass them to the\r\nRenderableImage via the createRendering method.  Most of the methods of\r\nRenderContexts are not meant to be used directly by applications,\r\nbut by the RenderableImage and operator classes to which it is\r\npassed.\r\n\r\n<p> The AffineTransform parameter passed into and out of this class\r\nare cloned.  The RenderingHints and Shape parameters are not\r\nnecessarily cloneable and are therefore only reference copied.\r\nAltering RenderingHints or Shape instances that are in use by\r\ninstances of RenderContext may have undesired side effects.","inherit":["java.lang.Cloneable"],"name":"java.awt.image.renderable.RenderContext","type":false},{"description":"The RenderedImageFactory interface (often abbreviated RIF) is\r\nintended to be implemented by classes that wish to act as factories\r\nto produce different renderings, for example by executing a series\r\nof BufferedImageOps on a set of sources, depending on a specific\r\nset of parameters, properties, and rendering hints.","inherit":[],"name":"java.awt.image.renderable.RenderedImageFactory","type":true},{"description":"","inherit":[],"name":"java.awt.image.RenderedImage","type":true},{"description":"An ImageFilter class for scaling images using the simplest algorithm.\r\nThis class extends the basic ImageFilter Class to scale an existing\r\nimage and provide a source for a new image containing the resampled\r\nimage.  The pixels in the source image are sampled to produce pixels\r\nfor an image of the specified size by replicating rows and columns of\r\npixels to scale up or omitting rows and columns of pixels to scale\r\ndown.\r\n<p>It is meant to be used in conjunction with a FilteredImageSource\r\nobject to produce scaled versions of existing images.  Due to\r\nimplementation dependencies, there may be differences in pixel values\r\nof an image filtered on different platforms.","inherit":["java.awt.image.ImageFilter"],"name":"java.awt.image.ReplicateScaleFilter","type":false},{"description":"This class performs a pixel-by-pixel rescaling of the data in the\r\nsource image by multiplying the sample values for each pixel by a scale\r\nfactor and then adding an offset. The scaled sample values are clipped\r\nto the minimum/maximum representable in the destination image.\r\n<p>\r\nThe pseudo code for the rescaling operation is as follows:\r\n<pre>\r\nfor each pixel from Source object {\r\n   for each band/component of the pixel {\r\n       dstElement = (srcElement*scaleFactor) + offset\r\n   }\r\n}\r\n</pre>\r\n<p>\r\nFor Rasters, rescaling operates on bands.  The number of\r\nsets of scaling constants may be one, in which case the same constants\r\nare applied to all bands, or it must equal the number of Source\r\nRaster bands.\r\n<p>\r\nFor BufferedImages, rescaling operates on color and alpha components.\r\nThe number of sets of scaling constants may be one, in which case the\r\nsame constants are applied to all color (but not alpha) components.\r\nOtherwise, the  number of sets of scaling constants may\r\nequal the number of Source color components, in which case no\r\nrescaling of the alpha component (if present) is performed.\r\nIf neither of these cases apply, the number of sets of scaling constants\r\nmust equal the number of Source color components plus alpha components,\r\nin which case all color and alpha components are rescaled.\r\n<p>\r\nBufferedImage sources with premultiplied alpha data are treated in the same\r\nmanner as non-premultiplied images for purposes of rescaling.  That is,\r\nthe rescaling is done per band on the raw data of the BufferedImage source\r\nwithout regard to whether the data is premultiplied.  If a color conversion\r\nis required to the destination ColorModel, the premultiplied state of\r\nboth source and destination will be taken into account for this step.\r\n<p>\r\nImages with an IndexColorModel cannot be rescaled.\r\n<p>\r\nIf a RenderingHints object is specified in the constructor, the\r\ncolor rendering hint and the dithering hint may be used when color\r\nconversion is required.\r\n<p>\r\nNote that in-place operation is allowed (i.e. the source and destination can\r\nbe the same object).","inherit":["java.awt.image.BufferedImageOp","java.awt.image.RasterOp"],"name":"java.awt.image.RescaleOp","type":false},{"description":"This class provides an easy way to create an ImageFilter which modifies\r\nthe pixels of an image in the default RGB ColorModel.  It is meant to\r\nbe used in conjunction with a FilteredImageSource object to produce\r\nfiltered versions of existing images.  It is an abstract class that\r\nprovides the calls needed to channel all of the pixel data through a\r\nsingle method which converts pixels one at a time in the default RGB\r\nColorModel regardless of the ColorModel being used by the ImageProducer.\r\nThe only method which needs to be defined to create a useable image\r\nfilter is the filterRGB method.  Here is an example of a definition\r\nof a filter which swaps the red and blue components of an image:\r\n<pre>{@code\r\n\r\n     class RedBlueSwapFilter extends RGBImageFilter {\r\n         public RedBlueSwapFilter() {\r\n             // The filter's operation does not depend on the\r\n             // pixel's location, so IndexColorModels can be\r\n             // filtered directly.\r\n             canFilterIndexColorModel = true;\r\n         }\r\n\r\n         public int filterRGB(int x, int y, int rgb) {\r\n             return ((rgb & 0xff00ff00)\r\n                     | ((rgb & 0xff0000) >> 16)\r\n                     | ((rgb & 0xff) << 16));\r\n         }\r\n     }\r\n\r\n}</pre>","inherit":["java.awt.image.ImageFilter"],"name":"java.awt.image.RGBImageFilter","type":false},{"description":"","inherit":[],"name":"java.awt.image.SampleModel","type":false},{"description":"This class defines a lookup table object.  The output of a\r\nlookup operation using an object of this class is interpreted\r\nas an unsigned short quantity.  The lookup table contains short\r\ndata arrays for one or more bands (or components) of an image,\r\nand it contains an offset which will be subtracted from the\r\ninput values before indexing the arrays.  This allows an array\r\nsmaller than the native data size to be provided for a\r\nconstrained input.  If there is only one array in the lookup\r\ntable, it will be applied to all bands.","inherit":["java.awt.image.LookupTable"],"name":"java.awt.image.ShortLookupTable","type":false},{"description":"","inherit":["java.awt.image.SampleModel"],"name":"java.awt.image.SinglePixelPackedSampleModel","type":false},{"description":"An interface for objects that wish to be informed when tiles\r\nof a WritableRenderedImage become modifiable by some writer via\r\na call to getWritableTile, and when they become unmodifiable via\r\nthe last call to releaseWritableTile.","inherit":[],"name":"java.awt.image.TileObserver","type":true},{"description":"VolatileImage is an image which can lose its\r\ncontents at any time due to circumstances beyond the control of the\r\napplication (e.g., situations caused by the operating system or by\r\nother applications). Because of the potential for hardware acceleration,\r\na VolatileImage object can have significant performance benefits on\r\nsome platforms.\r\n<p>\r\nThe drawing surface of an image (the memory where the image contents\r\nactually reside) can be lost or invalidated, causing the contents of that\r\nmemory to go away.  The drawing surface thus needs to be restored\r\nor recreated and the contents of that surface need to be\r\nre-rendered.  VolatileImage provides an interface for\r\nallowing the user to detect these problems and fix them\r\nwhen they occur.\r\n<p>\r\nWhen a VolatileImage object is created, limited system resources\r\nsuch as video memory (VRAM) may be allocated in order to support\r\nthe image.\r\nWhen a VolatileImage object is no longer used, it may be\r\ngarbage-collected and those system resources will be returned,\r\nbut this process does not happen at guaranteed times.\r\nApplications that create many VolatileImage objects (for example,\r\na resizing window may force recreation of its back buffer as the\r\nsize changes) may run out of optimal system resources for new\r\nVolatileImage objects simply because the old objects have not\r\nyet been removed from the system.\r\n(New VolatileImage objects may still be created, but they\r\nmay not perform as well as those created in accelerated\r\nmemory).\r\nThe flush method may be called at any time to proactively release\r\nthe resources used by a VolatileImage so that it does not prevent\r\nsubsequent VolatileImage objects from being accelerated.\r\nIn this way, applications can have more control over the state\r\nof the resources taken up by obsolete VolatileImage objects.\r\n<p>\r\nThis image should not be subclassed directly but should be created\r\nby using the {@link java.awt.Component#createVolatileImage(int, int)\r\nComponent.createVolatileImage} or\r\n{@link java.awt.GraphicsConfiguration#createCompatibleVolatileImage(int, int)\r\nGraphicsConfiguration.createCompatibleVolatileImage(int, int)} methods.\r\n<P>\r\nAn example of using a VolatileImage object follows:\r\n<pre>\r\n// image creation\r\nVolatileImage vImg = createVolatileImage(w, h);\r\n\r\n\r\n// rendering to the image\r\nvoid renderOffscreen() {\r\n     do {\r\n         if (vImg.validate(getGraphicsConfiguration()) ==\r\n             VolatileImage.IMAGE_INCOMPATIBLE)\r\n         {\r\n             // old vImg doesn't work with new GraphicsConfig; re-create it\r\n             vImg = createVolatileImage(w, h);\r\n         }\r\n         Graphics2D g = vImg.createGraphics();\r\n         //\r\n         // miscellaneous rendering commands...\r\n         //\r\n         g.dispose();\r\n     } while (vImg.contentsLost());\r\n}\r\n\r\n\r\n// copying from the image (here, gScreen is the Graphics\r\n// object for the onscreen window)\r\ndo {\r\n     int returnCode = vImg.validate(getGraphicsConfiguration());\r\n     if (returnCode == VolatileImage.IMAGE_RESTORED) {\r\n         // Contents need to be restored\r\n         renderOffscreen();      // restore contents\r\n     } else if (returnCode == VolatileImage.IMAGE_INCOMPATIBLE) {\r\n         // old vImg doesn't work with new GraphicsConfig; re-create it\r\n         vImg = createVolatileImage(w, h);\r\n         renderOffscreen();\r\n     }\r\n     gScreen.drawImage(vImg, 0, 0, this);\r\n} while (vImg.contentsLost());\r\n</pre>\r\n<P>\r\nNote that this class subclasses from the {@link Image} class, which\r\nincludes methods that take an {@link ImageObserver} parameter for\r\nasynchronous notifications as information is received from\r\na potential {@link ImageProducer}.  Since this <code>VolatileImage</code>\r\nis not loaded from an asynchronous source, the various methods that take\r\nan <code>ImageObserver</code> parameter will behave as if the data has\r\nalready been obtained from the <code>ImageProducer</code>.\r\nSpecifically, this means that the return values from such methods\r\nwill never indicate that the information is not yet available and\r\nthe <code>ImageObserver</code> used in such methods will never\r\nneed to be recorded for an asynchronous callback notification.","inherit":["java.awt.Image","java.awt.Transparency"],"name":"java.awt.image.VolatileImage","type":false},{"description":"This class extends Raster to provide pixel writing capabilities.\r\nRefer to the class comment for Raster for descriptions of how\r\na Raster stores pixels.\r\n\r\n<p> The constructors of this class are protected.  To instantiate\r\na WritableRaster, use one of the createWritableRaster factory methods\r\nin the Raster class.","inherit":["java.awt.image.Raster"],"name":"java.awt.image.WritableRaster","type":false},{"description":"","inherit":["java.awt.image.RenderedImage"],"name":"java.awt.image.WritableRenderedImage","type":true},{"description":"The abstract class <code>Image</code> is the superclass of all\r\nclasses that represent graphical images. The image must be\r\nobtained in a platform-specific manner.","inherit":[],"name":"java.awt.Image","type":false},{"description":"Capabilities and properties of images.","inherit":["java.lang.Cloneable"],"name":"java.awt.ImageCapabilities","type":false},{"description":"An <code>Insets</code> object is a representation of the borders\r\nof a container. It specifies the space that a container must leave\r\nat each of its edges. The space can be a border, a blank space, or\r\na title.","inherit":["java.lang.Cloneable","java.io.Serializable"],"name":"java.awt.Insets","type":false},{"description":"","inherit":[],"name":"java.awt.ItemSelectable","type":true},{"description":"A set of attributes which control a print job.\r\n<p>\r\nInstances of this class control the number of copies, default selection,\r\ndestination, print dialog, file and printer names, page ranges, multiple\r\ndocument handling (including collation), and multi-page imposition (such\r\nas duplex) of every print job which uses the instance. Attribute names are\r\ncompliant with the Internet Printing Protocol (IPP) 1.1 where possible.\r\nAttribute values are partially compliant where possible.\r\n<p>\r\nTo use a method which takes an inner class type, pass a reference to\r\none of the constant fields of the inner class. Client code cannot create\r\nnew instances of the inner class types because none of those classes\r\nhas a public constructor. For example, to set the print dialog type to\r\nthe cross-platform, pure Java print dialog, use the following code:\r\n<pre>\r\nimport java.awt.JobAttributes;\r\n\r\npublic class PureJavaPrintDialogExample {\r\n    public void setPureJavaPrintDialog(JobAttributes jobAttributes) {\r\n        jobAttributes.setDialog(JobAttributes.DialogType.COMMON);\r\n    }\r\n}\r\n</pre>\r\n<p>\r\nEvery IPP attribute which supports an <i>attributeName</i>-default value\r\nhas a corresponding <code>set<i>attributeName</i>ToDefault</code> method.\r\nDefault value fields are not provided.","inherit":["java.lang.Cloneable"],"name":"java.awt.JobAttributes","type":false},{"description":"A type-safe enumeration of possible default selection states.","inherit":["java.awt.AttributeValue"],"name":"java.awt.JobAttributes.DefaultSelectionType","type":false},{"description":"A type-safe enumeration of possible job destinations.","inherit":["java.awt.AttributeValue"],"name":"java.awt.JobAttributes.DestinationType","type":false},{"description":"A type-safe enumeration of possible dialogs to display to the user.","inherit":["java.awt.AttributeValue"],"name":"java.awt.JobAttributes.DialogType","type":false},{"description":"A type-safe enumeration of possible multiple copy handling states.\r\nIt is used to control how the sheets of multiple copies of a single\r\ndocument are collated.","inherit":["java.awt.AttributeValue"],"name":"java.awt.JobAttributes.MultipleDocumentHandlingType","type":false},{"description":"A type-safe enumeration of possible multi-page impositions. These\r\nimpositions are in compliance with IPP 1.1.","inherit":["java.awt.AttributeValue"],"name":"java.awt.JobAttributes.SidesType","type":false},{"description":"The KeyboardFocusManager is responsible for managing the active and focused\r\nWindows, and the current focus owner. The focus owner is defined as the\r\nComponent in an application that will typically receive all KeyEvents\r\ngenerated by the user. The focused Window is the Window that is, or\r\ncontains, the focus owner. Only a Frame or a Dialog can be the active\r\nWindow. The native windowing system may denote the active Window or its\r\nchildren with special decorations, such as a highlighted title bar. The\r\nactive Window is always either the focused Window, or the first Frame or\r\nDialog that is an owner of the focused Window.\r\n<p>\r\nThe KeyboardFocusManager is both a centralized location for client code to\r\nquery for the focus owner and initiate focus changes, and an event\r\ndispatcher for all FocusEvents, WindowEvents related to focus, and\r\nKeyEvents.\r\n<p>\r\nSome browsers partition applets in different code bases into separate\r\ncontexts, and establish walls between these contexts. In such a scenario,\r\nthere will be one KeyboardFocusManager per context. Other browsers place all\r\napplets into the same context, implying that there will be only a single,\r\nglobal KeyboardFocusManager for all applets. This behavior is\r\nimplementation-dependent. Consult your browser's documentation for more\r\ninformation. No matter how many contexts there may be, however, there can\r\nnever be more than one focus owner, focused Window, or active Window, per\r\nClassLoader.\r\n<p>\r\nPlease see\r\n<a href=\"https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html\">\r\nHow to Use the Focus Subsystem</a>,\r\na section in <em>The Java Tutorial</em>, and the\r\n<a href=\"../../java/awt/doc-files/FocusSpec.html\">Focus Specification</a>\r\nfor more information.","inherit":["java.awt.KeyEventDispatcher","java.awt.KeyEventPostProcessor"],"name":"java.awt.KeyboardFocusManager","type":false},{"description":"","inherit":[],"name":"java.awt.KeyboardFocusManager.LightweightFocusRequest","type":false},{"description":"","inherit":[],"name":"java.awt.KeyboardFocusManager.HeavyweightFocusRequest","type":false},{"description":"A KeyEventDispatcher cooperates with the current KeyboardFocusManager in the\r\ntargeting and dispatching of all KeyEvents. KeyEventDispatchers registered\r\nwith the current KeyboardFocusManager will receive KeyEvents before they are\r\ndispatched to their targets, allowing each KeyEventDispatcher to retarget\r\nthe event, consume it, dispatch the event itself, or make other changes.\r\n<p>\r\nNote that KeyboardFocusManager itself implements KeyEventDispatcher. By\r\ndefault, the current KeyboardFocusManager will be the sink for all KeyEvents\r\nnot dispatched by the registered KeyEventDispatchers. The current\r\nKeyboardFocusManager cannot be completely deregistered as a\r\nKeyEventDispatcher. However, if a KeyEventDispatcher reports that it\r\ndispatched the KeyEvent, regardless of whether it actually did so, the\r\nKeyboardFocusManager will take no further action with regard to the\r\nKeyEvent. (While it is possible for client code to register the current\r\nKeyboardFocusManager as a KeyEventDispatcher one or more times, this is\r\nusually unnecessary and not recommended.)","inherit":[],"name":"java.awt.KeyEventDispatcher","type":true},{"description":"A KeyEventPostProcessor cooperates with the current KeyboardFocusManager\r\nin the final resolution of all unconsumed KeyEvents. KeyEventPostProcessors\r\nregistered with the current KeyboardFocusManager will receive KeyEvents\r\nafter the KeyEvents have been dispatched to and handled by their targets.\r\nKeyEvents that would have been otherwise discarded because no Component in\r\nthe application currently owns the focus will also be forwarded to\r\nregistered KeyEventPostProcessors. This will allow applications to implement\r\nfeatures that require global KeyEvent post-handling, such as menu shortcuts.\r\n<p>\r\nNote that the KeyboardFocusManager itself implements KeyEventPostProcessor.\r\nBy default, the current KeyboardFocusManager will be the final\r\nKeyEventPostProcessor in the chain. The current KeyboardFocusManager cannot\r\nbe completely deregistered as a KeyEventPostProcessor. However, if a\r\nKeyEventPostProcessor reports that no further post-processing of the\r\nKeyEvent should take place, the AWT will consider the event fully handled\r\nand will take no additional action with regard to the event. (While it is\r\npossible for client code to register the current KeyboardFocusManager as\r\na KeyEventPostProcessor one or more times, this is usually unnecessary and\r\nnot recommended.)","inherit":[],"name":"java.awt.KeyEventPostProcessor","type":true},{"description":"A <code>Label</code> object is a component for placing text in a\r\ncontainer. A label displays a single line of read-only text.\r\nThe text can be changed by the application, but a user cannot edit it\r\ndirectly.\r\n<p>\r\nFor example, the code&nbsp;.&nbsp;.&nbsp;.\r\n\r\n<hr><blockquote><pre>\r\nsetLayout(new FlowLayout(FlowLayout.CENTER, 10, 10));\r\nadd(new Label(\"Hi There!\"));\r\nadd(new Label(\"Another Label\"));\r\n</pre></blockquote><hr>\r\n<p>\r\nproduces the following labels:\r\n<p>\r\n<img src=\"doc-files/Label-1.gif\" alt=\"Two labels: 'Hi There!' and 'Another label'\"\r\nstyle=\"float:center; margin: 7px 10px;\">","inherit":["java.awt.Component","javax.accessibility.Accessible"],"name":"java.awt.Label","type":false},{"description":"This class implements accessibility support for the\r\n<code>Label</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to label user-interface elements.","inherit":["java.awt.Component.AccessibleAWTComponent"],"name":"java.awt.Label.AccessibleAWTLabel","type":false},{"description":"Defines the interface for classes that know how to lay out\r\n<code>Container</code>s.\r\n<p>\r\nSwing's painting architecture assumes the children of a\r\n<code>JComponent</code> do not overlap.  If a\r\n<code>JComponent</code>'s <code>LayoutManager</code> allows\r\nchildren to overlap, the <code>JComponent</code> must override\r\n<code>isOptimizedDrawingEnabled</code> to return false.","inherit":[],"name":"java.awt.LayoutManager","type":true},{"description":"Defines an interface for classes that know how to layout Containers\r\nbased on a layout constraints object.\r\n\r\nThis interface extends the LayoutManager interface to deal with layouts\r\nexplicitly in terms of constraint objects that specify how and where\r\ncomponents should be added to the layout.\r\n<p>\r\nThis minimal extension to LayoutManager is intended for tool\r\nproviders who wish to the creation of constraint-based layouts.\r\nIt does not yet provide full, general support for custom\r\nconstraint-based layout managers.","inherit":["java.awt.LayoutManager"],"name":"java.awt.LayoutManager2","type":true},{"description":"The {@code LinearGradientPaint} class provides a way to fill\r\na {@link java.awt.Shape} with a linear color gradient pattern.  The user\r\nmay specify two or more gradient colors, and this paint will provide an\r\ninterpolation between each color.  The user also specifies start and end\r\npoints which define where in user space the color gradient should begin\r\nand end.\r\n<p>\r\nThe user must provide an array of floats specifying how to distribute the\r\ncolors along the gradient.  These values should range from 0.0 to 1.0 and\r\nact like keyframes along the gradient (they mark where the gradient should\r\nbe exactly a particular color).\r\n<p>\r\nIn the event that the user does not set the first keyframe value equal\r\nto 0 and/or the last keyframe value equal to 1, keyframes will be created\r\nat these positions and the first and last colors will be replicated there.\r\nSo, if a user specifies the following arrays to construct a gradient:<br>\r\n<pre>\r\n    {Color.BLUE, Color.RED}, {.3f, .7f}\r\n</pre>\r\nthis will be converted to a gradient with the following keyframes:<br>\r\n<pre>\r\n    {Color.BLUE, Color.BLUE, Color.RED, Color.RED}, {0f, .3f, .7f, 1f}\r\n</pre>\r\n\r\n<p>\r\nThe user may also select what action the {@code LinearGradientPaint} object\r\ntakes when it is filling the space outside the start and end points by\r\nsetting {@code CycleMethod} to either {@code REFLECTION} or {@code REPEAT}.\r\nThe distances between any two colors in any of the reflected or repeated\r\ncopies of the gradient are the same as the distance between those same two\r\ncolors between the start and end points.\r\nNote that some minor variations in distances may occur due to sampling at\r\nthe granularity of a pixel.\r\nIf no cycle method is specified, {@code NO_CYCLE} will be chosen by\r\ndefault, which means the endpoint colors will be used to fill the\r\nremaining area.\r\n<p>\r\nThe colorSpace parameter allows the user to specify in which colorspace\r\nthe interpolation should be performed, default sRGB or linearized RGB.\r\n\r\n<p>\r\nThe following code demonstrates typical usage of\r\n{@code LinearGradientPaint}:\r\n<pre>\r\n    Point2D start = new Point2D.Float(0, 0);\r\n    Point2D end = new Point2D.Float(50, 50);\r\n    float[] dist = {0.0f, 0.2f, 1.0f};\r\n    Color[] colors = {Color.RED, Color.WHITE, Color.BLUE};\r\n    LinearGradientPaint p =\r\n        new LinearGradientPaint(start, end, dist, colors);\r\n</pre>\r\n<p>\r\nThis code will create a {@code LinearGradientPaint} which interpolates\r\nbetween red and white for the first 20% of the gradient and between white\r\nand blue for the remaining 80%.\r\n\r\n<p>\r\nThis image demonstrates the example code above for each\r\nof the three cycle methods:\r\n<center>\r\n<img src = \"doc-files/LinearGradientPaint.png\"\r\nalt=\"image showing the output of the example code\">\r\n</center>","inherit":["java.awt.MultipleGradientPaint"],"name":"java.awt.LinearGradientPaint","type":false},{"description":"Provides the actual implementation for the LinearGradientPaint.\r\nThis is where the pixel processing is done.","inherit":["java.awt.MultipleGradientPaintContext"],"name":"java.awt.LinearGradientPaintContext","type":false},{"description":"The <code>List</code> component presents the user with a\r\nscrolling list of text items. The list can be set up so that\r\nthe user can choose either one item or multiple items.\r\n<p>\r\nFor example, the code&nbsp;.&nbsp;.&nbsp;.\r\n\r\n<hr><blockquote><pre>\r\nList lst = new List(4, false);\r\nlst.add(\"Mercury\");\r\nlst.add(\"Venus\");\r\nlst.add(\"Earth\");\r\nlst.add(\"JavaSoft\");\r\nlst.add(\"Mars\");\r\nlst.add(\"Jupiter\");\r\nlst.add(\"Saturn\");\r\nlst.add(\"Uranus\");\r\nlst.add(\"Neptune\");\r\nlst.add(\"Pluto\");\r\ncnt.add(lst);\r\n</pre></blockquote><hr>\r\n<p>\r\nwhere <code>cnt</code> is a container, produces the following\r\nscrolling list:\r\n<p>\r\n<img src=\"doc-files/List-1.gif\"\r\nalt=\"Shows a list containing: Venus, Earth, JavaSoft, and Mars. Javasoft is selected.\" style=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nIf the List allows multiple selections, then clicking on\r\nan item that is already selected deselects it. In the preceding\r\nexample, only one item from the scrolling list can be selected\r\nat a time, since the second argument when creating the new scrolling\r\nlist is <code>false</code>. If the List does not allow multiple\r\nselections, selecting an item causes any other selected item\r\nto be deselected.\r\n<p>\r\nNote that the list in the example shown was created with four visible\r\nrows.  Once the list has been created, the number of visible rows\r\ncannot be changed.  A default <code>List</code> is created with\r\nfour rows, so that <code>lst = new List()</code> is equivalent to\r\n<code>list = new List(4, false)</code>.\r\n<p>\r\nBeginning with Java&nbsp;1.1, the Abstract Window Toolkit\r\nsends the <code>List</code> object all mouse, keyboard, and focus events\r\nthat occur over it. (The old AWT event model is being maintained\r\nonly for backwards compatibility, and its use is discouraged.)\r\n<p>\r\nWhen an item is selected or deselected by the user, AWT sends an instance\r\nof <code>ItemEvent</code> to the list.\r\nWhen the user double-clicks on an item in a scrolling list,\r\nAWT sends an instance of <code>ActionEvent</code> to the\r\nlist following the item event. AWT also generates an action event\r\nwhen the user presses the return key while an item in the\r\nlist is selected.\r\n<p>\r\nIf an application wants to perform some action based on an item\r\nin this list being selected or activated by the user, it should implement\r\n<code>ItemListener</code> or <code>ActionListener</code>\r\nas appropriate and register the new listener to receive\r\nevents from this list.\r\n<p>\r\nFor multiple-selection scrolling lists, it is considered a better\r\nuser interface to use an external gesture (such as clicking on a\r\nbutton) to trigger the action.","inherit":["java.awt.Component","java.awt.ItemSelectable","javax.accessibility.Accessible"],"name":"java.awt.List","type":false},{"description":"This class implements accessibility support for the\r\n<code>List</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to list user-interface elements.","inherit":["java.awt.Component.AccessibleAWTComponent","javax.accessibility.AccessibleSelection","java.awt.event.ItemListener","java.awt.event.ActionListener"],"name":"java.awt.List.AccessibleAWTList","type":false},{"description":"This class implements accessibility support for\r\nList children.  It provides an implementation of the\r\nJava Accessibility API appropriate to list children\r\nuser-interface elements.","inherit":["java.awt.Component.AccessibleAWTComponent","javax.accessibility.Accessible"],"name":"java.awt.List.AccessibleAWTList.AccessibleAWTListChild","type":false},{"description":"The <code>MediaTracker</code> class is a utility class to track\r\nthe status of a number of media objects. Media objects could\r\ninclude audio clips as well as images, though currently only\r\nimages are supported.\r\n<p>\r\nTo use a media tracker, create an instance of\r\n<code>MediaTracker</code> and call its <code>addImage</code>\r\nmethod for each image to be tracked. In addition, each image can\r\nbe assigned a unique identifier. This identifier controls the\r\npriority order in which the images are fetched. It can also be used\r\nto identify unique subsets of the images that can be waited on\r\nindependently. Images with a lower ID are loaded in preference to\r\nthose with a higher ID number.\r\n\r\n<p>\r\n\r\nTracking an animated image\r\nmight not always be useful\r\ndue to the multi-part nature of animated image\r\nloading and painting,\r\nbut it is supported.\r\n<code>MediaTracker</code> treats an animated image\r\nas completely loaded\r\nwhen the first frame is completely loaded.\r\nAt that point, the <code>MediaTracker</code>\r\nsignals any waiters\r\nthat the image is completely loaded.\r\nIf no <code>ImageObserver</code>s are observing the image\r\nwhen the first frame has finished loading,\r\nthe image might flush itself\r\nto conserve resources\r\n(see {@link Image#flush()}).\r\n\r\n<p>\r\nHere is an example of using <code>MediaTracker</code>:\r\n<p>\r\n<hr><blockquote><pre>{@code\r\nimport java.applet.Applet;\r\nimport java.awt.Color;\r\nimport java.awt.Image;\r\nimport java.awt.Graphics;\r\nimport java.awt.MediaTracker;\r\n\r\npublic class ImageBlaster extends Applet implements Runnable {\r\n     MediaTracker tracker;\r\n     Image bg;\r\n     Image anim[] = new Image[5];\r\n     int index;\r\n     Thread animator;\r\n\r\n     // Get the images for the background (id == 0)\r\n     // and the animation frames (id == 1)\r\n     // and add them to the MediaTracker\r\n     public void init() {\r\n         tracker = new MediaTracker(this);\r\n         bg = getImage(getDocumentBase(),\r\n                 \"images/background.gif\");\r\n         tracker.addImage(bg, 0);\r\n         for (int i = 0; i < 5; i++) {\r\n             anim[i] = getImage(getDocumentBase(),\r\n                     \"images/anim\"+i+\".gif\");\r\n             tracker.addImage(anim[i], 1);\r\n         }\r\n     }\r\n\r\n     // Start the animation thread.\r\n     public void start() {\r\n         animator = new Thread(this);\r\n         animator.start();\r\n     }\r\n\r\n     // Stop the animation thread.\r\n     public void stop() {\r\n         animator = null;\r\n     }\r\n\r\n     // Run the animation thread.\r\n     // First wait for the background image to fully load\r\n     // and paint.  Then wait for all of the animation\r\n     // frames to finish loading. Finally, loop and\r\n     // increment the animation frame index.\r\n     public void run() {\r\n         try {\r\n             tracker.waitForID(0);\r\n             tracker.waitForID(1);\r\n         } catch (InterruptedException e) {\r\n             return;\r\n         }\r\n         Thread me = Thread.currentThread();\r\n         while (animator == me) {\r\n             try {\r\n                 Thread.sleep(100);\r\n             } catch (InterruptedException e) {\r\n                 break;\r\n             }\r\n             synchronized (this) {\r\n                 index++;\r\n                 if (index >= anim.length) {\r\n                     index = 0;\r\n                 }\r\n             }\r\n             repaint();\r\n         }\r\n     }\r\n\r\n     // The background image fills the frame so we\r\n     // don't need to clear the applet on repaints.\r\n     // Just call the paint method.\r\n     public void update(Graphics g) {\r\n         paint(g);\r\n     }\r\n\r\n     // Paint a large red rectangle if there are any errors\r\n     // loading the images.  Otherwise always paint the\r\n     // background so that it appears incrementally as it\r\n     // is loading.  Finally, only paint the current animation\r\n     // frame if all of the frames (id == 1) are done loading,\r\n     // so that we don't get partial animations.\r\n     public void paint(Graphics g) {\r\n         if ((tracker.statusAll(false) & MediaTracker.ERRORED) != 0) {\r\n             g.setColor(Color.red);\r\n             g.fillRect(0, 0, size().width, size().height);\r\n             return;\r\n         }\r\n         g.drawImage(bg, 0, 0, this);\r\n         if (tracker.statusID(1, false) == MediaTracker.COMPLETE) {\r\n             g.drawImage(anim[index], 10, 10, this);\r\n         }\r\n     }\r\n}\r\n} </pre></blockquote><hr>","inherit":["java.io.Serializable"],"name":"java.awt.MediaTracker","type":false},{"description":"","inherit":[],"name":"java.awt.MediaEntry","type":false},{"description":"","inherit":["java.awt.MediaEntry","java.awt.image.ImageObserver","java.io.Serializable"],"name":"java.awt.ImageMediaEntry","type":false},{"description":"A <code>Menu</code> object is a pull-down menu component\r\nthat is deployed from a menu bar.\r\n<p>\r\nA menu can optionally be a <i>tear-off</i> menu. A tear-off menu\r\ncan be opened and dragged away from its parent menu bar or menu.\r\nIt remains on the screen after the mouse button has been released.\r\nThe mechanism for tearing off a menu is platform dependent, since\r\nthe look and feel of the tear-off menu is determined by its peer.\r\nOn platforms that do not support tear-off menus, the tear-off\r\nproperty is ignored.\r\n<p>\r\nEach item in a menu must belong to the <code>MenuItem</code>\r\nclass. It can be an instance of <code>MenuItem</code>, a submenu\r\n(an instance of <code>Menu</code>), or a check box (an instance of\r\n<code>CheckboxMenuItem</code>).","inherit":["java.awt.MenuItem","java.awt.MenuContainer","javax.accessibility.Accessible"],"name":"java.awt.Menu","type":false},{"description":"Inner class of Menu used to provide default support for\r\naccessibility.  This class is not meant to be used directly by\r\napplication developers, but is instead meant only to be\r\nsubclassed by menu component developers.\r\n<p>\r\nThis class implements accessibility support for the\r\n<code>Menu</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to menu user-interface elements.","inherit":["java.awt.MenuItem.AccessibleAWTMenuItem"],"name":"java.awt.Menu.AccessibleAWTMenu","type":false},{"description":"The <code>MenuBar</code> class encapsulates the platform's\r\nconcept of a menu bar bound to a frame. In order to associate\r\nthe menu bar with a <code>Frame</code> object, call the\r\nframe's <code>setMenuBar</code> method.\r\n<p>\r\n<A NAME=\"mbexample\"></A><!-- target for cross references -->\r\nThis is what a menu bar might look like:\r\n<p>\r\n<img src=\"doc-files/MenuBar-1.gif\"\r\nalt=\"Diagram of MenuBar containing 2 menus: Examples and Options.\r\nExamples menu is expanded showing items: Basic, Simple, Check, and More Examples.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nA menu bar handles keyboard shortcuts for menu items, passing them\r\nalong to its child menus.\r\n(Keyboard shortcuts, which are optional, provide the user with\r\nan alternative to the mouse for invoking a menu item and the\r\naction that is associated with it.)\r\nEach menu item can maintain an instance of <code>MenuShortcut</code>.\r\nThe <code>MenuBar</code> class defines several methods,\r\n{@link MenuBar#shortcuts} and\r\n{@link MenuBar#getShortcutMenuItem}\r\nthat retrieve information about the shortcuts a given\r\nmenu bar is managing.","inherit":["java.awt.MenuComponent","java.awt.MenuContainer","javax.accessibility.Accessible"],"name":"java.awt.MenuBar","type":false},{"description":"Inner class of MenuBar used to provide default support for\r\naccessibility.  This class is not meant to be used directly by\r\napplication developers, but is instead meant only to be\r\nsubclassed by menu component developers.\r\n<p>\r\nThis class implements accessibility support for the\r\n<code>MenuBar</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to menu bar user-interface elements.","inherit":["java.awt.MenuComponent.AccessibleAWTMenuComponent"],"name":"java.awt.MenuBar.AccessibleAWTMenuBar","type":false},{"description":"The abstract class <code>MenuComponent</code> is the superclass\r\nof all menu-related components. In this respect, the class\r\n<code>MenuComponent</code> is analogous to the abstract superclass\r\n<code>Component</code> for AWT components.\r\n<p>\r\nMenu components receive and process AWT events, just as components do,\r\nthrough the method <code>processEvent</code>.","inherit":["java.io.Serializable"],"name":"java.awt.MenuComponent","type":false},{"description":"Inner class of <code>MenuComponent</code> used to provide\r\ndefault support for accessibility.  This class is not meant\r\nto be used directly by application developers, but is instead\r\nmeant only to be subclassed by menu component developers.\r\n<p>\r\nThe class used to obtain the accessible role for this object.","inherit":["javax.accessibility.AccessibleContext","java.io.Serializable","javax.accessibility.AccessibleComponent","javax.accessibility.AccessibleSelection"],"name":"java.awt.MenuComponent.AccessibleAWTMenuComponent","type":false},{"description":"","inherit":[],"name":"java.awt.MenuContainer","type":true},{"description":"All items in a menu must belong to the class\r\n<code>MenuItem</code>, or one of its subclasses.\r\n<p>\r\nThe default <code>MenuItem</code> object embodies\r\na simple labeled menu item.\r\n<p>\r\nThis picture of a menu bar shows five menu items:\r\n<IMG SRC=\"doc-files/MenuBar-1.gif\" alt=\"The following text describes this graphic.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<br style=\"clear:left;\">\r\nThe first two items are simple menu items, labeled\r\n<code>\"Basic\"</code> and <code>\"Simple\"</code>.\r\nFollowing these two items is a separator, which is itself\r\na menu item, created with the label <code>\"-\"</code>.\r\nNext is an instance of <code>CheckboxMenuItem</code>\r\nlabeled <code>\"Check\"</code>. The final menu item is a\r\nsubmenu labeled <code>\"More&nbsp;Examples\"</code>,\r\nand this submenu is an instance of <code>Menu</code>.\r\n<p>\r\nWhen a menu item is selected, AWT sends an action event to\r\nthe menu item. Since the event is an\r\ninstance of <code>ActionEvent</code>, the <code>processEvent</code>\r\nmethod examines the event and passes it along to\r\n<code>processActionEvent</code>. The latter method redirects the\r\nevent to any <code>ActionListener</code> objects that have\r\nregistered an interest in action events generated by this\r\nmenu item.\r\n<P>\r\nNote that the subclass <code>Menu</code> overrides this behavior and\r\ndoes not send any event to the frame until one of its subitems is\r\nselected.","inherit":["java.awt.MenuComponent","javax.accessibility.Accessible"],"name":"java.awt.MenuItem","type":false},{"description":"Inner class of MenuItem used to provide default support for\r\naccessibility.  This class is not meant to be used directly by\r\napplication developers, but is instead meant only to be\r\nsubclassed by menu component developers.\r\n<p>\r\nThis class implements accessibility support for the\r\n<code>MenuItem</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to menu item user-interface elements.","inherit":["java.awt.MenuComponent.AccessibleAWTMenuComponent","javax.accessibility.AccessibleAction","javax.accessibility.AccessibleValue"],"name":"java.awt.MenuItem.AccessibleAWTMenuItem","type":false},{"description":"The <code>MenuShortcut</code>class represents a keyboard accelerator\r\nfor a MenuItem.\r\n<p>\r\nMenu shortcuts are created using virtual keycodes, not characters.\r\nFor example, a menu shortcut for Ctrl-a (assuming that Control is\r\nthe accelerator key) would be created with code like the following:\r\n<p>\r\n<code>MenuShortcut ms = new MenuShortcut(KeyEvent.VK_A, false);</code>\r\n<p> or alternatively\r\n<p>\r\n<code>MenuShortcut ms = new MenuShortcut(KeyEvent.getExtendedKeyCodeForChar('A'), false);</code>\r\n<p>\r\nMenu shortcuts may also be constructed for a wider set of keycodes\r\nusing the <code>java.awt.event.KeyEvent.getExtendedKeyCodeForChar</code> call.\r\nFor example, a menu shortcut for \"Ctrl+cyrillic ef\" is created by\r\n<p>\r\n<code>MenuShortcut ms = new MenuShortcut(KeyEvent.getExtendedKeyCodeForChar('\\u0444'), false);</code>\r\n<p>\r\nNote that shortcuts created with a keycode or an extended keycode defined as a constant in <code>KeyEvent</code>\r\nwork regardless of the current keyboard layout. However, a shortcut made of\r\nan extended keycode not listed in <code>KeyEvent</code>\r\nonly work if the current keyboard layout produces a corresponding letter.\r\n<p>\r\nThe accelerator key is platform-dependent and may be obtained\r\nvia {@link Toolkit#getMenuShortcutKeyMask}.","inherit":["java.io.Serializable"],"name":"java.awt.MenuShortcut","type":false},{"description":"","inherit":["java.awt.EventFilter"],"name":"java.awt.ModalEventFilter","type":false},{"description":"","inherit":["java.awt.ModalEventFilter"],"name":"java.awt.ModalEventFilter.ToolkitModalEventFilter","type":false},{"description":"","inherit":["java.awt.ModalEventFilter"],"name":"java.awt.ModalEventFilter.ApplicationModalEventFilter","type":false},{"description":"","inherit":["java.awt.ModalEventFilter"],"name":"java.awt.ModalEventFilter.DocumentModalEventFilter","type":false},{"description":"","inherit":[],"name":"java.awt.MouseInfo","type":false},{"description":"This is the superclass for Paints which use a multiple color\r\ngradient to fill in their raster.  It provides storage for variables and\r\nenumerated values common to\r\n{@code LinearGradientPaint} and {@code RadialGradientPaint}.","inherit":["java.awt.Paint"],"name":"java.awt.MultipleGradientPaint","type":false},{"description":"This is the superclass for all PaintContexts which use a multiple color\r\ngradient to fill in their raster.  It provides the actual color\r\ninterpolation functionality.  Subclasses only have to deal with using\r\nthe gradient to fill pixels in a raster.","inherit":["java.awt.PaintContext"],"name":"java.awt.MultipleGradientPaintContext","type":false},{"description":"A set of attributes which control the output of a printed page.\r\n<p>\r\nInstances of this class control the color state, paper size (media type),\r\norientation, logical origin, print quality, and resolution of every\r\npage which uses the instance. Attribute names are compliant with the\r\nInternet Printing Protocol (IPP) 1.1 where possible. Attribute values\r\nare partially compliant where possible.\r\n<p>\r\nTo use a method which takes an inner class type, pass a reference to\r\none of the constant fields of the inner class. Client code cannot create\r\nnew instances of the inner class types because none of those classes\r\nhas a public constructor. For example, to set the color state to\r\nmonochrome, use the following code:\r\n<pre>\r\nimport java.awt.PageAttributes;\r\n\r\npublic class MonochromeExample {\r\n    public void setMonochrome(PageAttributes pageAttributes) {\r\n        pageAttributes.setColor(PageAttributes.ColorType.MONOCHROME);\r\n    }\r\n}\r\n</pre>\r\n<p>\r\nEvery IPP attribute which supports an <i>attributeName</i>-default value\r\nhas a corresponding <code>set<i>attributeName</i>ToDefault</code> method.\r\nDefault value fields are not provided.","inherit":["java.lang.Cloneable"],"name":"java.awt.PageAttributes","type":false},{"description":"A type-safe enumeration of possible color states.","inherit":["java.awt.AttributeValue"],"name":"java.awt.PageAttributes.ColorType","type":false},{"description":"A type-safe enumeration of possible paper sizes. These sizes are in\r\ncompliance with IPP 1.1.","inherit":["java.awt.AttributeValue"],"name":"java.awt.PageAttributes.MediaType","type":false},{"description":"A type-safe enumeration of possible orientations. These orientations\r\nare in partial compliance with IPP 1.1.","inherit":["java.awt.AttributeValue"],"name":"java.awt.PageAttributes.OrientationRequestedType","type":false},{"description":"A type-safe enumeration of possible origins.","inherit":["java.awt.AttributeValue"],"name":"java.awt.PageAttributes.OriginType","type":false},{"description":"A type-safe enumeration of possible print qualities. These print\r\nqualities are in compliance with IPP 1.1.","inherit":["java.awt.AttributeValue"],"name":"java.awt.PageAttributes.PrintQualityType","type":false},{"description":"","inherit":["java.awt.Transparency"],"name":"java.awt.Paint","type":true},{"description":"","inherit":[],"name":"java.awt.PaintContext","type":true},{"description":"<code>Panel</code> is the simplest container class. A panel\r\nprovides space in which an application can attach any other\r\ncomponent, including other panels.\r\n<p>\r\nThe default layout manager for a panel is the\r\n<code>FlowLayout</code> layout manager.","inherit":["java.awt.Container","javax.accessibility.Accessible"],"name":"java.awt.Panel","type":false},{"description":"This class implements accessibility support for the\r\n<code>Panel</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to panel user-interface elements.","inherit":["java.awt.Container.AccessibleAWTContainer"],"name":"java.awt.Panel.AccessibleAWTPanel","type":false},{"description":"The peer interface for {@link Button}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.ButtonPeer","type":true},{"description":"The peer interface for {@link Canvas}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.CanvasPeer","type":true},{"description":"The peer interface for {@link CheckboxMenuItem}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.MenuItemPeer"],"name":"java.awt.peer.CheckboxMenuItemPeer","type":true},{"description":"The peer interface for {@link Checkbox}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.CheckboxPeer","type":true},{"description":"The peer interface for {@link Choice}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.ChoicePeer","type":true},{"description":"The peer interface for {@link Component}. This is the top level peer\r\ninterface for widgets and defines the bulk of methods for AWT component\r\npeers. Most component peers have to implement this interface (via one\r\nof the subinterfaces), except menu components, which implement\r\n{@link MenuComponentPeer}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":[],"name":"java.awt.peer.ComponentPeer","type":true},{"description":"The peer interface for {@link Container}. This is the parent interface\r\nfor all container like widgets.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.ContainerPeer","type":true},{"description":"The {@code DesktopPeer} interface provides methods for the operation\r\nof open, edit, print, browse and mail with the given URL or file, by\r\nlaunching the associated application.\r\n<p>\r\nEach platform has an implementation class for this interface.","inherit":[],"name":"java.awt.peer.DesktopPeer","type":true},{"description":"The peer interface for {@link Dialog}. This adds a couple of dialog specific\r\nfeatures to the {@link WindowPeer} interface.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.WindowPeer"],"name":"java.awt.peer.DialogPeer","type":true},{"description":"The peer interface for {@link FileDialog}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.DialogPeer"],"name":"java.awt.peer.FileDialogPeer","type":true},{"description":"The peer interface for fonts. This is only a marker interface and not\r\nused by AWT itself.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":[],"name":"java.awt.peer.FontPeer","type":true},{"description":"The peer interface for {@link Frame}. This adds a couple of frame specific\r\nmethods to the {@link WindowPeer} interface.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.WindowPeer"],"name":"java.awt.peer.FramePeer","type":true},{"description":"The native peer interface for {@link KeyboardFocusManager}.","inherit":[],"name":"java.awt.peer.KeyboardFocusManagerPeer","type":true},{"description":"The peer interface for {@link Label}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.LabelPeer","type":true},{"description":"The LightweightPeer interface marks a component as depending upon\r\na native container so window related events can be routed to the\r\ncomponent.  Since this only applies to components and their\r\nextensions, this interface extends ComponentPeer.\r\n<p>\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.LightweightPeer","type":true},{"description":"The peer interface for {@link List}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.ListPeer","type":true},{"description":"The peer interface for {@link MenuBar}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.MenuComponentPeer"],"name":"java.awt.peer.MenuBarPeer","type":true},{"description":"The base interface for all kinds of menu components. This is used by\r\n{@link MenuComponent}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":[],"name":"java.awt.peer.MenuComponentPeer","type":true},{"description":"The peer interface for menu items. This is used by {@link MenuItem}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.MenuComponentPeer"],"name":"java.awt.peer.MenuItemPeer","type":true},{"description":"The peer interface for menus. This is used by {@link Menu}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.MenuItemPeer"],"name":"java.awt.peer.MenuPeer","type":true},{"description":"Peer interface for {@link MouseInfo}. This is used to get some additional\r\ninformation about the mouse.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":[],"name":"java.awt.peer.MouseInfoPeer","type":true},{"description":"The peer interface for {@link Panel}. This is a subinterface of\r\nContainerPeer and does not declare any additional methods because a Panel\r\nis just that, a concrete Container.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ContainerPeer"],"name":"java.awt.peer.PanelPeer","type":true},{"description":"The peer interface for {@link PopupMenu}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.MenuPeer"],"name":"java.awt.peer.PopupMenuPeer","type":true},{"description":"RobotPeer defines an interface whereby toolkits support automated testing\r\nby allowing native input events to be generated from Java code.\r\n\r\nThis interface should not be directly imported by code outside the\r\njava.awt.* hierarchy; it is not to be considered public and is subject\r\nto change.","inherit":[],"name":"java.awt.peer.RobotPeer","type":true},{"description":"The peer interface for {@link Scrollbar}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.ScrollbarPeer","type":true},{"description":"The peer interface for {@link ScrollPane}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ContainerPeer"],"name":"java.awt.peer.ScrollPanePeer","type":true},{"description":"The peer interface for {@link SystemTray}. This doesn't need to be\r\nimplemented if {@link SystemTray#isSupported()} returns false.","inherit":[],"name":"java.awt.peer.SystemTrayPeer","type":true},{"description":"The peer interface for {@link TexTArea}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.TextComponentPeer"],"name":"java.awt.peer.TextAreaPeer","type":true},{"description":"The peer interface for {@link TextComponent}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ComponentPeer"],"name":"java.awt.peer.TextComponentPeer","type":true},{"description":"The peer interface for {@link TextField}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.TextComponentPeer"],"name":"java.awt.peer.TextFieldPeer","type":true},{"description":"The peer interface for the {@link TrayIcon}. This doesn't need to be\r\nimplemented if {@link SystemTray#isSupported()} returns false.","inherit":[],"name":"java.awt.peer.TrayIconPeer","type":true},{"description":"The peer interface for {@link Window}.\r\n\r\nThe peer interfaces are intended only for use in porting\r\nthe AWT. They are not intended for use by application\r\ndevelopers, and developers should not implement peers\r\nnor invoke any of the peer methods directly on the peer\r\ninstances.","inherit":["java.awt.peer.ContainerPeer"],"name":"java.awt.peer.WindowPeer","type":true},{"description":"A point representing a location in {@code (x,y)} coordinate space,\r\nspecified in integer precision.","inherit":["java.awt.geom.Point2D","java.io.Serializable"],"name":"java.awt.Point","type":false},{"description":"A class that describes the pointer position.\r\nIt provides the {@code GraphicsDevice} where the pointer is and\r\nthe {@code Point} that represents the coordinates of the pointer.\r\n<p>\r\nInstances of this class should be obtained via\r\n{@link MouseInfo#getPointerInfo}.\r\nThe {@code PointerInfo} instance is not updated dynamically as the mouse\r\nmoves. To get the updated location, you must call\r\n{@link MouseInfo#getPointerInfo} again.","inherit":[],"name":"java.awt.PointerInfo","type":false},{"description":"The <code>Polygon</code> class encapsulates a description of a\r\nclosed, two-dimensional region within a coordinate space. This\r\nregion is bounded by an arbitrary number of line segments, each of\r\nwhich is one side of the polygon. Internally, a polygon\r\ncomprises of a list of {@code (x,y)}\r\ncoordinate pairs, where each pair defines a <i>vertex</i> of the\r\npolygon, and two successive pairs are the endpoints of a\r\nline that is a side of the polygon. The first and final\r\npairs of {@code (x,y)} points are joined by a line segment\r\nthat closes the polygon.  This <code>Polygon</code> is defined with\r\nan even-odd winding rule.  See\r\n{@link java.awt.geom.PathIterator#WIND_EVEN_ODD WIND_EVEN_ODD}\r\nfor a definition of the even-odd winding rule.\r\nThis class's hit-testing methods, which include the\r\n<code>contains</code>, <code>intersects</code> and <code>inside</code>\r\nmethods, use the <i>insideness</i> definition described in the\r\n{@link Shape} class comments.","inherit":["java.awt.Shape","java.io.Serializable"],"name":"java.awt.Polygon","type":false},{"description":"","inherit":["java.awt.geom.PathIterator"],"name":"java.awt.Polygon.PolygonPathIterator","type":false},{"description":"A class that implements a menu which can be dynamically popped up\r\nat a specified position within a component.\r\n<p>\r\nAs the inheritance hierarchy implies, a <code>PopupMenu</code>\r\n can be used anywhere a <code>Menu</code> can be used.\r\nHowever, if you use a <code>PopupMenu</code> like a <code>Menu</code>\r\n(e.g., you add it to a <code>MenuBar</code>), then you <b>cannot</b>\r\ncall <code>show</code> on that <code>PopupMenu</code>.","inherit":["java.awt.Menu"],"name":"java.awt.PopupMenu","type":false},{"description":"Inner class of PopupMenu used to provide default support for\r\naccessibility.  This class is not meant to be used directly by\r\napplication developers, but is instead meant only to be\r\nsubclassed by menu component developers.\r\n<p>\r\nThe class used to obtain the accessible role for this object.","inherit":["java.awt.Menu.AccessibleAWTMenu"],"name":"java.awt.PopupMenu.AccessibleAWTPopupMenu","type":false},{"description":"","inherit":["java.awt.print.Pageable"],"name":"java.awt.print.Book","type":false},{"description":"The BookPage inner class describes an individual\r\npage in a Book through a PageFormat-Printable pair.","inherit":[],"name":"java.awt.print.Book.BookPage","type":false},{"description":"The <code>Pageable</code> implementation represents a set of\r\npages to be printed. The <code>Pageable</code> object returns\r\nthe total number of pages in the set as well as the\r\n{@link PageFormat} and {@link Printable} for a specified page.","inherit":[],"name":"java.awt.print.Pageable","type":true},{"description":"The <code>PageFormat</code> class describes the size and\r\norientation of a page to be printed.","inherit":["java.lang.Cloneable"],"name":"java.awt.print.PageFormat","type":false},{"description":"The <code>Paper</code> class describes the physical characteristics of\r\na piece of paper.\r\n<p>\r\nWhen creating a <code>Paper</code> object, it is the application's\r\nresponsibility to ensure that the paper size and the imageable area\r\nare compatible.  For example, if the paper size is changed from\r\n11 x 17 to 8.5 x 11, the application might need to reduce the\r\nimageable area so that whatever is printed fits on the page.\r\n<p>","inherit":["java.lang.Cloneable"],"name":"java.awt.print.Paper","type":false},{"description":"The <code>Printable</code> interface is implemented\r\nby the <code>print</code> methods of the current\r\npage painter, which is called by the printing\r\nsystem to render a page.  When building a\r\n{@link Pageable}, pairs of {@link PageFormat}\r\ninstances and instances that implement\r\nthis interface are used to describe each page. The\r\ninstance implementing <code>Printable</code> is called to\r\nprint the page's graphics.\r\n<p>\r\nA <code>Printable(..)</code> may be set on a <code>PrinterJob</code>.\r\nWhen the client subsequently initiates printing by calling\r\n<code>PrinterJob.print(..)</code> control\r\n<p>\r\nis handed to the printing system until all pages have been printed.\r\nIt does this by calling <code>Printable.print(..)</code> until\r\nall pages in the document have been printed.\r\nIn using the <code>Printable</code> interface the printing\r\ncommits to image the contents of a page whenever\r\nrequested by the printing system.\r\n<p>\r\nThe parameters to <code>Printable.print(..)</code> include a\r\n<code>PageFormat</code> which describes the printable area of\r\nthe page, needed for calculating the contents that will fit the\r\npage, and the page index, which specifies the zero-based print\r\nstream index of the requested page.\r\n<p>\r\nFor correct printing behaviour, the following points should be\r\nobserved:\r\n<ul>\r\n<li> The printing system may request a page index more than once.\r\nOn each occasion equal PageFormat parameters will be supplied.\r\n\r\n<li>The printing system will call <code>Printable.print(..)</code>\r\nwith page indexes which increase monotonically, although as noted above,\r\nthe <code>Printable</code> should expect multiple calls for a page index\r\nand that page indexes may be skipped, when page ranges are specified\r\nby the client, or by a user through a print dialog.\r\n\r\n<li>If multiple collated copies of a document are requested, and the\r\nprinter cannot natively support this, then the document may be imaged\r\nmultiple times. Printing will start each copy from the lowest print\r\nstream page index page.\r\n\r\n<li>With the exception of re-imaging an entire document for multiple\r\ncollated copies, the increasing page index order means that when\r\npage N is requested if a client needs to calculate page break position,\r\nit may safely discard any state related to pages &lt; N, and make current\r\nthat for page N. \"State\" usually is just the calculated position in the\r\ndocument that corresponds to the start of the page.\r\n\r\n<li>When called by the printing system the <code>Printable</code> must\r\ninspect and honour the supplied PageFormat parameter as well as the\r\npage index.  The format of the page to be drawn is specified by the\r\nsupplied PageFormat. The size, orientation and imageable area of the page\r\nis therefore already determined and rendering must be within this\r\nimageable area.\r\nThis is key to correct printing behaviour, and it has the\r\nimplication that the client has the responsibility of tracking\r\nwhat content belongs on the specified page.\r\n\r\n<li>When the <code>Printable</code> is obtained from a client-supplied\r\n<code>Pageable</code> then the client may provide different PageFormats\r\nfor each page index. Calculations of page breaks must account for this.\r\n</ul>\r\n<p>","inherit":[],"name":"java.awt.print.Printable","type":true},{"description":"","inherit":["java.awt.print.PrinterException"],"name":"java.awt.print.PrinterAbortException","type":false},{"description":"","inherit":["java.lang.Exception"],"name":"java.awt.print.PrinterException","type":false},{"description":"","inherit":[],"name":"java.awt.print.PrinterGraphics","type":true},{"description":"The <code>PrinterIOException</code> class is a subclass of\r\n{@link PrinterException} and is used to indicate that an IO error\r\nof some sort has occurred while printing.\r\n\r\n<p>As of release 1.4, this exception has been retrofitted to conform to\r\nthe general purpose exception-chaining mechanism.  The\r\n\"<code>IOException</code> that terminated the print job\"\r\nthat is provided at construction time and accessed via the\r\n{@link #getIOException()} method is now known as the <i>cause</i>,\r\nand may be accessed via the {@link Throwable#getCause()} method,\r\nas well as the aforementioned \"legacy method.\"","inherit":["java.awt.print.PrinterException"],"name":"java.awt.print.PrinterIOException","type":false},{"description":"The <code>PrinterJob</code> class is the principal class that controls\r\nprinting. An application calls methods in this class to set up a job,\r\noptionally to invoke a print dialog with the user, and then to print\r\nthe pages of the job.","inherit":[],"name":"java.awt.print.PrinterJob","type":false},{"description":"An abstract class which provides a print graphics context for a page.","inherit":[],"name":"java.awt.PrintGraphics","type":true},{"description":"An abstract class which initiates and executes a print job.\r\nIt provides access to a print graphics object which renders\r\nto an appropriate print device.","inherit":[],"name":"java.awt.PrintJob","type":false},{"description":"The {@code RadialGradientPaint} class provides a way to fill a shape with\r\na circular radial color gradient pattern. The user may specify 2 or more\r\ngradient colors, and this paint will provide an interpolation between\r\neach color.\r\n<p>\r\nThe user must specify the circle controlling the gradient pattern,\r\nwhich is described by a center point and a radius.  The user can also\r\nspecify a separate focus point within that circle, which controls the\r\nlocation of the first color of the gradient.  By default the focus is\r\nset to be the center of the circle.\r\n<p>\r\nThis paint will map the first color of the gradient to the focus point,\r\nand the last color to the perimeter of the circle, interpolating\r\nsmoothly for any in-between colors specified by the user.  Any line drawn\r\nfrom the focus point to the circumference will thus span all the gradient\r\ncolors.\r\n<p>\r\nSpecifying a focus point outside of the radius of the circle will cause\r\nthe rings of the gradient pattern to be centered on the point just inside\r\nthe edge of the circle in the direction of the focus point.\r\nThe rendering will internally use this modified location as if it were\r\nthe specified focus point.\r\n<p>\r\nThe user must provide an array of floats specifying how to distribute the\r\ncolors along the gradient.  These values should range from 0.0 to 1.0 and\r\nact like keyframes along the gradient (they mark where the gradient should\r\nbe exactly a particular color).\r\n<p>\r\nIn the event that the user does not set the first keyframe value equal\r\nto 0 and/or the last keyframe value equal to 1, keyframes will be created\r\nat these positions and the first and last colors will be replicated there.\r\nSo, if a user specifies the following arrays to construct a gradient:<br>\r\n<pre>\r\n    {Color.BLUE, Color.RED}, {.3f, .7f}\r\n</pre>\r\nthis will be converted to a gradient with the following keyframes:<br>\r\n<pre>\r\n    {Color.BLUE, Color.BLUE, Color.RED, Color.RED}, {0f, .3f, .7f, 1f}\r\n</pre>\r\n\r\n<p>\r\nThe user may also select what action the {@code RadialGradientPaint} object\r\ntakes when it is filling the space outside the circle's radius by\r\nsetting {@code CycleMethod} to either {@code REFLECTION} or {@code REPEAT}.\r\nThe gradient color proportions are equal for any particular line drawn\r\nfrom the focus point. The following figure shows that the distance AB\r\nis equal to the distance BC, and the distance AD is equal to the distance DE.\r\n<center>\r\n<img src = \"doc-files/RadialGradientPaint-3.png\" alt=\"image showing the\r\ndistance AB=BC, and AD=DE\">\r\n</center>\r\nIf the gradient and graphics rendering transforms are uniformly scaled and\r\nthe user sets the focus so that it coincides with the center of the circle,\r\nthe gradient color proportions are equal for any line drawn from the center.\r\nThe following figure shows the distances AB, BC, AD, and DE. They are all equal.\r\n<center>\r\n<img src = \"doc-files/RadialGradientPaint-4.png\" alt=\"image showing the\r\ndistance of AB, BC, AD, and DE are all equal\">\r\n</center>\r\nNote that some minor variations in distances may occur due to sampling at\r\nthe granularity of a pixel.\r\nIf no cycle method is specified, {@code NO_CYCLE} will be chosen by\r\ndefault, which means the the last keyframe color will be used to fill the\r\nremaining area.\r\n<p>\r\nThe colorSpace parameter allows the user to specify in which colorspace\r\nthe interpolation should be performed, default sRGB or linearized RGB.\r\n\r\n<p>\r\nThe following code demonstrates typical usage of\r\n{@code RadialGradientPaint}, where the center and focus points are\r\nthe same:\r\n<pre>\r\n    Point2D center = new Point2D.Float(50, 50);\r\n    float radius = 25;\r\n    float[] dist = {0.0f, 0.2f, 1.0f};\r\n    Color[] colors = {Color.RED, Color.WHITE, Color.BLUE};\r\n    RadialGradientPaint p =\r\n        new RadialGradientPaint(center, radius, dist, colors);\r\n</pre>\r\n\r\n<p>\r\nThis image demonstrates the example code above, with default\r\n(centered) focus for each of the three cycle methods:\r\n<center>\r\n<img src = \"doc-files/RadialGradientPaint-1.png\" alt=\"image showing the\r\noutput of the sameple code\">\r\n</center>\r\n\r\n<p>\r\nIt is also possible to specify a non-centered focus point, as\r\nin the following code:\r\n<pre>\r\n    Point2D center = new Point2D.Float(50, 50);\r\n    float radius = 25;\r\n    Point2D focus = new Point2D.Float(40, 40);\r\n    float[] dist = {0.0f, 0.2f, 1.0f};\r\n    Color[] colors = {Color.RED, Color.WHITE, Color.BLUE};\r\n    RadialGradientPaint p =\r\n        new RadialGradientPaint(center, radius, focus,\r\n                                dist, colors,\r\n                                CycleMethod.NO_CYCLE);\r\n</pre>\r\n\r\n<p>\r\nThis image demonstrates the previous example code, with non-centered\r\nfocus for each of the three cycle methods:\r\n<center>\r\n<img src = \"doc-files/RadialGradientPaint-2.png\" alt=\"image showing the\r\noutput of the sample code\">\r\n</center>","inherit":["java.awt.MultipleGradientPaint"],"name":"java.awt.RadialGradientPaint","type":false},{"description":"Provides the actual implementation for the RadialGradientPaint.\r\nThis is where the pixel processing is done.  A RadialGradienPaint\r\nonly supports circular gradients, but it should be possible to scale\r\nthe circle to look approximately elliptical, by means of a\r\ngradient transform passed into the RadialGradientPaint constructor.","inherit":["java.awt.MultipleGradientPaintContext"],"name":"java.awt.RadialGradientPaintContext","type":false},{"description":"A <code>Rectangle</code> specifies an area in a coordinate space that is\r\nenclosed by the <code>Rectangle</code> object's upper-left point\r\n{@code (x,y)}\r\nin the coordinate space, its width, and its height.\r\n<p>\r\nA <code>Rectangle</code> object's <code>width</code> and\r\n<code>height</code> are <code>public</code> fields. The constructors\r\nthat create a <code>Rectangle</code>, and the methods that can modify\r\none, do not prevent setting a negative value for width or height.\r\n<p>\r\n<a name=\"Empty\">\r\nA {@code Rectangle} whose width or height is exactly zero has location\r\nalong those axes with zero dimension, but is otherwise considered empty.\r\nThe {@link #isEmpty} method will return true for such a {@code Rectangle}.\r\nMethods which test if an empty {@code Rectangle} contains or intersects\r\na point or rectangle will always return false if either dimension is zero.\r\nMethods which combine such a {@code Rectangle} with a point or rectangle\r\nwill include the location of the {@code Rectangle} on that axis in the\r\nresult as if the {@link #add(Point)} method were being called.\r\n</a>\r\n<p>\r\n<a name=\"NonExistant\">\r\nA {@code Rectangle} whose width or height is negative has neither\r\nlocation nor dimension along those axes with negative dimensions.\r\nSuch a {@code Rectangle} is treated as non-existant along those axes.\r\nSuch a {@code Rectangle} is also empty with respect to containment\r\ncalculations and methods which test if it contains or intersects a\r\npoint or rectangle will always return false.\r\nMethods which combine such a {@code Rectangle} with a point or rectangle\r\nwill ignore the {@code Rectangle} entirely in generating the result.\r\nIf two {@code Rectangle} objects are combined and each has a negative\r\ndimension, the result will have at least one negative dimension.\r\n</a>\r\n<p>\r\nMethods which affect only the location of a {@code Rectangle} will\r\noperate on its location regardless of whether or not it has a negative\r\nor zero dimension along either axis.\r\n<p>\r\nNote that a {@code Rectangle} constructed with the default no-argument\r\nconstructor will have dimensions of {@code 0x0} and therefore be empty.\r\nThat {@code Rectangle} will still have a location of {@code (0,0)} and\r\nwill contribute that location to the union and add operations.\r\nCode attempting to accumulate the bounds of a set of points should\r\ntherefore initially construct the {@code Rectangle} with a specifically\r\nnegative width and height or it should use the first point in the set\r\nto construct the {@code Rectangle}.\r\nFor example:\r\n<pre>{@code\r\n    Rectangle bounds = new Rectangle(0, 0, -1, -1);\r\n    for (int i = 0; i < points.length; i++) {\r\n        bounds.add(points[i]);\r\n    }\r\n}</pre>\r\nor if we know that the points array contains at least one point:\r\n<pre>{@code\r\n    Rectangle bounds = new Rectangle(points[0]);\r\n    for (int i = 1; i < points.length; i++) {\r\n        bounds.add(points[i]);\r\n    }\r\n}</pre>\r\n<p>\r\nThis class uses 32-bit integers to store its location and dimensions.\r\nFrequently operations may produce a result that exceeds the range of\r\na 32-bit integer.\r\nThe methods will calculate their results in a way that avoids any\r\n32-bit overflow for intermediate results and then choose the best\r\nrepresentation to store the final results back into the 32-bit fields\r\nwhich hold the location and dimensions.\r\nThe location of the result will be stored into the {@link #x} and\r\n{@link #y} fields by clipping the true result to the nearest 32-bit value.\r\nThe values stored into the {@link #width} and {@link #height} dimension\r\nfields will be chosen as the 32-bit values that encompass the largest\r\npart of the true result as possible.\r\nGenerally this means that the dimension will be clipped independently\r\nto the range of 32-bit integers except that if the location had to be\r\nmoved to store it into its pair of 32-bit fields then the dimensions\r\nwill be adjusted relative to the \"best representation\" of the location.\r\nIf the true result had a negative dimension and was therefore\r\nnon-existant along one or both axes, the stored dimensions will be\r\nnegative numbers in those axes.\r\nIf the true result had a location that could be represented within\r\nthe range of 32-bit integers, but zero dimension along one or both\r\naxes, then the stored dimensions will be zero in those axes.","inherit":["java.awt.geom.Rectangle2D","java.awt.Shape","java.io.Serializable"],"name":"java.awt.Rectangle","type":false},{"description":"The {@code RenderingHints} class defines and manages collections of\r\nkeys and associated values which allow an application to provide input\r\ninto the choice of algorithms used by other classes which perform\r\nrendering and image manipulation services.\r\nThe {@link java.awt.Graphics2D} class, and classes that implement\r\n{@link java.awt.image.BufferedImageOp} and\r\n{@link java.awt.image.RasterOp} all provide methods to get and\r\npossibly to set individual or groups of {@code RenderingHints}\r\nkeys and their associated values.\r\nWhen those implementations perform any rendering or image manipulation\r\noperations they should examine the values of any {@code RenderingHints}\r\nthat were requested by the caller and tailor the algorithms used\r\naccordingly and to the best of their ability.\r\n<p>\r\nNote that since these keys and values are <i>hints</i>, there is\r\nno requirement that a given implementation supports all possible\r\nchoices indicated below or that it can respond to requests to\r\nmodify its choice of algorithm.\r\nThe values of the various hint keys may also interact such that\r\nwhile all variants of a given key are supported in one situation,\r\nthe implementation may be more restricted when the values associated\r\nwith other keys are modified.\r\nFor example, some implementations may be able to provide several\r\ntypes of dithering when the antialiasing hint is turned off, but\r\nhave little control over dithering when antialiasing is on.\r\nThe full set of supported keys and hints may also vary by destination\r\nsince runtimes may use different underlying modules to render to\r\nthe screen, or to {@link java.awt.image.BufferedImage} objects,\r\nor while printing.\r\n<p>\r\nImplementations are free to ignore the hints completely, but should\r\ntry to use an implementation algorithm that is as close as possible\r\nto the request.\r\nIf an implementation supports a given algorithm when any value is used\r\nfor an associated hint key, then minimally it must do so when the\r\nvalue for that key is the exact value that specifies the algorithm.\r\n<p>\r\nThe keys used to control the hints are all special values that\r\nsubclass the associated {@link RenderingHints.Key} class.\r\nMany common hints are expressed below as static constants in this\r\nclass, but the list is not meant to be exhaustive.\r\nOther hints may be created by other packages by defining new objects\r\nwhich subclass the {@code Key} class and defining the associated values.","inherit":["java.util.Map","java.lang.Cloneable"],"name":"java.awt.RenderingHints","type":false},{"description":"Defines the base type of all keys used along with the\r\n{@link RenderingHints} class to control various\r\nalgorithm choices in the rendering and imaging pipelines.\r\nInstances of this class are immutable and unique which\r\nmeans that tests for matches can be made using the\r\n{@code ==} operator instead of the more expensive\r\n{@code equals()} method.","inherit":[],"name":"java.awt.RenderingHints.Key","type":false},{"description":"This class is used to generate native system input events\r\nfor the purposes of test automation, self-running demos, and\r\nother applications where control of the mouse and keyboard\r\nis needed. The primary purpose of Robot is to facilitate\r\nautomated testing of Java platform implementations.\r\n<p>\r\nUsing the class to generate input events differs from posting\r\nevents to the AWT event queue or AWT components in that the\r\nevents are generated in the platform's native input\r\nqueue. For example, <code>Robot.mouseMove</code> will actually move\r\nthe mouse cursor instead of just generating mouse move events.\r\n<p>\r\nNote that some platforms require special privileges or extensions\r\nto access low-level input control. If the current platform configuration\r\ndoes not allow input control, an <code>AWTException</code> will be thrown\r\nwhen trying to construct Robot objects. For example, X-Window systems\r\nwill throw the exception if the XTEST 2.2 standard extension is not supported\r\n(or not enabled) by the X server.\r\n<p>\r\nApplications that use Robot for purposes other than self-testing should\r\nhandle these error conditions gracefully.","inherit":[],"name":"java.awt.Robot","type":false},{"description":"","inherit":["sun.java2d.DisposerRecord"],"name":"java.awt.Robot.RobotDisposer","type":false},{"description":"The <code>Scrollbar</code> class embodies a scroll bar, a\r\nfamiliar user-interface object. A scroll bar provides a\r\nconvenient means for allowing a user to select from a\r\nrange of values. The following three vertical\r\nscroll bars could be used as slider controls to pick\r\nthe red, green, and blue components of a color:\r\n<p>\r\n<img src=\"doc-files/Scrollbar-1.gif\" alt=\"Image shows 3 vertical sliders, side-by-side.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nEach scroll bar in this example could be created with\r\ncode similar to the following:\r\n\r\n<hr><blockquote><pre>\r\nredSlider=new Scrollbar(Scrollbar.VERTICAL, 0, 1, 0, 255);\r\nadd(redSlider);\r\n</pre></blockquote><hr>\r\n<p>\r\nAlternatively, a scroll bar can represent a range of values. For\r\nexample, if a scroll bar is used for scrolling through text, the\r\nwidth of the \"bubble\" (also called the \"thumb\" or \"scroll box\")\r\ncan be used to represent the amount of text that is visible.\r\nHere is an example of a scroll bar that represents a range:\r\n<p>\r\n<img src=\"doc-files/Scrollbar-2.gif\"\r\nalt=\"Image shows horizontal slider with starting range of 0 and ending range of 300. The slider thumb is labeled 60.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nThe value range represented by the bubble in this example\r\nis the <em>visible amount</em>. The horizontal scroll bar\r\nin this example could be created with code like the following:\r\n\r\n<hr><blockquote><pre>\r\nranger = new Scrollbar(Scrollbar.HORIZONTAL, 0, 60, 0, 300);\r\nadd(ranger);\r\n</pre></blockquote><hr>\r\n<p>\r\nNote that the actual maximum value of the scroll bar is the\r\n<code>maximum</code> minus the <code>visible amount</code>.\r\nIn the previous example, because the <code>maximum</code> is\r\n300 and the <code>visible amount</code> is 60, the actual maximum\r\nvalue is 240.  The range of the scrollbar track is 0 - 300.\r\nThe left side of the bubble indicates the value of the\r\nscroll bar.\r\n<p>\r\nNormally, the user changes the value of the scroll bar by\r\nmaking a gesture with the mouse. For example, the user can\r\ndrag the scroll bar's bubble up and down, or click in the\r\nscroll bar's unit increment or block increment areas. Keyboard\r\ngestures can also be mapped to the scroll bar. By convention,\r\nthe <b>Page&nbsp;Up</b> and <b>Page&nbsp;Down</b>\r\nkeys are equivalent to clicking in the scroll bar's block\r\nincrement and block decrement areas.\r\n<p>\r\nWhen the user changes the value of the scroll bar, the scroll bar\r\nreceives an instance of <code>AdjustmentEvent</code>.\r\nThe scroll bar processes this event, passing it along to\r\nany registered listeners.\r\n<p>\r\nAny object that wishes to be notified of changes to the\r\nscroll bar's value should implement\r\n<code>AdjustmentListener</code>, an interface defined in\r\nthe package <code>java.awt.event</code>.\r\nListeners can be added and removed dynamically by calling\r\nthe methods <code>addAdjustmentListener</code> and\r\n<code>removeAdjustmentListener</code>.\r\n<p>\r\nThe <code>AdjustmentEvent</code> class defines five types\r\nof adjustment event, listed here:\r\n\r\n<ul>\r\n<li><code>AdjustmentEvent.TRACK</code> is sent out when the\r\nuser drags the scroll bar's bubble.\r\n<li><code>AdjustmentEvent.UNIT_INCREMENT</code> is sent out\r\nwhen the user clicks in the left arrow of a horizontal scroll\r\nbar, or the top arrow of a vertical scroll bar, or makes the\r\nequivalent gesture from the keyboard.\r\n<li><code>AdjustmentEvent.UNIT_DECREMENT</code> is sent out\r\nwhen the user clicks in the right arrow of a horizontal scroll\r\nbar, or the bottom arrow of a vertical scroll bar, or makes the\r\nequivalent gesture from the keyboard.\r\n<li><code>AdjustmentEvent.BLOCK_INCREMENT</code> is sent out\r\nwhen the user clicks in the track, to the left of the bubble\r\non a horizontal scroll bar, or above the bubble on a vertical\r\nscroll bar. By convention, the <b>Page&nbsp;Up</b>\r\nkey is equivalent, if the user is using a keyboard that\r\ndefines a <b>Page&nbsp;Up</b> key.\r\n<li><code>AdjustmentEvent.BLOCK_DECREMENT</code> is sent out\r\nwhen the user clicks in the track, to the right of the bubble\r\non a horizontal scroll bar, or below the bubble on a vertical\r\nscroll bar. By convention, the <b>Page&nbsp;Down</b>\r\nkey is equivalent, if the user is using a keyboard that\r\ndefines a <b>Page&nbsp;Down</b> key.\r\n</ul>\r\n<p>\r\nThe JDK&nbsp;1.0 event system is supported for backwards\r\ncompatibility, but its use with newer versions of the platform is\r\ndiscouraged. The five types of adjustment events introduced\r\nwith JDK&nbsp;1.1 correspond to the five event types\r\nthat are associated with scroll bars in previous platform versions.\r\nThe following list gives the adjustment event type,\r\nand the corresponding JDK&nbsp;1.0 event type it replaces.\r\n\r\n<ul>\r\n<li><code>AdjustmentEvent.TRACK</code> replaces\r\n<code>Event.SCROLL_ABSOLUTE</code>\r\n<li><code>AdjustmentEvent.UNIT_INCREMENT</code> replaces\r\n<code>Event.SCROLL_LINE_UP</code>\r\n<li><code>AdjustmentEvent.UNIT_DECREMENT</code> replaces\r\n<code>Event.SCROLL_LINE_DOWN</code>\r\n<li><code>AdjustmentEvent.BLOCK_INCREMENT</code> replaces\r\n<code>Event.SCROLL_PAGE_UP</code>\r\n<li><code>AdjustmentEvent.BLOCK_DECREMENT</code> replaces\r\n<code>Event.SCROLL_PAGE_DOWN</code>\r\n</ul>\r\n<p>\r\n<b>Note</b>: We recommend using a <code>Scrollbar</code>\r\nfor value selection only.  If you want to implement\r\na scrollable component inside a container, we recommend you use\r\na {@link ScrollPane ScrollPane}. If you use a\r\n<code>Scrollbar</code> for this purpose, you are likely to\r\nencounter issues with painting, key handling, sizing and\r\npositioning.","inherit":["java.awt.Component","java.awt.Adjustable","javax.accessibility.Accessible"],"name":"java.awt.Scrollbar","type":false},{"description":"This class implements accessibility support for the\r\n<code>Scrollbar</code> class.  It provides an implementation of\r\nthe Java Accessibility API appropriate to scrollbar\r\nuser-interface elements.","inherit":["java.awt.Component.AccessibleAWTComponent","javax.accessibility.AccessibleValue"],"name":"java.awt.Scrollbar.AccessibleAWTScrollBar","type":false},{"description":"A container class which implements automatic horizontal and/or\r\nvertical scrolling for a single child component.  The display\r\npolicy for the scrollbars can be set to:\r\n<OL>\r\n<LI>as needed: scrollbars created and shown only when needed by scrollpane\r\n<LI>always: scrollbars created and always shown by the scrollpane\r\n<LI>never: scrollbars never created or shown by the scrollpane\r\n</OL>\r\n<P>\r\nThe state of the horizontal and vertical scrollbars is represented\r\nby two <code>ScrollPaneAdjustable</code> objects (one for each\r\ndimension) which implement the <code>Adjustable</code> interface.\r\nThe API provides methods to access those objects such that the\r\nattributes on the Adjustable object (such as unitIncrement, value,\r\netc.) can be manipulated.\r\n<P>\r\nCertain adjustable properties (minimum, maximum, blockIncrement,\r\nand visibleAmount) are set internally by the scrollpane in accordance\r\nwith the geometry of the scrollpane and its child and these should\r\nnot be set by programs using the scrollpane.\r\n<P>\r\nIf the scrollbar display policy is defined as \"never\", then the\r\nscrollpane can still be programmatically scrolled using the\r\nsetScrollPosition() method and the scrollpane will move and clip\r\nthe child's contents appropriately.  This policy is useful if the\r\nprogram needs to create and manage its own adjustable controls.\r\n<P>\r\nThe placement of the scrollbars is controlled by platform-specific\r\nproperties set by the user outside of the program.\r\n<P>\r\nThe initial size of this container is set to 100x100, but can\r\nbe reset using setSize().\r\n<P>\r\nScrolling with the wheel on a wheel-equipped mouse is enabled by default.\r\nThis can be disabled using <code>setWheelScrollingEnabled</code>.\r\nWheel scrolling can be customized by setting the block and\r\nunit increment of the horizontal and vertical Adjustables.\r\nFor information on how mouse wheel events are dispatched, see\r\nthe class description for {@link MouseWheelEvent}.\r\n<P>\r\nInsets are used to define any space used by scrollbars and any\r\nborders created by the scroll pane. getInsets() can be used\r\nto get the current value for the insets.  If the value of\r\nscrollbarsAlwaysVisible is false, then the value of the insets\r\nwill change dynamically depending on whether the scrollbars are\r\ncurrently visible or not.","inherit":["java.awt.Container","javax.accessibility.Accessible"],"name":"java.awt.ScrollPane","type":false},{"description":"","inherit":["java.awt.event.AdjustmentListener","java.io.Serializable"],"name":"java.awt.ScrollPane.PeerFixer","type":false},{"description":"This class implements accessibility support for the\r\n<code>ScrollPane</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to scroll pane user-interface\r\nelements.","inherit":["java.awt.Container.AccessibleAWTContainer"],"name":"java.awt.ScrollPane.AccessibleAWTScrollPane","type":false},{"description":"","inherit":["java.awt.event.AdjustmentListener","java.io.Serializable"],"name":"java.awt.PeerFixer","type":false},{"description":"This class represents the state of a horizontal or vertical\r\nscrollbar of a <code>ScrollPane</code>.  Objects of this class are\r\nreturned by <code>ScrollPane</code> methods.","inherit":["java.awt.Adjustable","java.io.Serializable"],"name":"java.awt.ScrollPaneAdjustable","type":false},{"description":"A helper interface to run the nested event loop.\r\n<p>\r\nObjects that implement this interface are created with the\r\n{@link EventQueue#createSecondaryLoop} method. The interface\r\nprovides two methods, {@link #enter} and {@link #exit},\r\nwhich can be used to start and stop the event loop.\r\n<p>\r\nWhen the {@link #enter} method is called, the current\r\nthread is blocked until the loop is terminated by the\r\n{@link #exit} method. Also, a new event loop is started\r\non the event dispatch thread, which may or may not be\r\nthe current thread. The loop can be terminated on any\r\nthread by calling its {@link #exit} method. After the\r\nloop is terminated, the {@code SecondaryLoop} object can\r\nbe reused to run a new nested event loop.\r\n<p>\r\nA typical use case of applying this interface is AWT\r\nand Swing modal dialogs. When a modal dialog is shown on\r\nthe event dispatch thread, it enters a new secondary loop.\r\nLater, when the dialog is hidden or disposed, it exits\r\nthe loop, and the thread continues its execution.\r\n<p>\r\nThe following example illustrates a simple use case of\r\nsecondary loops:\r\n\r\n<pre>\r\n  SecondaryLoop loop;\r\n\r\n  JButton jButton = new JButton(\"Button\");\r\n  jButton.addActionListener(new ActionListener() {\r\n      {@code @Override}\r\n      public void actionPerformed(ActionEvent e) {\r\n          Toolkit tk = Toolkit.getDefaultToolkit();\r\n          EventQueue eq = tk.getSystemEventQueue();\r\n          loop = eq.createSecondaryLoop();\r\n\r\n          // Spawn a new thread to do the work\r\n          Thread worker = new WorkerThread();\r\n          worker.start();\r\n\r\n          // Enter the loop to block the current event\r\n          // handler, but leave UI responsive\r\n          if (!loop.enter()) {\r\n              // Report an error\r\n          }\r\n      }\r\n  });\r\n\r\n  class WorkerThread extends Thread {\r\n      {@code @Override}\r\n      public void run() {\r\n          // Perform calculations\r\n          doSomethingUseful();\r\n\r\n          // Exit the loop\r\n          loop.exit();\r\n      }\r\n  }\r\n</pre>","inherit":[],"name":"java.awt.SecondaryLoop","type":true},{"description":"A wrapping tag for a nested AWTEvent which indicates that the event was\r\nsent from another AppContext. The destination AppContext should handle the\r\nevent even if it is currently blocked waiting for a SequencedEvent or\r\nanother SentEvent to be handled.","inherit":["java.awt.AWTEvent","java.awt.ActiveEvent"],"name":"java.awt.SentEvent","type":false},{"description":"A mechanism for ensuring that a series of AWTEvents are executed in a\r\nprecise order, even across multiple AppContexts. The nested events will be\r\ndispatched in the order in which their wrapping SequencedEvents were\r\nconstructed. The only exception to this rule is if the peer of the target of\r\nthe nested event was destroyed (with a call to Component.removeNotify)\r\nbefore the wrapping SequencedEvent was able to be dispatched. In this case,\r\nthe nested event is never dispatched.","inherit":["java.awt.AWTEvent","java.awt.ActiveEvent"],"name":"java.awt.SequencedEvent","type":false},{"description":"The <code>Shape</code> interface provides definitions for objects\r\nthat represent some form of geometric shape.  The <code>Shape</code>\r\nis described by a {@link PathIterator} object, which can express the\r\noutline of the <code>Shape</code> as well as a rule for determining\r\nhow the outline divides the 2D plane into interior and exterior\r\npoints.  Each <code>Shape</code> object provides callbacks to get the\r\nbounding box of the geometry, determine whether points or\r\nrectangles lie partly or entirely within the interior\r\nof the <code>Shape</code>, and retrieve a <code>PathIterator</code>\r\nobject that describes the trajectory path of the <code>Shape</code>\r\noutline.\r\n<p>\r\n<a name=\"def_insideness\"><b>Definition of insideness:</b></a>\r\nA point is considered to lie inside a\r\n<code>Shape</code> if and only if:\r\n<ul>\r\n<li> it lies completely\r\ninside the<code>Shape</code> boundary <i>or</i>\r\n<li>\r\nit lies exactly on the <code>Shape</code> boundary <i>and</i> the\r\nspace immediately adjacent to the\r\npoint in the increasing <code>X</code> direction is\r\nentirely inside the boundary <i>or</i>\r\n<li>\r\nit lies exactly on a horizontal boundary segment <b>and</b> the\r\nspace immediately adjacent to the point in the\r\nincreasing <code>Y</code> direction is inside the boundary.\r\n</ul>\r\n<p>The <code>contains</code> and <code>intersects</code> methods\r\nconsider the interior of a <code>Shape</code> to be the area it\r\nencloses as if it were filled.  This means that these methods\r\nconsider\r\nunclosed shapes to be implicitly closed for the purpose of\r\ndetermining if a shape contains or intersects a rectangle or if a\r\nshape contains a point.","inherit":[],"name":"java.awt.Shape","type":true},{"description":"The splash screen can be displayed at application startup, before the\r\nJava Virtual Machine (JVM) starts. The splash screen is displayed as an\r\nundecorated window containing an image. You can use GIF, JPEG, or PNG files\r\nfor the image. Animation is supported for the GIF format, while transparency\r\nis supported both for GIF and PNG.  The window is positioned at the center\r\nof the screen. The position on multi-monitor systems is not specified. It is\r\nplatform and implementation dependent.  The splash screen window is closed\r\nautomatically as soon as the first window is displayed by Swing/AWT (may be\r\nalso closed manually using the Java API, see below).\r\n<P>\r\nIf your application is packaged in a jar file, you can use the\r\n\"SplashScreen-Image\" option in a manifest file to show a splash screen.\r\nPlace the image in the jar archive and specify the path in the option.\r\nThe path should not have a leading slash.\r\n<BR>\r\nFor example, in the <code>manifest.mf</code> file:\r\n<PRE>\r\nManifest-Version: 1.0\r\nMain-Class: Test\r\nSplashScreen-Image: filename.gif\r\n</PRE>\r\n<P>\r\nIf the Java implementation provides the command-line interface and you run\r\nyour application by using the command line or a shortcut, use the Java\r\napplication launcher option to show a splash screen. The Oracle reference\r\nimplementation allows you to specify the splash screen image location with\r\nthe {@code -splash:} option.\r\n<BR>\r\nFor example:\r\n<PRE>\r\njava -splash:filename.gif Test\r\n</PRE>\r\nThe command line interface has higher precedence over the manifest\r\nsetting.\r\n<p>\r\nThe splash screen will be displayed as faithfully as possible to present the\r\nwhole splash screen image given the limitations of the target platform and\r\ndisplay.\r\n<p>\r\nIt is implied that the specified image is presented on the screen \"as is\",\r\ni.e. preserving the exact color values as specified in the image file. Under\r\ncertain circumstances, though, the presented image may differ, e.g. when\r\napplying color dithering to present a 32 bits per pixel (bpp) image on a 16\r\nor 8 bpp screen. The native platform display configuration may also affect\r\nthe colors of the displayed image (e.g.  color profiles, etc.)\r\n<p>\r\nThe {@code SplashScreen} class provides the API for controlling the splash\r\nscreen. This class may be used to close the splash screen, change the splash\r\nscreen image, get the splash screen native window position/size, and paint\r\nin the splash screen. It cannot be used to create the splash screen. You\r\nshould use the options provided by the Java implementation for that.\r\n<p>\r\nThis class cannot be instantiated. Only a single instance of this class\r\ncan exist, and it may be obtained by using the {@link #getSplashScreen()}\r\nstatic method. In case the splash screen has not been created at\r\napplication startup via the command line or manifest file option,\r\nthe <code>getSplashScreen</code> method returns <code>null</code>.","inherit":[],"name":"java.awt.SplashScreen","type":false},{"description":"The <code>Stroke</code> interface allows a\r\n{@link Graphics2D} object to obtain a {@link Shape} that is the\r\ndecorated outline, or stylistic representation of the outline,\r\nof the specified <code>Shape</code>.\r\nStroking a <code>Shape</code> is like tracing its outline with a\r\nmarking pen of the appropriate size and shape.\r\nThe area where the pen would place ink is the area enclosed by the\r\noutline <code>Shape</code>.\r\n<p>\r\nThe methods of the <code>Graphics2D</code> interface that use the\r\noutline <code>Shape</code> returned by a <code>Stroke</code> object\r\ninclude <code>draw</code> and any other methods that are\r\nimplemented in terms of that method, such as\r\n<code>drawLine</code>, <code>drawRect</code>,\r\n<code>drawRoundRect</code>, <code>drawOval</code>,\r\n<code>drawArc</code>, <code>drawPolyline</code>,\r\nand <code>drawPolygon</code>.\r\n<p>\r\nThe objects of the classes implementing <code>Stroke</code>\r\nmust be read-only because <code>Graphics2D</code> does not\r\nclone these objects either when they are set as an attribute\r\nwith the <code>setStroke</code> method or when the\r\n<code>Graphics2D</code> object is itself cloned.\r\nIf a <code>Stroke</code> object is modified after it is set in\r\nthe <code>Graphics2D</code> context then the behavior\r\nof subsequent rendering would be undefined.","inherit":[],"name":"java.awt.Stroke","type":true},{"description":"A class to encapsulate symbolic colors representing the color of\r\nnative GUI objects on a system.  For systems which support the dynamic\r\nupdate of the system colors (when the user changes the colors)\r\nthe actual RGB values of these symbolic colors will also change\r\ndynamically.  In order to compare the \"current\" RGB value of a\r\n<code>SystemColor</code> object with a non-symbolic Color object,\r\n<code>getRGB</code> should be used rather than <code>equals</code>.\r\n<p>\r\nNote that the way in which these system colors are applied to GUI objects\r\nmay vary slightly from platform to platform since GUI objects may be\r\nrendered differently on each platform.\r\n<p>\r\nSystem color values may also be available through the <code>getDesktopProperty</code>\r\nmethod on <code>java.awt.Toolkit</code>.","inherit":["java.awt.Color","java.io.Serializable"],"name":"java.awt.SystemColor","type":false},{"description":"The <code>SystemTray</code> class represents the system tray for a\r\ndesktop.  On Microsoft Windows it is referred to as the \"Taskbar\r\nStatus Area\", on Gnome it is referred to as the \"Notification\r\nArea\", on KDE it is referred to as the \"System Tray\".  The system\r\ntray is shared by all applications running on the desktop.\r\n\r\n<p> On some platforms the system tray may not be present or may not\r\nbe supported, in this case {@link SystemTray#getSystemTray()}\r\nthrows {@link UnsupportedOperationException}.  To detect whether the\r\nsystem tray is supported, use {@link SystemTray#isSupported}.\r\n\r\n<p>The <code>SystemTray</code> may contain one or more {@link\r\nTrayIcon TrayIcons}, which are added to the tray using the {@link\r\n#add} method, and removed when no longer needed, using the\r\n{@link #remove}.  <code>TrayIcon</code> consists of an\r\nimage, a popup menu and a set of associated listeners.  Please see\r\nthe {@link TrayIcon} class for details.\r\n\r\n<p>Every Java application has a single <code>SystemTray</code>\r\ninstance that allows the app to interface with the system tray of\r\nthe desktop while the app is running.  The <code>SystemTray</code>\r\ninstance can be obtained from the {@link #getSystemTray} method.\r\nAn application may not create its own instance of\r\n<code>SystemTray</code>.\r\n\r\n<p>The following code snippet demonstrates how to access\r\nand customize the system tray:\r\n<pre>\r\n<code>\r\n    {@link TrayIcon} trayIcon = null;\r\n    if (SystemTray.isSupported()) {\r\n        // get the SystemTray instance\r\n        SystemTray tray = SystemTray.{@link #getSystemTray};\r\n        // load an image\r\n        {@link java.awt.Image} image = {@link java.awt.Toolkit#getImage(String) Toolkit.getDefaultToolkit().getImage}(...);\r\n        // create a action listener to listen for default action executed on the tray icon\r\n        {@link java.awt.event.ActionListener} listener = new {@link java.awt.event.ActionListener ActionListener}() {\r\n            public void {@link java.awt.event.ActionListener#actionPerformed actionPerformed}({@link java.awt.event.ActionEvent} e) {\r\n                // execute default action of the application\r\n                // ...\r\n            }\r\n        };\r\n        // create a popup menu\r\n        {@link java.awt.PopupMenu} popup = new {@link java.awt.PopupMenu#PopupMenu PopupMenu}();\r\n        // create menu item for the default action\r\n        MenuItem defaultItem = new MenuItem(...);\r\n        defaultItem.addActionListener(listener);\r\n        popup.add(defaultItem);\r\n        /// ... add other items\r\n        // construct a TrayIcon\r\n        trayIcon = new {@link TrayIcon#TrayIcon(java.awt.Image, String, java.awt.PopupMenu) TrayIcon}(image, \"Tray Demo\", popup);\r\n        // set the TrayIcon properties\r\n        trayIcon.{@link TrayIcon#addActionListener(java.awt.event.ActionListener) addActionListener}(listener);\r\n        // ...\r\n        // add the tray image\r\n        try {\r\n            tray.{@link SystemTray#add(TrayIcon) add}(trayIcon);\r\n        } catch (AWTException e) {\r\n            System.err.println(e);\r\n        }\r\n        // ...\r\n    } else {\r\n        // disable tray option in your application or\r\n        // perform other actions\r\n        ...\r\n    }\r\n    // ...\r\n    // some time later\r\n    // the application state has changed - update the image\r\n    if (trayIcon != null) {\r\n        trayIcon.{@link TrayIcon#setImage(java.awt.Image) setImage}(updatedImage);\r\n    }\r\n    // ...\r\n</code>\r\n</pre>","inherit":[],"name":"java.awt.SystemTray","type":false},{"description":"A <code>TextArea</code> object is a multi-line region\r\nthat displays text. It can be set to allow editing or\r\nto be read-only.\r\n<p>\r\nThe following image shows the appearance of a text area:\r\n<p>\r\n<img src=\"doc-files/TextArea-1.gif\" alt=\"A TextArea showing the word 'Hello!'\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nThis text area could be created by the following line of code:\r\n\r\n<hr><blockquote><pre>\r\nnew TextArea(\"Hello\", 5, 40);\r\n</pre></blockquote><hr>\r\n<p>","inherit":["java.awt.TextComponent"],"name":"java.awt.TextArea","type":false},{"description":"This class implements accessibility support for the\r\n<code>TextArea</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to text area user-interface elements.","inherit":["java.awt.TextComponent.AccessibleAWTTextComponent"],"name":"java.awt.TextArea.AccessibleAWTTextArea","type":false},{"description":"The <code>TextComponent</code> class is the superclass of\r\nany component that allows the editing of some text.\r\n<p>\r\nA text component embodies a string of text.  The\r\n<code>TextComponent</code> class defines a set of methods\r\nthat determine whether or not this text is editable. If the\r\ncomponent is editable, it defines another set of methods\r\nthat supports a text insertion caret.\r\n<p>\r\nIn addition, the class defines methods that are used\r\nto maintain a current <em>selection</em> from the text.\r\nThe text selection, a substring of the component's text,\r\nis the target of editing operations. It is also referred\r\nto as the <em>selected text</em>.","inherit":["java.awt.Component","javax.accessibility.Accessible"],"name":"java.awt.TextComponent","type":false},{"description":"This class implements accessibility support for the\r\n<code>TextComponent</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to text component user-interface\r\nelements.","inherit":["java.awt.Component.AccessibleAWTComponent","javax.accessibility.AccessibleText","java.awt.event.TextListener"],"name":"java.awt.TextComponent.AccessibleAWTTextComponent","type":false},{"description":"A <code>TextField</code> object is a text component\r\nthat allows for the editing of a single line of text.\r\n<p>\r\nFor example, the following image depicts a frame with four\r\ntext fields of varying widths. Two of these text fields\r\ndisplay the predefined text <code>\"Hello\"</code>.\r\n<p>\r\n<img src=\"doc-files/TextField-1.gif\" alt=\"The preceding text describes this image.\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nHere is the code that produces these four text fields:\r\n\r\n<hr><blockquote><pre>\r\nTextField tf1, tf2, tf3, tf4;\r\n// a blank text field\r\ntf1 = new TextField();\r\n// blank field of 20 columns\r\ntf2 = new TextField(\"\", 20);\r\n// predefined text displayed\r\ntf3 = new TextField(\"Hello!\");\r\n// predefined text in 30 columns\r\ntf4 = new TextField(\"Hello\", 30);\r\n</pre></blockquote><hr>\r\n<p>\r\nEvery time the user types a key in the text field, one or\r\nmore key events are sent to the text field.  A <code>KeyEvent</code>\r\nmay be one of three types: keyPressed, keyReleased, or keyTyped.\r\nThe properties of a key event indicate which of these types\r\nit is, as well as additional information about the event,\r\nsuch as what modifiers are applied to the key event and the\r\ntime at which the event occurred.\r\n<p>\r\nThe key event is passed to every <code>KeyListener</code>\r\nor <code>KeyAdapter</code> object which registered to receive such\r\nevents using the component's <code>addKeyListener</code> method.\r\n(<code>KeyAdapter</code> objects implement the\r\n<code>KeyListener</code> interface.)\r\n<p>\r\nIt is also possible to fire an <code>ActionEvent</code>.\r\nIf action events are enabled for the text field, they may\r\nbe fired by pressing the <code>Return</code> key.\r\n<p>\r\nThe <code>TextField</code> class's <code>processEvent</code>\r\nmethod examines the action event and passes it along to\r\n<code>processActionEvent</code>. The latter method redirects the\r\nevent to any <code>ActionListener</code> objects that have\r\nregistered to receive action events generated by this\r\ntext field.","inherit":["java.awt.TextComponent"],"name":"java.awt.TextField","type":false},{"description":"This class implements accessibility support for the\r\n<code>TextField</code> class.  It provides an implementation of the\r\nJava Accessibility API appropriate to text field user-interface elements.","inherit":["java.awt.TextComponent.AccessibleAWTTextComponent"],"name":"java.awt.TextField.AccessibleAWTTextField","type":false},{"description":"","inherit":["java.awt.Paint"],"name":"java.awt.TexturePaint","type":false},{"description":"","inherit":["java.awt.PaintContext"],"name":"java.awt.TexturePaintContext","type":false},{"description":"","inherit":["java.awt.TexturePaintContext"],"name":"java.awt.TexturePaintContext.Int","type":false},{"description":"","inherit":["java.awt.TexturePaintContext"],"name":"java.awt.TexturePaintContext.Byte","type":false},{"description":"","inherit":["java.awt.TexturePaintContext"],"name":"java.awt.TexturePaintContext.ByteFilter","type":false},{"description":"","inherit":["java.awt.TexturePaintContext"],"name":"java.awt.TexturePaintContext.Any","type":false},{"description":"This class is the abstract superclass of all actual\r\nimplementations of the Abstract Window Toolkit. Subclasses of\r\nthe <code>Toolkit</code> class are used to bind the various components\r\nto particular native toolkit implementations.\r\n<p>\r\nMany GUI events may be delivered to user\r\nasynchronously, if the opposite is not specified explicitly.\r\nAs well as\r\nmany GUI operations may be performed asynchronously.\r\nThis fact means that if the state of a component is set, and then\r\nthe state immediately queried, the returned value may not yet\r\nreflect the requested change.  This behavior includes, but is not\r\nlimited to:\r\n<ul>\r\n<li>Scrolling to a specified position.\r\n<br>For example, calling <code>ScrollPane.setScrollPosition</code>\r\n    and then <code>getScrollPosition</code> may return an incorrect\r\n    value if the original request has not yet been processed.\r\n\r\n<li>Moving the focus from one component to another.\r\n<br>For more information, see\r\n<a href=\"https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html#transferTiming\">Timing\r\nFocus Transfers</a>, a section in\r\n<a href=\"http://java.sun.com/docs/books/tutorial/uiswing/\">The Swing\r\nTutorial</a>.\r\n\r\n<li>Making a top-level container visible.\r\n<br>Calling <code>setVisible(true)</code> on a <code>Window</code>,\r\n    <code>Frame</code> or <code>Dialog</code> may occur\r\n    asynchronously.\r\n\r\n<li>Setting the size or location of a top-level container.\r\n<br>Calls to <code>setSize</code>, <code>setBounds</code> or\r\n    <code>setLocation</code> on a <code>Window</code>,\r\n    <code>Frame</code> or <code>Dialog</code> are forwarded\r\n    to the underlying window management system and may be\r\n    ignored or modified.  See {@link java.awt.Window} for\r\n    more information.\r\n</ul>\r\n<p>\r\nMost applications should not call any of the methods in this\r\nclass directly. The methods defined by <code>Toolkit</code> are\r\nthe \"glue\" that joins the platform-independent classes in the\r\n<code>java.awt</code> package with their counterparts in\r\n<code>java.awt.peer</code>. Some methods defined by\r\n<code>Toolkit</code> query the native operating system directly.","inherit":[],"name":"java.awt.Toolkit","type":false},{"description":"","inherit":["java.awt.AWTEventMulticaster","java.awt.event.AWTEventListener"],"name":"java.awt.Toolkit.ToolkitEventMulticaster","type":false},{"description":"","inherit":["java.awt.event.AWTEventListener"],"name":"java.awt.Toolkit.SelectiveAWTEventListener","type":false},{"description":"","inherit":["java.beans.PropertyChangeSupport"],"name":"java.awt.Toolkit.DesktopPropertyChangeSupport","type":false},{"description":"The <code>Transparency</code> interface defines the common transparency\r\nmodes for implementing classes.","inherit":[],"name":"java.awt.Transparency","type":true},{"description":"A <code>TrayIcon</code> object represents a tray icon that can be\r\nadded to the {@link SystemTray system tray}. A\r\n<code>TrayIcon</code> can have a tooltip (text), an image, a popup\r\nmenu, and a set of listeners associated with it.\r\n\r\n<p>A <code>TrayIcon</code> can generate various {@link MouseEvent\r\nMouseEvents} and supports adding corresponding listeners to receive\r\nnotification of these events.  <code>TrayIcon</code> processes some\r\nof the events by itself.  For example, by default, when the\r\nright-mouse click is performed on the <code>TrayIcon</code> it\r\ndisplays the specified popup menu.  When the mouse hovers\r\nover the <code>TrayIcon</code> the tooltip is displayed.\r\n\r\n<p><strong>Note:</strong> When the <code>MouseEvent</code> is\r\ndispatched to its registered listeners its <code>component</code>\r\nproperty will be set to <code>null</code>.  (See {@link\r\njava.awt.event.ComponentEvent#getComponent}) The\r\n<code>source</code> property will be set to this\r\n<code>TrayIcon</code>. (See {@link\r\njava.util.EventObject#getSource})\r\n\r\n<p><b>Note:</b> A well-behaved {@link TrayIcon} implementation\r\nwill assign different gestures to showing a popup menu and\r\nselecting a tray icon.\r\n\r\n<p>A <code>TrayIcon</code> can generate an {@link ActionEvent\r\nActionEvent}.  On some platforms, this occurs when the user selects\r\nthe tray icon using either the mouse or keyboard.\r\n\r\n<p>If a SecurityManager is installed, the AWTPermission\r\n{@code accessSystemTray} must be granted in order to create\r\na {@code TrayIcon}. Otherwise the constructor will throw a\r\nSecurityException.\r\n\r\n<p> See the {@link SystemTray} class overview for an example on how\r\nto use the <code>TrayIcon</code> API.","inherit":[],"name":"java.awt.TrayIcon","type":false},{"description":"This utility class is used to suspend execution on a thread\r\nwhile still allowing {@code EventDispatchThread} to dispatch events.\r\nThe API methods of the class are thread-safe.","inherit":["java.awt.SecondaryLoop"],"name":"java.awt.WaitDispatchSupport","type":false},{"description":"A {@code Window} object is a top-level window with no borders and no\r\nmenubar.\r\nThe default layout for a window is {@code BorderLayout}.\r\n<p>\r\nA window must have either a frame, dialog, or another window defined as its\r\nowner when it's constructed.\r\n<p>\r\nIn a multi-screen environment, you can create a {@code Window}\r\non a different screen device by constructing the {@code Window}\r\nwith {@link #Window(Window, GraphicsConfiguration)}.  The\r\n{@code GraphicsConfiguration} object is one of the\r\n{@code GraphicsConfiguration} objects of the target screen device.\r\n<p>\r\nIn a virtual device multi-screen environment in which the desktop\r\narea could span multiple physical screen devices, the bounds of all\r\nconfigurations are relative to the virtual device coordinate system.\r\nThe origin of the virtual-coordinate system is at the upper left-hand\r\ncorner of the primary physical screen.  Depending on the location of\r\nthe primary screen in the virtual device, negative coordinates are\r\npossible, as shown in the following figure.\r\n<p>\r\n<img src=\"doc-files/MultiScreen.gif\"\r\nalt=\"Diagram shows virtual device containing 4 physical screens. Primary physical screen shows coords (0,0), other screen shows (-80,-100).\"\r\nstyle=\"float:center; margin: 7px 10px;\">\r\n<p>\r\nIn such an environment, when calling {@code setLocation},\r\nyou must pass a virtual coordinate to this method.  Similarly,\r\ncalling {@code getLocationOnScreen} on a {@code Window} returns\r\nvirtual device coordinates.  Call the {@code getBounds} method\r\nof a {@code GraphicsConfiguration} to find its origin in the virtual\r\ncoordinate system.\r\n<p>\r\nThe following code sets the location of a {@code Window}\r\nat (10, 10) relative to the origin of the physical screen\r\nof the corresponding {@code GraphicsConfiguration}.  If the\r\nbounds of the {@code GraphicsConfiguration} is not taken\r\ninto account, the {@code Window} location would be set\r\nat (10, 10) relative to the virtual-coordinate system and would appear\r\non the primary physical screen, which might be different from the\r\nphysical screen of the specified {@code GraphicsConfiguration}.\r\n\r\n<pre>\r\n     Window w = new Window(Window owner, GraphicsConfiguration gc);\r\n     Rectangle bounds = gc.getBounds();\r\n     w.setLocation(10 + bounds.x, 10 + bounds.y);\r\n</pre>\r\n\r\n<p>\r\nNote: the location and size of top-level windows (including\r\n{@code Window}s, {@code Frame}s, and {@code Dialog}s)\r\nare under the control of the desktop's window management system.\r\nCalls to {@code setLocation}, {@code setSize}, and\r\n{@code setBounds} are requests (not directives) which are\r\nforwarded to the window management system.  Every effort will be\r\nmade to honor such requests.  However, in some cases the window\r\nmanagement system may ignore such requests, or modify the requested\r\ngeometry in order to place and size the {@code Window} in a way\r\nthat more closely matches the desktop settings.\r\n<p>\r\nDue to the asynchronous nature of native event handling, the results\r\nreturned by {@code getBounds}, {@code getLocation},\r\n{@code getLocationOnScreen}, and {@code getSize} might not\r\nreflect the actual geometry of the Window on screen until the last\r\nrequest has been processed.  During the processing of subsequent\r\nrequests these values might change accordingly while the window\r\nmanagement system fulfills the requests.\r\n<p>\r\nAn application may set the size and location of an invisible\r\n{@code Window} arbitrarily, but the window management system may\r\nsubsequently change its size and/or location when the\r\n{@code Window} is made visible. One or more {@code ComponentEvent}s\r\nwill be generated to indicate the new geometry.\r\n<p>\r\nWindows are capable of generating the following WindowEvents:\r\nWindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.","inherit":["java.awt.Container","javax.accessibility.Accessible"],"name":"java.awt.Window","type":false},{"description":"","inherit":["sun.java2d.DisposerRecord"],"name":"java.awt.Window.WindowDisposerRecord","type":false},{"description":"","inherit":["java.lang.Runnable"],"name":"","type":false},{"description":"This class implements accessibility support for the\r\n{@code Window} class.  It provides an implementation of the\r\nJava Accessibility API appropriate to window user-interface elements.","inherit":["java.awt.Container.AccessibleAWTContainer"],"name":"java.awt.Window.AccessibleAWTWindow","type":false},{"description":"This class is no longer used, but is maintained for Serialization\r\nbackward-compatibility.","inherit":["java.io.Serializable"],"name":"java.awt.FocusManager","type":false},{"description":"","inherit":[],"name":"java.beans.AppletInitializer","type":true},{"description":"","inherit":["java.beans.beancontext.BeanContextChild","java.util.Collection","java.beans.DesignMode","java.beans.Visibility"],"name":"java.beans.beancontext.BeanContext","type":true},{"description":"","inherit":[],"name":"java.beans.beancontext.BeanContextChild","type":true},{"description":"","inherit":[],"name":"java.beans.beancontext.BeanContextChildComponentProxy","type":true},{"description":"","inherit":["java.beans.beancontext.BeanContextChild","java.beans.beancontext.BeanContextServicesListener","java.io.Serializable"],"name":"java.beans.beancontext.BeanContextChildSupport","type":false},{"description":"","inherit":[],"name":"java.beans.beancontext.BeanContextContainerProxy","type":true},{"description":"","inherit":["java.util.EventObject"],"name":"java.beans.beancontext.BeanContextEvent","type":false},{"description":"A <code>BeanContextMembershipEvent</code> encapsulates\r\nthe list of children added to, or removed from,\r\nthe membership of a particular <code>BeanContext</code>.\r\nAn instance of this event is fired whenever a successful\r\nadd(), remove(), retainAll(), removeAll(), or clear() is\r\ninvoked on a given <code>BeanContext</code> instance.\r\nObjects interested in receiving events of this type must\r\nimplement the <code>BeanContextMembershipListener</code>\r\ninterface, and must register their intent via the\r\n<code>BeanContext</code>'s\r\n<code>addBeanContextMembershipListener(BeanContextMembershipListener bcml)\r\n</code> method.","inherit":["java.beans.beancontext.BeanContextEvent"],"name":"java.beans.beancontext.BeanContextMembershipEvent","type":false},{"description":"","inherit":["java.util.EventListener"],"name":"java.beans.beancontext.BeanContextMembershipListener","type":true},{"description":"","inherit":[],"name":"java.beans.beancontext.BeanContextProxy","type":true},{"description":"","inherit":["java.beans.beancontext.BeanContextEvent"],"name":"java.beans.beancontext.BeanContextServiceAvailableEvent","type":false},{"description":"","inherit":[],"name":"java.beans.beancontext.BeanContextServiceProvider","type":true},{"description":"","inherit":["java.beans.BeanInfo"],"name":"java.beans.beancontext.BeanContextServiceProviderBeanInfo","type":true},{"description":"<p>\r\nThis event type is used by the\r\n<code>BeanContextServiceRevokedListener</code> in order to\r\nidentify the service being revoked.\r\n</p>","inherit":["java.beans.beancontext.BeanContextEvent"],"name":"java.beans.beancontext.BeanContextServiceRevokedEvent","type":false},{"description":" The listener interface for receiving\r\n<code>BeanContextServiceRevokedEvent</code> objects. A class that is\r\ninterested in processing a <code>BeanContextServiceRevokedEvent</code>\r\nimplements this interface.","inherit":["java.util.EventListener"],"name":"java.beans.beancontext.BeanContextServiceRevokedListener","type":true},{"description":"<p>\r\nThe BeanContextServices interface provides a mechanism for a BeanContext\r\nto expose generic \"services\" to the BeanContextChild objects within.\r\n</p>","inherit":["java.beans.beancontext.BeanContext","java.beans.beancontext.BeanContextServicesListener"],"name":"java.beans.beancontext.BeanContextServices","type":true},{"description":"The listener interface for receiving\r\n<code>BeanContextServiceAvailableEvent</code> objects.\r\nA class that is interested in processing a\r\n<code>BeanContextServiceAvailableEvent</code> implements this interface.","inherit":["java.beans.beancontext.BeanContextServiceRevokedListener"],"name":"java.beans.beancontext.BeanContextServicesListener","type":true},{"description":"","inherit":["java.beans.beancontext.BeanContextSupport","java.beans.beancontext.BeanContextServices"],"name":"java.beans.beancontext.BeanContextServicesSupport","type":false},{"description":"","inherit":["java.beans.beancontext.BeanContextSupport.BCSChild"],"name":"java.beans.beancontext.BeanContextServicesSupport.BCSSChild","type":false},{"description":"","inherit":[],"name":"java.beans.beancontext.BeanContextServicesSupport.BCSSChild.BCSSCServiceClassRef","type":false},{"description":"","inherit":[],"name":"java.beans.beancontext.BeanContextServicesSupport.BCSSChild.BCSSCServiceRef","type":false},{"description":"","inherit":["java.io.Serializable"],"name":"java.beans.beancontext.BeanContextServicesSupport.BCSSServiceProvider","type":false},{"description":"","inherit":["java.beans.beancontext.BeanContextServiceProvider","java.beans.beancontext.BeanContextServiceRevokedListener"],"name":"java.beans.beancontext.BeanContextServicesSupport.BCSSProxyServiceProvider","type":false},{"description":"This helper class provides a utility implementation of the\r\njava.beans.beancontext.BeanContext interface.\r\n<p>\r\nSince this class directly implements the BeanContext interface, the class\r\ncan, and is intended to be used either by subclassing this implementation,\r\nor via ad-hoc delegation of an instance of this class from another.\r\n</p>","inherit":["java.beans.beancontext.BeanContextChildSupport","java.beans.beancontext.BeanContext","java.io.Serializable","java.beans.PropertyChangeListener","java.beans.VetoableChangeListener"],"name":"java.beans.beancontext.BeanContextSupport","type":false},{"description":"","inherit":["java.util.Iterator"],"name":"java.beans.beancontext.BeanContextSupport.BCSIterator","type":false},{"description":"","inherit":["java.io.Serializable"],"name":"java.beans.beancontext.BeanContextSupport.BCSChild","type":false},{"description":"","inherit":["java.beans.FeatureDescriptor"],"name":"java.beans.BeanDescriptor","type":false},{"description":"Use the {@code BeanInfo} interface\r\nto create a {@code BeanInfo} class\r\nand provide explicit information about the methods,\r\nproperties, events, and other features of your beans.\r\n<p>\r\nWhen developing your bean, you can implement\r\nthe bean features required for your application task\r\nomitting the rest of the {@code BeanInfo} features.\r\nThey will be obtained through the automatic analysis\r\nby using the low-level reflection of the bean methods\r\nand applying standard design patterns.\r\nYou have an opportunity to provide additional bean information\r\nthrough various descriptor classes.\r\n<p>\r\nSee the {@link SimpleBeanInfo} class that is\r\na convenient basic class for {@code BeanInfo} classes.\r\nYou can override the methods and properties of\r\nthe {@code SimpleBeanInfo} class to define specific information.\r\n<p>\r\nSee also the {@link Introspector} class to learn more about bean behavior.","inherit":[],"name":"java.beans.BeanInfo","type":true},{"description":"","inherit":[],"name":"java.beans.Beans","type":false},{"description":"","inherit":["java.io.ObjectInputStream"],"name":"java.beans.ObjectInputStreamWithLoader","type":false},{"description":"","inherit":["java.applet.AppletContext"],"name":"java.beans.BeansAppletContext","type":false},{"description":"Package private support class.  This provides an AppletStub\r\nfor beans which are applets.","inherit":["java.applet.AppletStub"],"name":"java.beans.BeansAppletStub","type":false},{"description":"This is an abstract class that provides base functionality\r\nfor the {@link PropertyChangeSupport PropertyChangeSupport} class\r\nand the {@link VetoableChangeSupport VetoableChangeSupport} class.","inherit":[],"name":"java.beans.ChangeListenerMap","type":false},{"description":"","inherit":[],"name":"java.beans.Customizer","type":true},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.DefaultPersistenceDelegate","type":false},{"description":"","inherit":[],"name":"java.beans.DesignMode","type":true},{"description":"","inherit":[],"name":"java.beans.Encoder","type":false},{"description":"The <code>EventHandler</code> class provides\r\nsupport for dynamically generating event listeners whose methods\r\nexecute a simple statement involving an incoming event object\r\nand a target object.\r\n<p>\r\nThe <code>EventHandler</code> class is intended to be used by interactive tools, such as\r\napplication builders, that allow developers to make connections between\r\nbeans. Typically connections are made from a user interface bean\r\n(the event <em>source</em>)\r\nto an application logic bean (the <em>target</em>). The most effective\r\nconnections of this kind isolate the application logic from the user\r\ninterface.  For example, the <code>EventHandler</code> for a\r\nconnection from a <code>JCheckBox</code> to a method\r\nthat accepts a boolean value can deal with extracting the state\r\nof the check box and passing it directly to the method so that\r\nthe method is isolated from the user interface layer.\r\n<p>\r\nInner classes are another, more general way to handle events from\r\nuser interfaces.  The <code>EventHandler</code> class\r\nhandles only a subset of what is possible using inner\r\nclasses. However, <code>EventHandler</code> works better\r\nwith the long-term persistence scheme than inner classes.\r\nAlso, using <code>EventHandler</code> in large applications in\r\nwhich the same interface is implemented many times can\r\nreduce the disk and memory footprint of the application.\r\n<p>\r\nThe reason that listeners created with <code>EventHandler</code>\r\nhave such a small\r\nfootprint is that the <code>Proxy</code> class, on which\r\nthe <code>EventHandler</code> relies, shares implementations\r\nof identical\r\ninterfaces. For example, if you use\r\nthe <code>EventHandler</code> <code>create</code> methods to make\r\nall the <code>ActionListener</code>s in an application,\r\nall the action listeners will be instances of a single class\r\n(one created by the <code>Proxy</code> class).\r\nIn general, listeners based on\r\nthe <code>Proxy</code> class require one listener class\r\nto be created per <em>listener type</em> (interface),\r\nwhereas the inner class\r\napproach requires one class to be created per <em>listener</em>\r\n(object that implements the interface).\r\n\r\n<p>\r\nYou don't generally deal directly with <code>EventHandler</code>\r\ninstances.\r\nInstead, you use one of the <code>EventHandler</code>\r\n<code>create</code> methods to create\r\nan object that implements a given listener interface.\r\nThis listener object uses an <code>EventHandler</code> object\r\nbehind the scenes to encapsulate information about the\r\nevent, the object to be sent a message when the event occurs,\r\nthe message (method) to be sent, and any argument\r\nto the method.\r\nThe following section gives examples of how to create listener\r\nobjects using the <code>create</code> methods.\r\n\r\n<h2>Examples of Using EventHandler</h2>\r\n\r\nThe simplest use of <code>EventHandler</code> is to install\r\na listener that calls a method on the target object with no arguments.\r\nIn the following example we create an <code>ActionListener</code>\r\nthat invokes the <code>toFront</code> method on an instance\r\nof <code>javax.swing.JFrame</code>.\r\n\r\n<blockquote>\r\n<pre>\r\nmyButton.addActionListener(\r\n   (ActionListener)EventHandler.create(ActionListener.class, frame, \"toFront\"));\r\n</pre>\r\n</blockquote>\r\n\r\nWhen <code>myButton</code> is pressed, the statement\r\n<code>frame.toFront()</code> will be executed.  One could get\r\nthe same effect, with some additional compile-time type safety,\r\nby defining a new implementation of the <code>ActionListener</code>\r\ninterface and adding an instance of it to the button:\r\n\r\n<blockquote>\r\n<pre>\r\n//Equivalent code using an inner class instead of EventHandler.\r\nmyButton.addActionListener(new ActionListener() {\r\n   public void actionPerformed(ActionEvent e) {\r\n       frame.toFront();\r\n   }\r\n});\r\n</pre>\r\n</blockquote>\r\n\r\nThe next simplest use of <code>EventHandler</code> is\r\nto extract a property value from the first argument\r\nof the method in the listener interface (typically an event object)\r\nand use it to set the value of a property in the target object.\r\nIn the following example we create an <code>ActionListener</code> that\r\nsets the <code>nextFocusableComponent</code> property of the target\r\n(myButton) object to the value of the \"source\" property of the event.\r\n\r\n<blockquote>\r\n<pre>\r\nEventHandler.create(ActionListener.class, myButton, \"nextFocusableComponent\", \"source\")\r\n</pre>\r\n</blockquote>\r\n\r\nThis would correspond to the following inner class implementation:\r\n\r\n<blockquote>\r\n<pre>\r\n//Equivalent code using an inner class instead of EventHandler.\r\nnew ActionListener() {\r\n   public void actionPerformed(ActionEvent e) {\r\n       myButton.setNextFocusableComponent((Component)e.getSource());\r\n   }\r\n}\r\n</pre>\r\n</blockquote>\r\n\r\nIt's also possible to create an <code>EventHandler</code> that\r\njust passes the incoming event object to the target's action.\r\nIf the fourth <code>EventHandler.create</code> argument is\r\nan empty string, then the event is just passed along:\r\n\r\n<blockquote>\r\n<pre>\r\nEventHandler.create(ActionListener.class, target, \"doActionEvent\", \"\")\r\n</pre>\r\n</blockquote>\r\n\r\nThis would correspond to the following inner class implementation:\r\n\r\n<blockquote>\r\n<pre>\r\n//Equivalent code using an inner class instead of EventHandler.\r\nnew ActionListener() {\r\n   public void actionPerformed(ActionEvent e) {\r\n       target.doActionEvent(e);\r\n   }\r\n}\r\n</pre>\r\n</blockquote>\r\n\r\nProbably the most common use of <code>EventHandler</code>\r\nis to extract a property value from the\r\n<em>source</em> of the event object and set this value as\r\nthe value of a property of the target object.\r\nIn the following example we create an <code>ActionListener</code> that\r\nsets the \"label\" property of the target\r\nobject to the value of the \"text\" property of the\r\nsource (the value of the \"source\" property) of the event.\r\n\r\n<blockquote>\r\n<pre>\r\nEventHandler.create(ActionListener.class, myButton, \"label\", \"source.text\")\r\n</pre>\r\n</blockquote>\r\n\r\nThis would correspond to the following inner class implementation:\r\n\r\n<blockquote>\r\n<pre>\r\n//Equivalent code using an inner class instead of EventHandler.\r\nnew ActionListener {\r\n   public void actionPerformed(ActionEvent e) {\r\n       myButton.setLabel(((JTextField)e.getSource()).getText());\r\n   }\r\n}\r\n</pre>\r\n</blockquote>\r\n\r\nThe event property may be \"qualified\" with an arbitrary number\r\nof property prefixes delimited with the \".\" character. The \"qualifying\"\r\nnames that appear before the \".\" characters are taken as the names of\r\nproperties that should be applied, left-most first, to\r\nthe event object.\r\n<p>\r\nFor example, the following action listener\r\n\r\n<blockquote>\r\n<pre>\r\nEventHandler.create(ActionListener.class, target, \"a\", \"b.c.d\")\r\n</pre>\r\n</blockquote>\r\n\r\nmight be written as the following inner class\r\n(assuming all the properties had canonical getter methods and\r\nreturned the appropriate types):\r\n\r\n<blockquote>\r\n<pre>\r\n//Equivalent code using an inner class instead of EventHandler.\r\nnew ActionListener {\r\n   public void actionPerformed(ActionEvent e) {\r\n       target.setA(e.getB().getC().isD());\r\n   }\r\n}\r\n</pre>\r\n</blockquote>\r\nThe target property may also be \"qualified\" with an arbitrary number\r\nof property prefixs delimited with the \".\" character.  For example, the\r\nfollowing action listener:\r\n<pre>\r\n  EventHandler.create(ActionListener.class, target, \"a.b\", \"c.d\")\r\n</pre>\r\nmight be written as the following inner class\r\n(assuming all the properties had canonical getter methods and\r\nreturned the appropriate types):\r\n<pre>\r\n  //Equivalent code using an inner class instead of EventHandler.\r\n  new ActionListener {\r\n    public void actionPerformed(ActionEvent e) {\r\n        target.getA().setB(e.getC().isD());\r\n   }\r\n}\r\n</pre>\r\n<p>\r\nAs <code>EventHandler</code> ultimately relies on reflection to invoke\r\na method we recommend against targeting an overloaded method.  For example,\r\nif the target is an instance of the class <code>MyTarget</code> which is\r\ndefined as:\r\n<pre>\r\n  public class MyTarget {\r\n    public void doIt(String);\r\n    public void doIt(Object);\r\n  }\r\n</pre>\r\nThen the method <code>doIt</code> is overloaded.  EventHandler will invoke\r\nthe method that is appropriate based on the source.  If the source is\r\nnull, then either method is appropriate and the one that is invoked is\r\nundefined.  For that reason we recommend against targeting overloaded\r\nmethods.","inherit":["java.lang.reflect.InvocationHandler"],"name":"java.beans.EventHandler","type":false},{"description":"An EventSetDescriptor describes a group of events that a given Java\r\nbean fires.\r\n<P>\r\nThe given group of events are all delivered as method calls on a single\r\nevent listener interface, and an event listener object can be registered\r\nvia a call on a registration method supplied by the event source.","inherit":["java.beans.FeatureDescriptor"],"name":"java.beans.EventSetDescriptor","type":false},{"description":"An ExceptionListener is notified of internal exceptions.","inherit":[],"name":"java.beans.ExceptionListener","type":true},{"description":"An <code>Expression</code> object represents a primitive expression\r\nin which a single method is applied to a target and a set of\r\narguments to return a result - as in <code>\"a.getFoo()\"</code>.\r\n<p>\r\nIn addition to the properties of the super class, the\r\n<code>Expression</code> object provides a <em>value</em> which\r\nis the object returned when this expression is evaluated.\r\nThe return value is typically not provided by the caller and\r\nis instead computed by dynamically finding the method and invoking\r\nit when the first call to <code>getValue</code> is made.","inherit":["java.beans.Statement"],"name":"java.beans.Expression","type":false},{"description":"","inherit":[],"name":"java.beans.FeatureDescriptor","type":false},{"description":"An \"IndexedPropertyChange\" event gets delivered whenever a component that\r\nconforms to the JavaBeans&trade; specification (a \"bean\") changes a bound\r\nindexed property. This class is an extension of <code>PropertyChangeEvent</code>\r\nbut contains the index of the property that has changed.\r\n<P>\r\nNull values may be provided for the old and the new values if their\r\ntrue values are not known.\r\n<P>\r\nAn event source may send a null object as the name to indicate that an\r\narbitrary set of if its properties have changed.  In this case the\r\nold and new values should also be null.","inherit":["java.beans.PropertyChangeEvent"],"name":"java.beans.IndexedPropertyChangeEvent","type":false},{"description":"","inherit":["java.beans.PropertyDescriptor"],"name":"java.beans.IndexedPropertyDescriptor","type":false},{"description":"","inherit":["java.lang.Exception"],"name":"java.beans.IntrospectionException","type":false},{"description":"","inherit":[],"name":"java.beans.Introspector","type":false},{"description":"","inherit":["java.beans.SimpleBeanInfo"],"name":"java.beans.GenericBeanInfo","type":false},{"description":"","inherit":[],"name":"java.beans.MetaData","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.NullPersistenceDelegate","type":false},{"description":"The persistence delegate for <CODE>enum</CODE> classes.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.EnumPersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.PrimitivePersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.ArrayPersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.ProxyPersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_lang_String_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_lang_Class_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_lang_reflect_Field_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_lang_reflect_Method_PersistenceDelegate","type":false},{"description":"The persistence delegate for <CODE>java.util.Date</CODE> classes.\r\nDo not extend DefaultPersistenceDelegate to improve performance and\r\nto avoid problems with <CODE>java.sql.Date</CODE>,\r\n<CODE>java.sql.Time</CODE> and <CODE>java.sql.Timestamp</CODE>.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_util_Date_PersistenceDelegate","type":false},{"description":"The persistence delegate for <CODE>java.sql.Timestamp</CODE> classes.\r\nIt supports nanoseconds.","inherit":["java.beans.MetaData.java_util_Date_PersistenceDelegate"],"name":"java.beans.MetaData.java_sql_Timestamp_PersistenceDelegate","type":false},{"description":"The base class for persistence delegates for inner classes\r\nthat can be created using {@link Collections}.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_util_Collections","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.EmptyList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.EmptySet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.EmptyMap_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SingletonList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SingletonSet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SingletonMap_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.UnmodifiableCollection_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.UnmodifiableList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.UnmodifiableRandomAccessList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.UnmodifiableSet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.UnmodifiableSortedSet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.UnmodifiableMap_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.UnmodifiableSortedMap_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SynchronizedCollection_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SynchronizedList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SynchronizedRandomAccessList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SynchronizedSet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SynchronizedSortedSet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SynchronizedMap_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.SynchronizedSortedMap_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.CheckedCollection_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.CheckedList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.CheckedRandomAccessList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.CheckedSet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.CheckedSortedSet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.CheckedMap_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collections"],"name":"java.beans.MetaData.java_util_Collections.CheckedSortedMap_PersistenceDelegate","type":false},{"description":"The persistence delegate for <CODE>java.util.EnumMap</CODE> classes.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_util_EnumMap_PersistenceDelegate","type":false},{"description":"The persistence delegate for <CODE>java.util.EnumSet</CODE> classes.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_util_EnumSet_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_util_Collection_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_util_List_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_util_Map_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collection_PersistenceDelegate"],"name":"java.beans.MetaData.java_util_AbstractCollection_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_List_PersistenceDelegate"],"name":"java.beans.MetaData.java_util_AbstractList_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Map_PersistenceDelegate"],"name":"java.beans.MetaData.java_util_AbstractMap_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Map_PersistenceDelegate"],"name":"java.beans.MetaData.java_util_Hashtable_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.java_util_Collection_PersistenceDelegate"],"name":"java.beans.MetaData.java_beans_beancontext_BeanContextSupport_PersistenceDelegate","type":false},{"description":"The persistence delegate for {@link Insets}.\r\nIt is impossible to use {@link DefaultPersistenceDelegate}\r\nbecause this class does not have any properties.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_awt_Insets_PersistenceDelegate","type":false},{"description":"The persistence delegate for {@link Font}.\r\nIt is impossible to use {@link DefaultPersistenceDelegate}\r\nbecause size of the font can be float value.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_awt_Font_PersistenceDelegate","type":false},{"description":"The persistence delegate for {@link AWTKeyStroke}.\r\nIt is impossible to use {@link DefaultPersistenceDelegate}\r\nbecause this class have no public constructor.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_awt_AWTKeyStroke_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.StaticFieldsPersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.StaticFieldsPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_SystemColor_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.MetaData.StaticFieldsPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_font_TextAttribute_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.java_awt_MenuShortcut_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_Component_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_Container_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_Choice_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_Menu_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_MenuBar_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_List_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_BorderLayout_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_CardLayout_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.java_awt_GridBagLayout_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_JFrame_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_DefaultListModel_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_DefaultComboBoxModel_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_tree_DefaultMutableTreeNode_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_ToolTipManager_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_JTabbedPane_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_Box_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.DefaultPersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_JMenu_PersistenceDelegate","type":false},{"description":"The persistence delegate for {@link MatteBorder}.\r\nIt is impossible to use {@link DefaultPersistenceDelegate}\r\nbecause this class does not have writable properties.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.javax_swing_border_MatteBorder_PersistenceDelegate","type":false},{"description":"The persistence delegate for {@link PrintColorUIResource}.\r\nIt is impossible to use {@link DefaultPersistenceDelegate}\r\nbecause this class has special rule for serialization:\r\nit should be converted to {@link ColorUIResource}.","inherit":["java.beans.PersistenceDelegate"],"name":"java.beans.MetaData.sun_swing_PrintColorUIResource_PersistenceDelegate","type":false},{"description":"","inherit":["java.beans.FeatureDescriptor"],"name":"java.beans.MethodDescriptor","type":false},{"description":"","inherit":[],"name":"java.beans.MethodRef","type":false},{"description":"A utility class which generates unique names for object instances.\r\nThe name will be a concatenation of the unqualified class name\r\nand an instance number.\r\n<p>\r\nFor example, if the first object instance javax.swing.JButton\r\nis passed into <code>instanceName</code> then the returned\r\nstring identifier will be &quot;JButton0&quot;.","inherit":[],"name":"java.beans.NameGenerator","type":false},{"description":"","inherit":["java.beans.FeatureDescriptor"],"name":"java.beans.ParameterDescriptor","type":false},{"description":"","inherit":[],"name":"java.beans.PersistenceDelegate","type":false},{"description":"A \"PropertyChange\" event gets delivered whenever a bean changes a \"bound\"\r\nor \"constrained\" property.  A PropertyChangeEvent object is sent as an\r\nargument to the PropertyChangeListener and VetoableChangeListener methods.\r\n<P>\r\nNormally PropertyChangeEvents are accompanied by the name and the old\r\nand new value of the changed property.  If the new value is a primitive\r\ntype (such as int or boolean) it must be wrapped as the\r\ncorresponding java.lang.* Object type (such as Integer or Boolean).\r\n<P>\r\nNull values may be provided for the old and the new values if their\r\ntrue values are not known.\r\n<P>\r\nAn event source may send a null object as the name to indicate that an\r\narbitrary set of if its properties have changed.  In this case the\r\nold and new values should also be null.","inherit":["java.util.EventObject"],"name":"java.beans.PropertyChangeEvent","type":false},{"description":"","inherit":["java.util.EventListener"],"name":"java.beans.PropertyChangeListener","type":true},{"description":"A class which extends the {@code EventListenerProxy}\r\nspecifically for adding a {@code PropertyChangeListener}\r\nwith a \"bound\" property.\r\nInstances of this class can be added\r\nas {@code PropertyChangeListener}s to a bean\r\nwhich supports firing property change events.\r\n<p>\r\nIf the object has a {@code getPropertyChangeListeners} method\r\nthen the array returned could be a mixture of {@code PropertyChangeListener}\r\nand {@code PropertyChangeListenerProxy} objects.","inherit":["java.util.EventListenerProxy","java.beans.PropertyChangeListener"],"name":"java.beans.PropertyChangeListenerProxy","type":false},{"description":"This is a utility class that can be used by beans that support bound\r\nproperties.  It manages a list of listeners and dispatches\r\n{@link PropertyChangeEvent}s to them.  You can use an instance of this class\r\nas a member field of your bean and delegate these types of work to it.\r\nThe {@link PropertyChangeListener} can be registered for all properties\r\nor for a property specified by name.\r\n<p>\r\nHere is an example of {@code PropertyChangeSupport} usage that follows\r\nthe rules and recommendations laid out in the JavaBeans&trade; specification:\r\n<pre>\r\npublic class MyBean {\r\n    private final PropertyChangeSupport pcs = new PropertyChangeSupport(this);\r\n\r\n    public void addPropertyChangeListener(PropertyChangeListener listener) {\r\n        this.pcs.addPropertyChangeListener(listener);\r\n    }\r\n\r\n    public void removePropertyChangeListener(PropertyChangeListener listener) {\r\n        this.pcs.removePropertyChangeListener(listener);\r\n    }\r\n\r\n    private String value;\r\n\r\n    public String getValue() {\r\n        return this.value;\r\n    }\r\n\r\n    public void setValue(String newValue) {\r\n        String oldValue = this.value;\r\n        this.value = newValue;\r\n        this.pcs.firePropertyChange(\"value\", oldValue, newValue);\r\n    }\r\n\r\n    [...]\r\n}\r\n</pre>\r\n<p>\r\nA {@code PropertyChangeSupport} instance is thread-safe.\r\n<p>\r\nThis class is serializable.  When it is serialized it will save\r\n(and restore) any listeners that are themselves serializable.  Any\r\nnon-serializable listeners will be skipped during serialization.","inherit":["java.io.Serializable"],"name":"java.beans.PropertyChangeSupport","type":false},{"description":"This is a {@link ChangeListenerMap ChangeListenerMap} implementation\r\nthat works with {@link PropertyChangeListener PropertyChangeListener} objects.","inherit":["java.beans.ChangeListenerMap"],"name":"java.beans.PropertyChangeSupport.PropertyChangeListenerMap","type":false},{"description":"A PropertyDescriptor describes one property that a Java Bean\r\nexports via a pair of accessor methods.","inherit":["java.beans.FeatureDescriptor"],"name":"java.beans.PropertyDescriptor","type":false},{"description":"","inherit":[],"name":"java.beans.PropertyEditor","type":true},{"description":"","inherit":[],"name":"java.beans.PropertyEditorManager","type":false},{"description":"","inherit":["java.beans.PropertyEditor"],"name":"java.beans.PropertyEditorSupport","type":false},{"description":"","inherit":["java.lang.Exception"],"name":"java.beans.PropertyVetoException","type":false},{"description":"","inherit":["java.beans.BeanInfo"],"name":"java.beans.SimpleBeanInfo","type":false},{"description":"A <code>Statement</code> object represents a primitive statement\r\nin which a single method is applied to a target and\r\na set of arguments - as in <code>\"a.setFoo(b)\"</code>.\r\nNote that where this example uses names\r\nto denote the target and its argument, a statement\r\nobject does not require a name space and is constructed with\r\nthe values themselves.\r\nThe statement object associates the named method\r\nwith its environment as a simple set of values:\r\nthe target and an array of argument values.","inherit":[],"name":"java.beans.Statement","type":false},{"description":"The {@code ThreadGroupContext} is an application-dependent\r\ncontext referenced by the specific {@link ThreadGroup}.\r\nThis is a replacement for the {@link sun.awt.AppContext}.","inherit":[],"name":"java.beans.ThreadGroupContext","type":false},{"description":"A VetoableChange event gets fired whenever a bean changes a \"constrained\"\r\nproperty.  You can register a VetoableChangeListener with a source bean\r\nso as to be notified of any constrained property updates.","inherit":["java.util.EventListener"],"name":"java.beans.VetoableChangeListener","type":true},{"description":"A class which extends the {@code EventListenerProxy}\r\nspecifically for adding a {@code VetoableChangeListener}\r\nwith a \"constrained\" property.\r\nInstances of this class can be added\r\nas {@code VetoableChangeListener}s to a bean\r\nwhich supports firing vetoable change events.\r\n<p>\r\nIf the object has a {@code getVetoableChangeListeners} method\r\nthen the array returned could be a mixture of {@code VetoableChangeListener}\r\nand {@code VetoableChangeListenerProxy} objects.","inherit":["java.util.EventListenerProxy","java.beans.VetoableChangeListener"],"name":"java.beans.VetoableChangeListenerProxy","type":false},{"description":"This is a utility class that can be used by beans that support constrained\r\nproperties.  It manages a list of listeners and dispatches\r\n{@link PropertyChangeEvent}s to them.  You can use an instance of this class\r\nas a member field of your bean and delegate these types of work to it.\r\nThe {@link VetoableChangeListener} can be registered for all properties\r\nor for a property specified by name.\r\n<p>\r\nHere is an example of {@code VetoableChangeSupport} usage that follows\r\nthe rules and recommendations laid out in the JavaBeans&trade; specification:\r\n<pre>{@code\r\npublic class MyBean {\r\n    private final VetoableChangeSupport vcs = new VetoableChangeSupport(this);\r\n\r\n    public void addVetoableChangeListener(VetoableChangeListener listener) {\r\n        this.vcs.addVetoableChangeListener(listener);\r\n    }\r\n\r\n    public void removeVetoableChangeListener(VetoableChangeListener listener) {\r\n        this.vcs.removeVetoableChangeListener(listener);\r\n    }\r\n\r\n    private String value;\r\n\r\n    public String getValue() {\r\n        return this.value;\r\n    }\r\n\r\n    public void setValue(String newValue) throws PropertyVetoException {\r\n        String oldValue = this.value;\r\n        this.vcs.fireVetoableChange(\"value\", oldValue, newValue);\r\n        this.value = newValue;\r\n    }\r\n\r\n    [...]\r\n}\r\n}</pre>\r\n<p>\r\nA {@code VetoableChangeSupport} instance is thread-safe.\r\n<p>\r\nThis class is serializable.  When it is serialized it will save\r\n(and restore) any listeners that are themselves serializable.  Any\r\nnon-serializable listeners will be skipped during serialization.","inherit":["java.io.Serializable"],"name":"java.beans.VetoableChangeSupport","type":false},{"description":"This is a {@link ChangeListenerMap ChangeListenerMap} implementation\r\nthat works with {@link VetoableChangeListener VetoableChangeListener} objects.","inherit":["java.beans.ChangeListenerMap"],"name":"java.beans.VetoableChangeSupport.VetoableChangeListenerMap","type":false},{"description":"","inherit":[],"name":"java.beans.Visibility","type":true},{"description":"Hash table based mapping, which uses weak references to store keys\r\nand reference-equality in place of object-equality to compare them.\r\nAn entry will automatically be removed when its key is no longer\r\nin ordinary use.  Both null values and the null key are supported.\r\nThis class does not require additional synchronization.\r\nA thread-safety is provided by a fragile combination\r\nof synchronized blocks and volatile fields.\r\nBe very careful during editing!","inherit":[],"name":"java.beans.WeakIdentityMap","type":false},{"description":"","inherit":["java.lang.ref.WeakReference"],"name":"java.beans.WeakIdentityMap.Entry","type":false},{"description":"The <code>XMLDecoder</code> class is used to read XML documents\r\ncreated using the <code>XMLEncoder</code> and is used just like\r\nthe <code>ObjectInputStream</code>. For example, one can use\r\nthe following fragment to read the first object defined\r\nin an XML document written by the <code>XMLEncoder</code>\r\nclass:\r\n<pre>\r\n      XMLDecoder d = new XMLDecoder(\r\n                         new BufferedInputStream(\r\n                             new FileInputStream(\"Test.xml\")));\r\n      Object result = d.readObject();\r\n      d.close();\r\n</pre>\r\n\r\n<p>\r\nFor more information you might also want to check out\r\n<a\r\n href=\"http://java.sun.com/products/jfc/tsc/articles/persistence3\">Long Term Persistence of JavaBeans Components: XML Schema</a>,\r\nan article in <em>The Swing Connection.</em>","inherit":["java.lang.AutoCloseable"],"name":"java.beans.XMLDecoder","type":false},{"description":"The <code>XMLEncoder</code> class is a complementary alternative to\r\nthe <code>ObjectOutputStream</code> and can used to generate\r\na textual representation of a <em>JavaBean</em> in the same\r\nway that the <code>ObjectOutputStream</code> can\r\nbe used to create binary representation of <code>Serializable</code>\r\nobjects. For example, the following fragment can be used to create\r\na textual representation the supplied <em>JavaBean</em>\r\nand all its properties:\r\n<pre>\r\n      XMLEncoder e = new XMLEncoder(\r\n                         new BufferedOutputStream(\r\n                             new FileOutputStream(\"Test.xml\")));\r\n      e.writeObject(new JButton(\"Hello, world\"));\r\n      e.close();\r\n</pre>\r\nDespite the similarity of their APIs, the <code>XMLEncoder</code>\r\nclass is exclusively designed for the purpose of archiving graphs\r\nof <em>JavaBean</em>s as textual representations of their public\r\nproperties. Like Java source files, documents written this way\r\nhave a natural immunity to changes in the implementations of the classes\r\ninvolved. The <code>ObjectOutputStream</code> continues to be recommended\r\nfor interprocess communication and general purpose serialization.\r\n<p>\r\nThe <code>XMLEncoder</code> class provides a default denotation for\r\n<em>JavaBean</em>s in which they are represented as XML documents\r\ncomplying with version 1.0 of the XML specification and the\r\nUTF-8 character encoding of the Unicode/ISO 10646 character set.\r\nThe XML documents produced by the <code>XMLEncoder</code> class are:\r\n<ul>\r\n<li>\r\n<em>Portable and version resilient</em>: they have no dependencies\r\non the private implementation of any class and so, like Java source\r\nfiles, they may be exchanged between environments which may have\r\ndifferent versions of some of the classes and between VMs from\r\ndifferent vendors.\r\n<li>\r\n<em>Structurally compact</em>: The <code>XMLEncoder</code> class\r\nuses a <em>redundancy elimination</em> algorithm internally so that the\r\ndefault values of a Bean's properties are not written to the stream.\r\n<li>\r\n<em>Fault tolerant</em>: Non-structural errors in the file,\r\ncaused either by damage to the file or by API changes\r\nmade to classes in an archive remain localized\r\nso that a reader can report the error and continue to load the parts\r\nof the document which were not affected by the error.\r\n</ul>\r\n<p>\r\nBelow is an example of an XML archive containing\r\nsome user interface components from the <em>swing</em> toolkit:\r\n<pre>\r\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;java version=\"1.0\" class=\"java.beans.XMLDecoder\"&gt;\r\n&lt;object class=\"javax.swing.JFrame\"&gt;\r\n  &lt;void property=\"name\"&gt;\r\n    &lt;string&gt;frame1&lt;/string&gt;\r\n  &lt;/void&gt;\r\n  &lt;void property=\"bounds\"&gt;\r\n    &lt;object class=\"java.awt.Rectangle\"&gt;\r\n      &lt;int&gt;0&lt;/int&gt;\r\n      &lt;int&gt;0&lt;/int&gt;\r\n      &lt;int&gt;200&lt;/int&gt;\r\n      &lt;int&gt;200&lt;/int&gt;\r\n    &lt;/object&gt;\r\n  &lt;/void&gt;\r\n  &lt;void property=\"contentPane\"&gt;\r\n    &lt;void method=\"add\"&gt;\r\n      &lt;object class=\"javax.swing.JButton\"&gt;\r\n        &lt;void property=\"label\"&gt;\r\n          &lt;string&gt;Hello&lt;/string&gt;\r\n        &lt;/void&gt;\r\n      &lt;/object&gt;\r\n    &lt;/void&gt;\r\n  &lt;/void&gt;\r\n  &lt;void property=\"visible\"&gt;\r\n    &lt;boolean&gt;true&lt;/boolean&gt;\r\n  &lt;/void&gt;\r\n&lt;/object&gt;\r\n&lt;/java&gt;\r\n</pre>\r\nThe XML syntax uses the following conventions:\r\n<ul>\r\n<li>\r\nEach element represents a method call.\r\n<li>\r\nThe \"object\" tag denotes an <em>expression</em> whose value is\r\nto be used as the argument to the enclosing element.\r\n<li>\r\nThe \"void\" tag denotes a <em>statement</em> which will\r\nbe executed, but whose result will not be used as an\r\nargument to the enclosing method.\r\n<li>\r\nElements which contain elements use those elements as arguments,\r\nunless they have the tag: \"void\".\r\n<li>\r\nThe name of the method is denoted by the \"method\" attribute.\r\n<li>\r\nXML's standard \"id\" and \"idref\" attributes are used to make\r\nreferences to previous expressions - so as to deal with\r\ncircularities in the object graph.\r\n<li>\r\nThe \"class\" attribute is used to specify the target of a static\r\nmethod or constructor explicitly; its value being the fully\r\nqualified name of the class.\r\n<li>\r\nElements with the \"void\" tag are executed using\r\nthe outer context as the target if no target is defined\r\nby a \"class\" attribute.\r\n<li>\r\nJava's String class is treated specially and is\r\nwritten &lt;string&gt;Hello, world&lt;/string&gt; where\r\nthe characters of the string are converted to bytes\r\nusing the UTF-8 character encoding.\r\n</ul>\r\n<p>\r\nAlthough all object graphs may be written using just these three\r\ntags, the following definitions are included so that common\r\ndata structures can be expressed more concisely:\r\n<p>\r\n<ul>\r\n<li>\r\nThe default method name is \"new\".\r\n<li>\r\nA reference to a java class is written in the form\r\n &lt;class&gt;javax.swing.JButton&lt;/class&gt;.\r\n<li>\r\nInstances of the wrapper classes for Java's primitive types are written\r\nusing the name of the primitive type as the tag. For example, an\r\ninstance of the <code>Integer</code> class could be written:\r\n&lt;int&gt;123&lt;/int&gt;. Note that the <code>XMLEncoder</code> class\r\nuses Java's reflection package in which the conversion between\r\nJava's primitive types and their associated \"wrapper classes\"\r\nis handled internally. The API for the <code>XMLEncoder</code> class\r\nitself deals only with <code>Object</code>s.\r\n<li>\r\nIn an element representing a nullary method whose name\r\nstarts with \"get\", the \"method\" attribute is replaced\r\nwith a \"property\" attribute whose value is given by removing\r\nthe \"get\" prefix and decapitalizing the result.\r\n<li>\r\nIn an element representing a monadic method whose name\r\nstarts with \"set\", the \"method\" attribute is replaced\r\nwith a \"property\" attribute whose value is given by removing\r\nthe \"set\" prefix and decapitalizing the result.\r\n<li>\r\nIn an element representing a method named \"get\" taking one\r\ninteger argument, the \"method\" attribute is replaced\r\nwith an \"index\" attribute whose value the value of the\r\nfirst argument.\r\n<li>\r\nIn an element representing a method named \"set\" taking two arguments,\r\nthe first of which is an integer, the \"method\" attribute is replaced\r\nwith an \"index\" attribute whose value the value of the\r\nfirst argument.\r\n<li>\r\nA reference to an array is written using the \"array\"\r\ntag. The \"class\" and \"length\" attributes specify the\r\nsub-type of the array and its length respectively.\r\n</ul>\r\n\r\n<p>\r\nFor more information you might also want to check out\r\n<a\r\n href=\"http://java.sun.com/products/jfc/tsc/articles/persistence4\">Using XMLEncoder</a>,\r\nan article in <em>The Swing Connection.</em>","inherit":["java.beans.Encoder","java.lang.AutoCloseable"],"name":"java.beans.XMLEncoder","type":false},{"description":"","inherit":[],"name":"java.beans.XMLEncoder.ValueData","type":false},{"description":"Utility methods for packing/unpacking primitive values in/out of byte arrays\r\nusing big-endian byte ordering.","inherit":[],"name":"java.io.Bits","type":false},{"description":"A <code>BufferedInputStream</code> adds\r\nfunctionality to another input stream-namely,\r\nthe ability to buffer the input and to\r\nsupport the <code>mark</code> and <code>reset</code>\r\nmethods. When  the <code>BufferedInputStream</code>\r\nis created, an internal buffer array is\r\ncreated. As bytes  from the stream are read\r\nor skipped, the internal buffer is refilled\r\nas necessary  from the contained input stream,\r\nmany bytes at a time. The <code>mark</code>\r\noperation  remembers a point in the input\r\nstream and the <code>reset</code> operation\r\ncauses all the  bytes read since the most\r\nrecent <code>mark</code> operation to be\r\nreread before new bytes are  taken from\r\nthe contained input stream.","inherit":["java.io.FilterInputStream"],"name":"java.io.BufferedInputStream","type":false},{"description":"The class implements a buffered output stream. By setting up such\r\nan output stream, an application can write bytes to the underlying\r\noutput stream without necessarily causing a call to the underlying\r\nsystem for each byte written.","inherit":["java.io.FilterOutputStream"],"name":"java.io.BufferedOutputStream","type":false},{"description":"","inherit":["java.io.Reader"],"name":"java.io.BufferedReader","type":false},{"description":"","inherit":["java.io.Writer"],"name":"java.io.BufferedWriter","type":false},{"description":"A <code>ByteArrayInputStream</code> contains\r\nan internal buffer that contains bytes that\r\nmay be read from the stream. An internal\r\ncounter keeps track of the next byte to\r\nbe supplied by the <code>read</code> method.\r\n<p>\r\nClosing a <tt>ByteArrayInputStream</tt> has no effect. The methods in\r\nthis class can be called after the stream has been closed without\r\ngenerating an <tt>IOException</tt>.","inherit":["java.io.InputStream"],"name":"java.io.ByteArrayInputStream","type":false},{"description":"","inherit":["java.io.OutputStream"],"name":"java.io.ByteArrayOutputStream","type":false},{"description":"This class implements a character buffer that can be used as a\r\ncharacter-input stream.","inherit":["java.io.Reader"],"name":"java.io.CharArrayReader","type":false},{"description":"This class implements a character buffer that can be used as an Writer.\r\nThe buffer automatically grows when data is written to the stream.  The data\r\ncan be retrieved using toCharArray() and toString().\r\n<P>\r\nNote: Invoking close() on this class has no effect, and methods\r\nof this class can be called after the stream has closed\r\nwithout generating an IOException.","inherit":["java.io.Writer"],"name":"java.io.CharArrayWriter","type":false},{"description":"Base class for character conversion exceptions.","inherit":["java.io.IOException"],"name":"java.io.CharConversionException","type":false},{"description":"A {@code Closeable} is a source or destination of data that can be closed.\r\nThe close method is invoked to release resources that the object is\r\nholding (such as open files).","inherit":["java.lang.AutoCloseable"],"name":"java.io.Closeable","type":true},{"description":"","inherit":["java.io.Flushable"],"name":"java.io.Console","type":false},{"description":"","inherit":["java.io.Reader"],"name":"java.io.Console.LineReader","type":false},{"description":"The {@code DataInput} interface provides\r\nfor reading bytes from a binary stream and\r\nreconstructing from them data in any of\r\nthe Java primitive types. There is also\r\na\r\nfacility for reconstructing a {@code String}\r\nfrom data in\r\n<a href=\"#modified-utf-8\">modified UTF-8</a>\r\nformat.\r\n<p>\r\nIt is generally true of all the reading\r\nroutines in this interface that if end of\r\nfile is reached before the desired number\r\nof bytes has been read, an {@code EOFException}\r\n(which is a kind of {@code IOException})\r\nis thrown. If any byte cannot be read for\r\nany reason other than end of file, an {@code IOException}\r\nother than {@code EOFException} is\r\nthrown. In particular, an {@code IOException}\r\nmay be thrown if the input stream has been\r\nclosed.\r\n\r\n<h3><a name=\"modified-utf-8\">Modified UTF-8</a></h3>\r\n<p>\r\nImplementations of the DataInput and DataOutput interfaces represent\r\nUnicode strings in a format that is a slight modification of UTF-8.\r\n(For information regarding the standard UTF-8 format, see section\r\n<i>3.9 Unicode Encoding Forms</i> of <i>The Unicode Standard, Version\r\n4.0</i>).\r\nNote that in the following table, the most significant bit appears in the\r\nfar left-hand column.\r\n\r\n<blockquote>\r\n  <table border=\"1\" cellspacing=\"0\" cellpadding=\"8\"\r\n         summary=\"Bit values and bytes\">\r\n    <tr>\r\n      <th colspan=\"9\"><span style=\"font-weight:normal\">\r\n        All characters in the range {@code '\\u005Cu0001'} to\r\n        {@code '\\u005Cu007F'} are represented by a single byte:</span></th>\r\n    </tr>\r\n    <tr>\r\n      <td></td>\r\n      <th colspan=\"8\" id=\"bit_a\">Bit Values</th>\r\n    </tr>\r\n    <tr>\r\n      <th id=\"byte1_a\">Byte 1</th>\r\n      <td><center>0</center>\r\n      <td colspan=\"7\"><center>bits 6-0</center>\r\n    </tr>\r\n    <tr>\r\n      <th colspan=\"9\"><span style=\"font-weight:normal\">\r\n        The null character {@code '\\u005Cu0000'} and characters\r\n        in the range {@code '\\u005Cu0080'} to {@code '\\u005Cu07FF'} are\r\n        represented by a pair of bytes:</span></th>\r\n    </tr>\r\n    <tr>\r\n      <td></td>\r\n      <th colspan=\"8\" id=\"bit_b\">Bit Values</th>\r\n    </tr>\r\n    <tr>\r\n      <th id=\"byte1_b\">Byte 1</th>\r\n      <td><center>1</center>\r\n      <td><center>1</center>\r\n      <td><center>0</center>\r\n      <td colspan=\"5\"><center>bits 10-6</center>\r\n    </tr>\r\n    <tr>\r\n      <th id=\"byte2_a\">Byte 2</th>\r\n      <td><center>1</center>\r\n      <td><center>0</center>\r\n      <td colspan=\"6\"><center>bits 5-0</center>\r\n    </tr>\r\n    <tr>\r\n      <th colspan=\"9\"><span style=\"font-weight:normal\">\r\n        {@code char} values in the range {@code '\\u005Cu0800'}\r\n        to {@code '\\u005CuFFFF'} are represented by three bytes:</span></th>\r\n    </tr>\r\n    <tr>\r\n      <td></td>\r\n      <th colspan=\"8\"id=\"bit_c\">Bit Values</th>\r\n    </tr>\r\n    <tr>\r\n      <th id=\"byte1_c\">Byte 1</th>\r\n      <td><center>1</center>\r\n      <td><center>1</center>\r\n      <td><center>1</center>\r\n      <td><center>0</center>\r\n      <td colspan=\"4\"><center>bits 15-12</center>\r\n    </tr>\r\n    <tr>\r\n      <th id=\"byte2_b\">Byte 2</th>\r\n      <td><center>1</center>\r\n      <td><center>0</center>\r\n      <td colspan=\"6\"><center>bits 11-6</center>\r\n    </tr>\r\n    <tr>\r\n      <th id=\"byte3\">Byte 3</th>\r\n      <td><center>1</center>\r\n      <td><center>0</center>\r\n      <td colspan=\"6\"><center>bits 5-0</center>\r\n    </tr>\r\n  </table>\r\n</blockquote>\r\n<p>\r\nThe differences between this format and the\r\nstandard UTF-8 format are the following:\r\n<ul>\r\n<li>The null byte {@code '\\u005Cu0000'} is encoded in 2-byte format\r\n    rather than 1-byte, so that the encoded strings never have\r\n    embedded nulls.\r\n<li>Only the 1-byte, 2-byte, and 3-byte formats are used.\r\n<li><a href=\"../lang/Character.html#unicode\">Supplementary characters</a>\r\n    are represented in the form of surrogate pairs.\r\n</ul>","inherit":[],"name":"java.io.DataInput","type":true},{"description":"A data input stream lets an application read primitive Java data\r\ntypes from an underlying input stream in a machine-independent\r\nway. An application uses a data output stream to write data that\r\ncan later be read by a data input stream.\r\n<p>\r\nDataInputStream is not necessarily safe for multithreaded access.\r\nThread safety is optional and is the responsibility of users of\r\nmethods in this class.","inherit":["java.io.FilterInputStream","java.io.DataInput"],"name":"java.io.DataInputStream","type":false},{"description":"The <code>DataOutput</code> interface provides\r\nfor converting data from any of the Java\r\nprimitive types to a series of bytes and\r\nwriting these bytes to a binary stream.\r\nThere is  also a facility for converting\r\na <code>String</code> into\r\n<a href=\"DataInput.html#modified-utf-8\">modified UTF-8</a>\r\nformat and writing the resulting series\r\nof bytes.\r\n<p>\r\nFor all the methods in this interface that\r\nwrite bytes, it is generally true that if\r\na byte cannot be written for any reason,\r\nan <code>IOException</code> is thrown.","inherit":[],"name":"java.io.DataOutput","type":true},{"description":"A data output stream lets an application write primitive Java data\r\ntypes to an output stream in a portable way. An application can\r\nthen use a data input stream to read the data back in.","inherit":["java.io.FilterOutputStream","java.io.DataOutput"],"name":"java.io.DataOutputStream","type":false},{"description":"","inherit":[],"name":"java.io.DefaultFileSystem","type":false},{"description":"","inherit":[],"name":"java.io.DeleteOnExitHook","type":false},{"description":"Signals that an end of file or end of stream has been reached\r\nunexpectedly during input.\r\n<p>\r\nThis exception is mainly used by data input streams to signal end of\r\nstream. Note that many other input operations return a special value on\r\nend of stream rather than throwing an exception.","inherit":["java.io.IOException"],"name":"java.io.EOFException","type":false},{"description":"","inherit":[],"name":"java.io.ExpiringCache","type":false},{"description":"","inherit":[],"name":"java.io.ExpiringCache.Entry","type":false},{"description":"Only the identity of the class of an Externalizable instance is\r\nwritten in the serialization stream and it is the responsibility\r\nof the class to save and restore the contents of its instances.\r\n\r\nThe writeExternal and readExternal methods of the Externalizable\r\ninterface are implemented by a class to give the class complete\r\ncontrol over the format and contents of the stream for an object\r\nand its supertypes. These methods must explicitly\r\ncoordinate with the supertype to save its state. These methods supersede\r\ncustomized implementations of writeObject and readObject methods.<br>\r\n\r\nObject Serialization uses the Serializable and Externalizable\r\ninterfaces.  Object persistence mechanisms can use them as well.  Each\r\nobject to be stored is tested for the Externalizable interface. If\r\nthe object supports Externalizable, the writeExternal method is called. If the\r\nobject does not support Externalizable and does implement\r\nSerializable, the object is saved using\r\nObjectOutputStream. <br> When an Externalizable object is\r\nreconstructed, an instance is created using the public no-arg\r\nconstructor, then the readExternal method called.  Serializable\r\nobjects are restored by reading them from an ObjectInputStream.<br>\r\n\r\nAn Externalizable instance can designate a substitution object via\r\nthe writeReplace and readResolve methods documented in the Serializable\r\ninterface.<br>","inherit":["java.io.Serializable"],"name":"java.io.Externalizable","type":true},{"description":"","inherit":["java.io.Serializable","java.lang.Comparable"],"name":"java.io.File","type":false},{"description":"","inherit":[],"name":"java.io.File.TempDirectory","type":false},{"description":"Instances of the file descriptor class serve as an opaque handle\r\nto the underlying machine-specific structure representing an\r\nopen file, an open socket, or another source or sink of bytes.\r\nThe main practical use for a file descriptor is to create a\r\n{@link FileInputStream} or {@link FileOutputStream} to contain it.\r\n\r\n<p>Applications should not create their own file descriptors.","inherit":[],"name":"java.io.FileDescriptor","type":false},{"description":"A filter for abstract pathnames.\r\n\r\n<p> Instances of this interface may be passed to the <code>{@link\r\nFile#listFiles(java.io.FileFilter) listFiles(FileFilter)}</code> method\r\nof the <code>{@link java.io.File}</code> class.","inherit":[],"name":"java.io.FileFilter","type":true},{"description":"A <code>FileInputStream</code> obtains input bytes\r\nfrom a file in a file system. What files\r\nare  available depends on the host environment.\r\n\r\n<p><code>FileInputStream</code> is meant for reading streams of raw bytes\r\nsuch as image data. For reading streams of characters, consider using\r\n<code>FileReader</code>.","inherit":["java.io.InputStream"],"name":"java.io.FileInputStream","type":false},{"description":"Instances of classes that implement this interface are used to\r\nfilter filenames. These instances are used to filter directory\r\nlistings in the <code>list</code> method of class\r\n<code>File</code>, and by the Abstract Window Toolkit's file\r\ndialog component.","inherit":[],"name":"java.io.FilenameFilter","type":true},{"description":"","inherit":["java.io.IOException"],"name":"java.io.FileNotFoundException","type":false},{"description":"A file output stream is an output stream for writing data to a\r\n<code>File</code> or to a <code>FileDescriptor</code>. Whether or not\r\na file is available or may be created depends upon the underlying\r\nplatform.  Some platforms, in particular, allow a file to be opened\r\nfor writing by only one <tt>FileOutputStream</tt> (or other\r\nfile-writing object) at a time.  In such situations the constructors in\r\nthis class will fail if the file involved is already open.\r\n\r\n<p><code>FileOutputStream</code> is meant for writing streams of raw bytes\r\nsuch as image data. For writing streams of characters, consider using\r\n<code>FileWriter</code>.","inherit":["java.io.OutputStream"],"name":"java.io.FileOutputStream","type":false},{"description":"","inherit":["java.security.Permission","java.io.Serializable"],"name":"java.io.FilePermission","type":false},{"description":"","inherit":["java.security.PermissionCollection","java.io.Serializable"],"name":"java.io.FilePermissionCollection","type":false},{"description":"Convenience class for reading character files.  The constructors of this\r\nclass assume that the default character encoding and the default byte-buffer\r\nsize are appropriate.  To specify these values yourself, construct an\r\nInputStreamReader on a FileInputStream.\r\n\r\n<p><code>FileReader</code> is meant for reading streams of characters.\r\nFor reading streams of raw bytes, consider using a\r\n<code>FileInputStream</code>.","inherit":["java.io.InputStreamReader"],"name":"java.io.FileReader","type":false},{"description":"","inherit":[],"name":"java.io.FileSystem","type":false},{"description":"","inherit":["java.io.OutputStreamWriter"],"name":"java.io.FileWriter","type":false},{"description":"A <code>FilterInputStream</code> contains\r\nsome other input stream, which it uses as\r\nits  basic source of data, possibly transforming\r\nthe data along the way or providing  additional\r\nfunctionality. The class <code>FilterInputStream</code>\r\nitself simply overrides all  methods of\r\n<code>InputStream</code> with versions that\r\npass all requests to the contained  input\r\nstream. Subclasses of <code>FilterInputStream</code>\r\nmay further override some of  these methods\r\nand may also provide additional methods\r\nand fields.","inherit":["java.io.InputStream"],"name":"java.io.FilterInputStream","type":false},{"description":"This class is the superclass of all classes that filter output\r\nstreams. These streams sit on top of an already existing output\r\nstream (the <i>underlying</i> output stream) which it uses as its\r\nbasic sink of data, but possibly transforming the data along the\r\nway or providing additional functionality.\r\n<p>\r\nThe class <code>FilterOutputStream</code> itself simply overrides\r\nall methods of <code>OutputStream</code> with versions that pass\r\nall requests to the underlying output stream. Subclasses of\r\n<code>FilterOutputStream</code> may further override some of these\r\nmethods as well as provide additional methods and fields.","inherit":["java.io.OutputStream"],"name":"java.io.FilterOutputStream","type":false},{"description":"","inherit":["java.io.Reader"],"name":"java.io.FilterReader","type":false},{"description":"","inherit":["java.io.Writer"],"name":"java.io.FilterWriter","type":false},{"description":"A <tt>Flushable</tt> is a destination of data that can be flushed.  The\r\nflush method is invoked to write any buffered output to the underlying\r\nstream.","inherit":[],"name":"java.io.Flushable","type":true},{"description":"This abstract class is the superclass of all classes representing\r\nan input stream of bytes.\r\n\r\n<p> Applications that need to define a subclass of <code>InputStream</code>\r\nmust always provide a method that returns the next byte of input.","inherit":["java.io.Closeable"],"name":"java.io.InputStream","type":false},{"description":"","inherit":["java.io.Reader"],"name":"java.io.InputStreamReader","type":false},{"description":"Signals that an I/O operation has been interrupted. An\r\n<code>InterruptedIOException</code> is thrown to indicate that an\r\ninput or output transfer has been terminated because the thread\r\nperforming it was interrupted. The field {@link #bytesTransferred}\r\nindicates how many bytes were successfully transferred before\r\nthe interruption occurred.","inherit":["java.io.IOException"],"name":"java.io.InterruptedIOException","type":false},{"description":"Thrown when the Serialization runtime detects one of the following\r\nproblems with a Class.\r\n<UL>\r\n<LI> The serial version of the class does not match that of the class\r\n     descriptor read from the stream\r\n<LI> The class contains unknown datatypes\r\n<LI> The class does not have an accessible no-arg constructor\r\n</UL>","inherit":["java.io.ObjectStreamException"],"name":"java.io.InvalidClassException","type":false},{"description":"Indicates that one or more deserialized objects failed validation\r\ntests.  The argument should provide the reason for the failure.","inherit":["java.io.ObjectStreamException"],"name":"java.io.InvalidObjectException","type":false},{"description":"Thrown when a serious I/O error has occurred.","inherit":["java.lang.Error"],"name":"java.io.IOError","type":false},{"description":"Signals that an I/O exception of some sort has occurred. This\r\nclass is the general class of exceptions produced by failed or\r\ninterrupted I/O operations.","inherit":["java.lang.Exception"],"name":"java.io.IOException","type":false},{"description":"This class is an input stream filter that provides the added\r\nfunctionality of keeping track of the current line number.\r\n<p>\r\nA line is a sequence of bytes ending with a carriage return\r\ncharacter ({@code '\\u005Cr'}), a newline character\r\n({@code '\\u005Cn'}), or a carriage return character followed\r\nimmediately by a linefeed character. In all three cases, the line\r\nterminating character(s) are returned as a single newline character.\r\n<p>\r\nThe line number begins at {@code 0}, and is incremented by\r\n{@code 1} when a {@code read} returns a newline character.","inherit":["java.io.FilterInputStream"],"name":"java.io.LineNumberInputStream","type":false},{"description":"","inherit":["java.io.BufferedReader"],"name":"java.io.LineNumberReader","type":false},{"description":"Thrown when serialization or deserialization is not active.","inherit":["java.io.ObjectStreamException"],"name":"java.io.NotActiveException","type":false},{"description":"Thrown when an instance is required to have a Serializable interface.\r\nThe serialization runtime or the class of the instance can throw\r\nthis exception. The argument should be the name of the class.","inherit":["java.io.ObjectStreamException"],"name":"java.io.NotSerializableException","type":false},{"description":"ObjectInput extends the DataInput interface to include the reading of\r\nobjects. DataInput includes methods for the input of primitive types,\r\nObjectInput extends that interface to include objects, arrays, and Strings.","inherit":["java.io.DataInput","java.lang.AutoCloseable"],"name":"java.io.ObjectInput","type":true},{"description":"An ObjectInputStream deserializes primitive data and objects previously\r\nwritten using an ObjectOutputStream.\r\n\r\n<p>ObjectOutputStream and ObjectInputStream can provide an application with\r\npersistent storage for graphs of objects when used with a FileOutputStream\r\nand FileInputStream respectively.  ObjectInputStream is used to recover\r\nthose objects previously serialized. Other uses include passing objects\r\nbetween hosts using a socket stream or for marshaling and unmarshaling\r\narguments and parameters in a remote communication system.\r\n\r\n<p>ObjectInputStream ensures that the types of all objects in the graph\r\ncreated from the stream match the classes present in the Java Virtual\r\nMachine.  Classes are loaded as required using the standard mechanisms.\r\n\r\n<p>Only objects that support the java.io.Serializable or\r\njava.io.Externalizable interface can be read from streams.\r\n\r\n<p>The method <code>readObject</code> is used to read an object from the\r\nstream.  Java's safe casting should be used to get the desired type.  In\r\nJava, strings and arrays are objects and are treated as objects during\r\nserialization. When read they need to be cast to the expected type.\r\n\r\n<p>Primitive data types can be read from the stream using the appropriate\r\nmethod on DataInput.\r\n\r\n<p>The default deserialization mechanism for objects restores the contents\r\nof each field to the value and type it had when it was written.  Fields\r\ndeclared as transient or static are ignored by the deserialization process.\r\nReferences to other objects cause those objects to be read from the stream\r\nas necessary.  Graphs of objects are restored correctly using a reference\r\nsharing mechanism.  New objects are always allocated when deserializing,\r\nwhich prevents existing objects from being overwritten.\r\n\r\n<p>Reading an object is analogous to running the constructors of a new\r\nobject.  Memory is allocated for the object and initialized to zero (NULL).\r\nNo-arg constructors are invoked for the non-serializable classes and then\r\nthe fields of the serializable classes are restored from the stream starting\r\nwith the serializable class closest to java.lang.object and finishing with\r\nthe object's most specific class.\r\n\r\n<p>For example to read from a stream as written by the example in\r\nObjectOutputStream:\r\n<br>\r\n<pre>\r\n     FileInputStream fis = new FileInputStream(\"t.tmp\");\r\n     ObjectInputStream ois = new ObjectInputStream(fis);\r\n\r\n     int i = ois.readInt();\r\n     String today = (String) ois.readObject();\r\n     Date date = (Date) ois.readObject();\r\n\r\n     ois.close();\r\n</pre>\r\n\r\n<p>Classes control how they are serialized by implementing either the\r\njava.io.Serializable or java.io.Externalizable interfaces.\r\n\r\n<p>Implementing the Serializable interface allows object serialization to\r\nsave and restore the entire state of the object and it allows classes to\r\nevolve between the time the stream is written and the time it is read.  It\r\nautomatically traverses references between objects, saving and restoring\r\nentire graphs.\r\n\r\n<p>Serializable classes that require special handling during the\r\nserialization and deserialization process should implement the following\r\nmethods:\r\n\r\n<pre>\r\nprivate void writeObject(java.io.ObjectOutputStream stream)\r\n    throws IOException;\r\nprivate void readObject(java.io.ObjectInputStream stream)\r\n    throws IOException, ClassNotFoundException;\r\nprivate void readObjectNoData()\r\n    throws ObjectStreamException;\r\n</pre>\r\n\r\n<p>The readObject method is responsible for reading and restoring the state\r\nof the object for its particular class using data written to the stream by\r\nthe corresponding writeObject method.  The method does not need to concern\r\nitself with the state belonging to its superclasses or subclasses.  State is\r\nrestored by reading data from the ObjectInputStream for the individual\r\nfields and making assignments to the appropriate fields of the object.\r\nReading primitive data types is supported by DataInput.\r\n\r\n<p>Any attempt to read object data which exceeds the boundaries of the\r\ncustom data written by the corresponding writeObject method will cause an\r\nOptionalDataException to be thrown with an eof field value of true.\r\nNon-object reads which exceed the end of the allotted data will reflect the\r\nend of data in the same way that they would indicate the end of the stream:\r\nbytewise reads will return -1 as the byte read or number of bytes read, and\r\nprimitive reads will throw EOFExceptions.  If there is no corresponding\r\nwriteObject method, then the end of default serialized data marks the end of\r\nthe allotted data.\r\n\r\n<p>Primitive and object read calls issued from within a readExternal method\r\nbehave in the same manner--if the stream is already positioned at the end of\r\ndata written by the corresponding writeExternal method, object reads will\r\nthrow OptionalDataExceptions with eof set to true, bytewise reads will\r\nreturn -1, and primitive reads will throw EOFExceptions.  Note that this\r\nbehavior does not hold for streams written with the old\r\n<code>ObjectStreamConstants.PROTOCOL_VERSION_1</code> protocol, in which the\r\nend of data written by writeExternal methods is not demarcated, and hence\r\ncannot be detected.\r\n\r\n<p>The readObjectNoData method is responsible for initializing the state of\r\nthe object for its particular class in the event that the serialization\r\nstream does not list the given class as a superclass of the object being\r\ndeserialized.  This may occur in cases where the receiving party uses a\r\ndifferent version of the deserialized instance's class than the sending\r\nparty, and the receiver's version extends classes that are not extended by\r\nthe sender's version.  This may also occur if the serialization stream has\r\nbeen tampered; hence, readObjectNoData is useful for initializing\r\ndeserialized objects properly despite a \"hostile\" or incomplete source\r\nstream.\r\n\r\n<p>Serialization does not read or assign values to the fields of any object\r\nthat does not implement the java.io.Serializable interface.  Subclasses of\r\nObjects that are not serializable can be serializable. In this case the\r\nnon-serializable class must have a no-arg constructor to allow its fields to\r\nbe initialized.  In this case it is the responsibility of the subclass to\r\nsave and restore the state of the non-serializable class. It is frequently\r\nthe case that the fields of that class are accessible (public, package, or\r\nprotected) or that there are get and set methods that can be used to restore\r\nthe state.\r\n\r\n<p>Any exception that occurs while deserializing an object will be caught by\r\nthe ObjectInputStream and abort the reading process.\r\n\r\n<p>Implementing the Externalizable interface allows the object to assume\r\ncomplete control over the contents and format of the object's serialized\r\nform.  The methods of the Externalizable interface, writeExternal and\r\nreadExternal, are called to save and restore the objects state.  When\r\nimplemented by a class they can write and read their own state using all of\r\nthe methods of ObjectOutput and ObjectInput.  It is the responsibility of\r\nthe objects to handle any versioning that occurs.\r\n\r\n<p>Enum constants are deserialized differently than ordinary serializable or\r\nexternalizable objects.  The serialized form of an enum constant consists\r\nsolely of its name; field values of the constant are not transmitted.  To\r\ndeserialize an enum constant, ObjectInputStream reads the constant name from\r\nthe stream; the deserialized constant is then obtained by calling the static\r\nmethod <code>Enum.valueOf(Class, String)</code> with the enum constant's\r\nbase type and the received constant name as arguments.  Like other\r\nserializable or externalizable objects, enum constants can function as the\r\ntargets of back references appearing subsequently in the serialization\r\nstream.  The process by which enum constants are deserialized cannot be\r\ncustomized: any class-specific readObject, readObjectNoData, and readResolve\r\nmethods defined by enum types are ignored during deserialization.\r\nSimilarly, any serialPersistentFields or serialVersionUID field declarations\r\nare also ignored--all enum types have a fixed serialVersionUID of 0L.","inherit":["java.io.InputStream","java.io.ObjectInput","java.io.ObjectStreamConstants"],"name":"java.io.ObjectInputStream","type":false},{"description":"","inherit":[],"name":"java.io.ObjectInputStream.Caches","type":false},{"description":"","inherit":[],"name":"java.io.ObjectInputStream.Logging","type":false},{"description":"Provide access to the persistent fields read from the input stream.","inherit":[],"name":"java.io.ObjectInputStream.GetField","type":false},{"description":"Default GetField implementation.","inherit":["java.io.ObjectInputStream.GetField"],"name":"java.io.ObjectInputStream.GetFieldImpl","type":false},{"description":"Prioritized list of callbacks to be performed once object graph has been\r\ncompletely deserialized.","inherit":[],"name":"java.io.ObjectInputStream.ValidationList","type":false},{"description":"","inherit":[],"name":"java.io.ObjectInputStream.ValidationList.Callback","type":false},{"description":"Hold a snapshot of values to be passed to an ObjectInputFilter.","inherit":["sun.misc.ObjectInputFilter.FilterInfo"],"name":"java.io.ObjectInputStream.FilterValues","type":false},{"description":"Input stream supporting single-byte peek operations.","inherit":["java.io.InputStream"],"name":"java.io.ObjectInputStream.PeekInputStream","type":false},{"description":"Input stream with two modes: in default mode, inputs data written in the\r\nsame format as DataOutputStream; in \"block data\" mode, inputs data\r\nbracketed by block data markers (see object serialization specification\r\nfor details).  Buffering depends on block data mode: when in default\r\nmode, no data is buffered in advance; when in block data mode, all data\r\nfor the current data block is read in at once (and buffered).","inherit":["java.io.InputStream","java.io.DataInput"],"name":"java.io.ObjectInputStream.BlockDataInputStream","type":false},{"description":"","inherit":[],"name":"java.io.ObjectInputStream.HandleTable","type":false},{"description":"Simple growable list of (integer) handles.","inherit":[],"name":"java.io.ObjectInputStream.HandleTable.HandleList","type":false},{"description":"Callback interface to allow validation of objects within a graph.\r\nAllows an object to be called when a complete graph of objects has\r\nbeen deserialized.","inherit":[],"name":"java.io.ObjectInputValidation","type":true},{"description":"ObjectOutput extends the DataOutput interface to include writing of objects.\r\nDataOutput includes methods for output of primitive types, ObjectOutput\r\nextends that interface to include objects, arrays, and Strings.","inherit":["java.io.DataOutput","java.lang.AutoCloseable"],"name":"java.io.ObjectOutput","type":true},{"description":"An ObjectOutputStream writes primitive data types and graphs of Java objects\r\nto an OutputStream.  The objects can be read (reconstituted) using an\r\nObjectInputStream.  Persistent storage of objects can be accomplished by\r\nusing a file for the stream.  If the stream is a network socket stream, the\r\nobjects can be reconstituted on another host or in another process.\r\n\r\n<p>Only objects that support the java.io.Serializable interface can be\r\nwritten to streams.  The class of each serializable object is encoded\r\nincluding the class name and signature of the class, the values of the\r\nobject's fields and arrays, and the closure of any other objects referenced\r\nfrom the initial objects.\r\n\r\n<p>The method writeObject is used to write an object to the stream.  Any\r\nobject, including Strings and arrays, is written with writeObject. Multiple\r\nobjects or primitives can be written to the stream.  The objects must be\r\nread back from the corresponding ObjectInputstream with the same types and\r\nin the same order as they were written.\r\n\r\n<p>Primitive data types can also be written to the stream using the\r\nappropriate methods from DataOutput. Strings can also be written using the\r\nwriteUTF method.\r\n\r\n<p>The default serialization mechanism for an object writes the class of the\r\nobject, the class signature, and the values of all non-transient and\r\nnon-static fields.  References to other objects (except in transient or\r\nstatic fields) cause those objects to be written also. Multiple references\r\nto a single object are encoded using a reference sharing mechanism so that\r\ngraphs of objects can be restored to the same shape as when the original was\r\nwritten.\r\n\r\n<p>For example to write an object that can be read by the example in\r\nObjectInputStream:\r\n<br>\r\n<pre>\r\n     FileOutputStream fos = new FileOutputStream(\"t.tmp\");\r\n     ObjectOutputStream oos = new ObjectOutputStream(fos);\r\n\r\n     oos.writeInt(12345);\r\n     oos.writeObject(\"Today\");\r\n     oos.writeObject(new Date());\r\n\r\n     oos.close();\r\n</pre>\r\n\r\n<p>Classes that require special handling during the serialization and\r\ndeserialization process must implement special methods with these exact\r\nsignatures:\r\n<br>\r\n<pre>\r\nprivate void readObject(java.io.ObjectInputStream stream)\r\n    throws IOException, ClassNotFoundException;\r\nprivate void writeObject(java.io.ObjectOutputStream stream)\r\n    throws IOException\r\nprivate void readObjectNoData()\r\n    throws ObjectStreamException;\r\n</pre>\r\n\r\n<p>The writeObject method is responsible for writing the state of the object\r\nfor its particular class so that the corresponding readObject method can\r\nrestore it.  The method does not need to concern itself with the state\r\nbelonging to the object's superclasses or subclasses.  State is saved by\r\nwriting the individual fields to the ObjectOutputStream using the\r\nwriteObject method or by using the methods for primitive data types\r\nsupported by DataOutput.\r\n\r\n<p>Serialization does not write out the fields of any object that does not\r\nimplement the java.io.Serializable interface.  Subclasses of Objects that\r\nare not serializable can be serializable. In this case the non-serializable\r\nclass must have a no-arg constructor to allow its fields to be initialized.\r\nIn this case it is the responsibility of the subclass to save and restore\r\nthe state of the non-serializable class. It is frequently the case that the\r\nfields of that class are accessible (public, package, or protected) or that\r\nthere are get and set methods that can be used to restore the state.\r\n\r\n<p>Serialization of an object can be prevented by implementing writeObject\r\nand readObject methods that throw the NotSerializableException.  The\r\nexception will be caught by the ObjectOutputStream and abort the\r\nserialization process.\r\n\r\n<p>Implementing the Externalizable interface allows the object to assume\r\ncomplete control over the contents and format of the object's serialized\r\nform.  The methods of the Externalizable interface, writeExternal and\r\nreadExternal, are called to save and restore the objects state.  When\r\nimplemented by a class they can write and read their own state using all of\r\nthe methods of ObjectOutput and ObjectInput.  It is the responsibility of\r\nthe objects to handle any versioning that occurs.\r\n\r\n<p>Enum constants are serialized differently than ordinary serializable or\r\nexternalizable objects.  The serialized form of an enum constant consists\r\nsolely of its name; field values of the constant are not transmitted.  To\r\nserialize an enum constant, ObjectOutputStream writes the string returned by\r\nthe constant's name method.  Like other serializable or externalizable\r\nobjects, enum constants can function as the targets of back references\r\nappearing subsequently in the serialization stream.  The process by which\r\nenum constants are serialized cannot be customized; any class-specific\r\nwriteObject and writeReplace methods defined by enum types are ignored\r\nduring serialization.  Similarly, any serialPersistentFields or\r\nserialVersionUID field declarations are also ignored--all enum types have a\r\nfixed serialVersionUID of 0L.\r\n\r\n<p>Primitive data, excluding serializable fields and externalizable data, is\r\nwritten to the ObjectOutputStream in block-data records. A block data record\r\nis composed of a header and data. The block data header consists of a marker\r\nand the number of bytes to follow the header.  Consecutive primitive data\r\nwrites are merged into one block-data record.  The blocking factor used for\r\na block-data record will be 1024 bytes.  Each block-data record will be\r\nfilled up to 1024 bytes, or be written whenever there is a termination of\r\nblock-data mode.  Calls to the ObjectOutputStream methods writeObject,\r\ndefaultWriteObject and writeFields initially terminate any existing\r\nblock-data record.","inherit":["java.io.OutputStream","java.io.ObjectOutput","java.io.ObjectStreamConstants"],"name":"java.io.ObjectOutputStream","type":false},{"description":"","inherit":[],"name":"java.io.ObjectOutputStream.Caches","type":false},{"description":"Provide programmatic access to the persistent fields to be written\r\nto ObjectOutput.","inherit":[],"name":"java.io.ObjectOutputStream.PutField","type":false},{"description":"Default PutField implementation.","inherit":["java.io.ObjectOutputStream.PutField"],"name":"java.io.ObjectOutputStream.PutFieldImpl","type":false},{"description":"Buffered output stream with two modes: in default mode, outputs data in\r\nsame format as DataOutputStream; in \"block data\" mode, outputs data\r\nbracketed by block data markers (see object serialization specification\r\nfor details).","inherit":["java.io.OutputStream","java.io.DataOutput"],"name":"java.io.ObjectOutputStream.BlockDataOutputStream","type":false},{"description":"Lightweight identity hash table which maps objects to integer handles,\r\nassigned in ascending order.","inherit":[],"name":"java.io.ObjectOutputStream.HandleTable","type":false},{"description":"Lightweight identity hash table which maps objects to replacement\r\nobjects.","inherit":[],"name":"java.io.ObjectOutputStream.ReplaceTable","type":false},{"description":"Stack to keep debug information about the state of the\r\nserialization process, for embedding in exception messages.","inherit":[],"name":"java.io.ObjectOutputStream.DebugTraceInfoStack","type":false},{"description":"Serialization's descriptor for classes.  It contains the name and\r\nserialVersionUID of the class.  The ObjectStreamClass for a specific class\r\nloaded in this Java VM can be found/created using the lookup method.\r\n\r\n<p>The algorithm to compute the SerialVersionUID is described in\r\n<a href=\"../../../platform/serialization/spec/class.html#4100\">Object\r\nSerialization Specification, Section 4.6, Stream Unique Identifiers</a>.","inherit":["java.io.Serializable"],"name":"java.io.ObjectStreamClass","type":false},{"description":"","inherit":[],"name":"java.io.ObjectStreamClass.Caches","type":false},{"description":"Contains information about InvalidClassException instances to be thrown\r\nwhen attempting operations on an invalid class. Note that instances of\r\nthis class are immutable and are potentially shared among\r\nObjectStreamClass instances.","inherit":[],"name":"java.io.ObjectStreamClass.ExceptionInfo","type":false},{"description":"Placeholder used in class descriptor and field reflector lookup tables\r\nfor an entry in the process of being initialized.  (Internal) callers\r\nwhich receive an EntryFuture belonging to another thread as the result\r\nof a lookup should call the get() method of the EntryFuture; this will\r\nreturn the actual entry once it is ready for use and has been set().  To\r\nconserve objects, EntryFutures synchronize on themselves.","inherit":[],"name":"java.io.ObjectStreamClass.EntryFuture","type":false},{"description":"Class representing the portion of an object's serialized form allotted\r\nto data described by a given class descriptor.  If \"hasData\" is false,\r\nthe object's serialized form does not contain data associated with the\r\nclass descriptor.","inherit":[],"name":"java.io.ObjectStreamClass.ClassDataSlot","type":false},{"description":"Class for computing and caching field/constructor/method signatures\r\nduring serialVersionUID calculation.","inherit":[],"name":"java.io.ObjectStreamClass.MemberSignature","type":false},{"description":"","inherit":[],"name":"java.io.ObjectStreamClass.FieldReflector","type":false},{"description":"FieldReflector cache lookup key.  Keys are considered equal if they\r\nrefer to the same class and equivalent field formats.","inherit":["java.lang.ref.WeakReference"],"name":"java.io.ObjectStreamClass.FieldReflectorKey","type":false},{"description":" Weak key for Class objects.","inherit":["java.lang.ref.WeakReference"],"name":"java.io.ObjectStreamClass.WeakClassKey","type":false},{"description":"Constants written into the Object Serialization Stream.","inherit":[],"name":"java.io.ObjectStreamConstants","type":true},{"description":"Superclass of all exceptions specific to Object Stream classes.","inherit":["java.io.IOException"],"name":"java.io.ObjectStreamException","type":false},{"description":"A description of a Serializable field from a Serializable class.  An array\r\nof ObjectStreamFields is used to declare the Serializable fields of a class.","inherit":["java.lang.Comparable"],"name":"java.io.ObjectStreamField","type":false},{"description":"Exception indicating the failure of an object read operation due to\r\nunread primitive data, or the end of data belonging to a serialized\r\nobject in the stream.  This exception may be thrown in two cases:\r\n\r\n<ul>\r\n  <li>An attempt was made to read an object when the next element in the\r\n      stream is primitive data.  In this case, the OptionalDataException's\r\n      length field is set to the number of bytes of primitive data\r\n      immediately readable from the stream, and the eof field is set to\r\n      false.\r\n\r\n  <li>An attempt was made to read past the end of data consumable by a\r\n      class-defined readObject or readExternal method.  In this case, the\r\n      OptionalDataException's eof field is set to true, and the length field\r\n      is set to 0.\r\n</ul>","inherit":["java.io.ObjectStreamException"],"name":"java.io.OptionalDataException","type":false},{"description":"This abstract class is the superclass of all classes representing\r\nan output stream of bytes. An output stream accepts output bytes\r\nand sends them to some sink.\r\n<p>\r\nApplications that need to define a subclass of\r\n<code>OutputStream</code> must always provide at least a method\r\nthat writes one byte of output.","inherit":["java.io.Closeable","java.io.Flushable"],"name":"java.io.OutputStream","type":false},{"description":"","inherit":["java.io.Writer"],"name":"java.io.OutputStreamWriter","type":false},{"description":"A piped input stream should be connected\r\nto a piped output stream; the piped  input\r\nstream then provides whatever data bytes\r\nare written to the piped output  stream.\r\nTypically, data is read from a <code>PipedInputStream</code>\r\nobject by one thread  and data is written\r\nto the corresponding <code>PipedOutputStream</code>\r\nby some  other thread. Attempting to use\r\nboth objects from a single thread is not\r\nrecommended, as it may deadlock the thread.\r\nThe piped input stream contains a buffer,\r\ndecoupling read operations from write operations,\r\nwithin limits.\r\nA pipe is said to be <a name=\"BROKEN\"> <i>broken</i> </a> if a\r\nthread that was providing data bytes to the connected\r\npiped output stream is no longer alive.","inherit":["java.io.InputStream"],"name":"java.io.PipedInputStream","type":false},{"description":"A piped output stream can be connected to a piped input stream\r\nto create a communications pipe. The piped output stream is the\r\nsending end of the pipe. Typically, data is written to a\r\n<code>PipedOutputStream</code> object by one thread and data is\r\nread from the connected <code>PipedInputStream</code> by some\r\nother thread. Attempting to use both objects from a single thread\r\nis not recommended as it may deadlock the thread.\r\nThe pipe is said to be <a name=BROKEN> <i>broken</i> </a> if a\r\nthread that was reading data bytes from the connected piped input\r\nstream is no longer alive.","inherit":["java.io.OutputStream"],"name":"java.io.PipedOutputStream","type":false},{"description":"","inherit":["java.io.Reader"],"name":"java.io.PipedReader","type":false},{"description":"","inherit":["java.io.Writer"],"name":"java.io.PipedWriter","type":false},{"description":"","inherit":["java.io.FilterOutputStream","java.lang.Appendable","java.io.Closeable"],"name":"java.io.PrintStream","type":false},{"description":"","inherit":["java.io.Writer"],"name":"java.io.PrintWriter","type":false},{"description":"A <code>PushbackInputStream</code> adds\r\nfunctionality to another input stream, namely\r\nthe  ability to \"push back\" or \"unread\"\r\none byte. This is useful in situations where\r\nit is  convenient for a fragment of code\r\nto read an indefinite number of data bytes\r\nthat  are delimited by a particular byte\r\nvalue; after reading the terminating byte,\r\nthe  code fragment can \"unread\" it, so that\r\nthe next read operation on the input stream\r\nwill reread the byte that was pushed back.\r\nFor example, bytes representing the  characters\r\nconstituting an identifier might be terminated\r\nby a byte representing an  operator character;\r\na method whose job is to read just an identifier\r\ncan read until it  sees the operator and\r\nthen push the operator back to be re-read.","inherit":["java.io.FilterInputStream"],"name":"java.io.PushbackInputStream","type":false},{"description":"","inherit":["java.io.FilterReader"],"name":"java.io.PushbackReader","type":false},{"description":"","inherit":["java.io.DataOutput","java.io.DataInput","java.io.Closeable"],"name":"java.io.RandomAccessFile","type":false},{"description":"","inherit":["java.lang.Readable","java.io.Closeable"],"name":"java.io.Reader","type":false},{"description":"A <code>SequenceInputStream</code> represents\r\nthe logical concatenation of other input\r\nstreams. It starts out with an ordered\r\ncollection of input streams and reads from\r\nthe first one until end of file is reached,\r\nwhereupon it reads from the second one,\r\nand so on, until end of file is reached\r\non the last of the contained input streams.","inherit":["java.io.InputStream"],"name":"java.io.SequenceInputStream","type":false},{"description":"Context during upcalls from object stream to class-defined\r\nreadObject/writeObject methods.\r\nHolds object currently being deserialized and descriptor for current class.\r\n\r\nThis context keeps track of the thread it was constructed on, and allows\r\nonly a single call of defaultReadObject, readFields, defaultWriteObject\r\nor writeFields which must be invoked on the same thread before the class's\r\nreadObject/writeObject method has returned.\r\nIf not set to the current thread, the getObj method throws NotActiveException.","inherit":[],"name":"java.io.SerialCallbackContext","type":false},{"description":"Serializability of a class is enabled by the class implementing the\r\njava.io.Serializable interface. Classes that do not implement this\r\ninterface will not have any of their state serialized or\r\ndeserialized.  All subtypes of a serializable class are themselves\r\nserializable.  The serialization interface has no methods or fields\r\nand serves only to identify the semantics of being serializable. <p>\r\n\r\nTo allow subtypes of non-serializable classes to be serialized, the\r\nsubtype may assume responsibility for saving and restoring the\r\nstate of the supertype's public, protected, and (if accessible)\r\npackage fields.  The subtype may assume this responsibility only if\r\nthe class it extends has an accessible no-arg constructor to\r\ninitialize the class's state.  It is an error to declare a class\r\nSerializable if this is not the case.  The error will be detected at\r\nruntime. <p>\r\n\r\nDuring deserialization, the fields of non-serializable classes will\r\nbe initialized using the public or protected no-arg constructor of\r\nthe class.  A no-arg constructor must be accessible to the subclass\r\nthat is serializable.  The fields of serializable subclasses will\r\nbe restored from the stream. <p>\r\n\r\nWhen traversing a graph, an object may be encountered that does not\r\nsupport the Serializable interface. In this case the\r\nNotSerializableException will be thrown and will identify the class\r\nof the non-serializable object. <p>\r\n\r\nClasses that require special handling during the serialization and\r\ndeserialization process must implement special methods with these exact\r\nsignatures:\r\n\r\n<PRE>\r\nprivate void writeObject(java.io.ObjectOutputStream out)\r\n    throws IOException\r\nprivate void readObject(java.io.ObjectInputStream in)\r\n    throws IOException, ClassNotFoundException;\r\nprivate void readObjectNoData()\r\n    throws ObjectStreamException;\r\n</PRE>\r\n\r\n<p>The writeObject method is responsible for writing the state of the\r\nobject for its particular class so that the corresponding\r\nreadObject method can restore it.  The default mechanism for saving\r\nthe Object's fields can be invoked by calling\r\nout.defaultWriteObject. The method does not need to concern\r\nitself with the state belonging to its superclasses or subclasses.\r\nState is saved by writing the individual fields to the\r\nObjectOutputStream using the writeObject method or by using the\r\nmethods for primitive data types supported by DataOutput.\r\n\r\n<p>The readObject method is responsible for reading from the stream and\r\nrestoring the classes fields. It may call in.defaultReadObject to invoke\r\nthe default mechanism for restoring the object's non-static and\r\nnon-transient fields.  The defaultReadObject method uses information in\r\nthe stream to assign the fields of the object saved in the stream with the\r\ncorrespondingly named fields in the current object.  This handles the case\r\nwhen the class has evolved to add new fields. The method does not need to\r\nconcern itself with the state belonging to its superclasses or subclasses.\r\nState is saved by writing the individual fields to the\r\nObjectOutputStream using the writeObject method or by using the\r\nmethods for primitive data types supported by DataOutput.\r\n\r\n<p>The readObjectNoData method is responsible for initializing the state of\r\nthe object for its particular class in the event that the serialization\r\nstream does not list the given class as a superclass of the object being\r\ndeserialized.  This may occur in cases where the receiving party uses a\r\ndifferent version of the deserialized instance's class than the sending\r\nparty, and the receiver's version extends classes that are not extended by\r\nthe sender's version.  This may also occur if the serialization stream has\r\nbeen tampered; hence, readObjectNoData is useful for initializing\r\ndeserialized objects properly despite a \"hostile\" or incomplete source\r\nstream.\r\n\r\n<p>Serializable classes that need to designate an alternative object to be\r\nused when writing an object to the stream should implement this\r\nspecial method with the exact signature:\r\n\r\n<PRE>\r\nANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;\r\n</PRE><p>\r\n\r\nThis writeReplace method is invoked by serialization if the method\r\nexists and it would be accessible from a method defined within the\r\nclass of the object being serialized. Thus, the method can have private,\r\nprotected and package-private access. Subclass access to this method\r\nfollows java accessibility rules. <p>\r\n\r\nClasses that need to designate a replacement when an instance of it\r\nis read from the stream should implement this special method with the\r\nexact signature.\r\n\r\n<PRE>\r\nANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;\r\n</PRE><p>\r\n\r\nThis readResolve method follows the same invocation rules and\r\naccessibility rules as writeReplace.<p>\r\n\r\nThe serialization runtime associates with each serializable class a version\r\nnumber, called a serialVersionUID, which is used during deserialization to\r\nverify that the sender and receiver of a serialized object have loaded\r\nclasses for that object that are compatible with respect to serialization.\r\nIf the receiver has loaded a class for the object that has a different\r\nserialVersionUID than that of the corresponding sender's class, then\r\ndeserialization will result in an {@link InvalidClassException}.  A\r\nserializable class can declare its own serialVersionUID explicitly by\r\ndeclaring a field named <code>\"serialVersionUID\"</code> that must be static,\r\nfinal, and of type <code>long</code>:\r\n\r\n<PRE>\r\nANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;\r\n</PRE>\r\n\r\nIf a serializable class does not explicitly declare a serialVersionUID, then\r\nthe serialization runtime will calculate a default serialVersionUID value\r\nfor that class based on various aspects of the class, as described in the\r\nJava(TM) Object Serialization Specification.  However, it is <em>strongly\r\nrecommended</em> that all serializable classes explicitly declare\r\nserialVersionUID values, since the default serialVersionUID computation is\r\nhighly sensitive to class details that may vary depending on compiler\r\nimplementations, and can thus result in unexpected\r\n<code>InvalidClassException</code>s during deserialization.  Therefore, to\r\nguarantee a consistent serialVersionUID value across different java compiler\r\nimplementations, a serializable class must declare an explicit\r\nserialVersionUID value.  It is also strongly advised that explicit\r\nserialVersionUID declarations use the <code>private</code> modifier where\r\npossible, since such declarations apply only to the immediately declaring\r\nclass--serialVersionUID fields are not useful as inherited members. Array\r\nclasses cannot declare an explicit serialVersionUID, so they always have\r\nthe default computed value, but the requirement for matching\r\nserialVersionUID values is waived for array classes.","inherit":[],"name":"java.io.Serializable","type":true},{"description":"","inherit":["java.security.BasicPermission"],"name":"java.io.SerializablePermission","type":false},{"description":"Thrown when control information that was read from an object stream\r\nviolates internal consistency checks.","inherit":["java.io.ObjectStreamException"],"name":"java.io.StreamCorruptedException","type":false},{"description":"","inherit":[],"name":"java.io.StreamTokenizer","type":false},{"description":"This class allows an application to create an input stream in\r\nwhich the bytes read are supplied by the contents of a string.\r\nApplications can also read bytes from a byte array by using a\r\n<code>ByteArrayInputStream</code>.\r\n<p>\r\nOnly the low eight bits of each character in the string are used by\r\nthis class.","inherit":["java.io.InputStream"],"name":"java.io.StringBufferInputStream","type":false},{"description":"","inherit":["java.io.Reader"],"name":"java.io.StringReader","type":false},{"description":"","inherit":["java.io.Writer"],"name":"java.io.StringWriter","type":false},{"description":"Signals that a sync operation has failed.","inherit":["java.io.IOException"],"name":"java.io.SyncFailedException","type":false},{"description":"Wraps an {@link IOException} with an unchecked exception.","inherit":["java.lang.RuntimeException"],"name":"java.io.UncheckedIOException","type":false},{"description":"The Character Encoding is not supported.","inherit":["java.io.IOException"],"name":"java.io.UnsupportedEncodingException","type":false},{"description":"Signals that a malformed string in\r\n<a href=\"DataInput.html#modified-utf-8\">modified UTF-8</a>\r\nformat has been read in a data\r\ninput stream or by any class that implements the data input\r\ninterface.\r\nSee the\r\n<a href=\"DataInput.html#modified-utf-8\"><code>DataInput</code></a>\r\nclass description for the format in\r\nwhich modified UTF-8 strings are read and written.","inherit":["java.io.IOException"],"name":"java.io.UTFDataFormatException","type":false},{"description":"Unicode-aware FileSystem for Windows NT/2000.","inherit":["java.io.FileSystem"],"name":"java.io.WinNTFileSystem","type":false},{"description":"Signals that one of the ObjectStreamExceptions was thrown during a\r\nwrite operation.  Thrown during a read operation when one of the\r\nObjectStreamExceptions was thrown during a write operation.  The\r\nexception that terminated the write can be found in the detail\r\nfield. The stream is reset to it's initial state and all references\r\nto objects already deserialized are discarded.\r\n\r\n<p>As of release 1.4, this exception has been retrofitted to conform to\r\nthe general purpose exception-chaining mechanism.  The \"exception causing\r\nthe abort\" that is provided at construction time and\r\naccessed via the public {@link #detail} field is now known as the\r\n<i>cause</i>, and may be accessed via the {@link Throwable#getCause()}\r\nmethod, as well as the aforementioned \"legacy field.\"","inherit":["java.io.ObjectStreamException"],"name":"java.io.WriteAbortedException","type":false},{"description":"","inherit":["java.lang.Appendable","java.io.Closeable","java.io.Flushable"],"name":"java.io.Writer","type":false},{"description":"Thrown when an application tries to call an abstract method.\r\nNormally, this error is caught by the compiler; this error can\r\nonly occur at run time if the definition of some class has\r\nincompatibly changed since the currently executing method was last\r\ncompiled.","inherit":["java.lang.IncompatibleClassChangeError"],"name":"java.lang.AbstractMethodError","type":false},{"description":"A mutable sequence of characters.\r\n<p>\r\nImplements a modifiable string. At any point in time it contains some\r\nparticular sequence of characters, but the length and content of the\r\nsequence can be changed through certain method calls.\r\n\r\n<p>Unless otherwise noted, passing a {@code null} argument to a constructor\r\nor method in this class will cause a {@link NullPointerException} to be\r\nthrown.","inherit":["java.lang.Appendable","java.lang.CharSequence"],"name":"java.lang.AbstractStringBuilder","type":false},{"description":"The common interface extended by all annotation types.  Note that an\r\ninterface that manually extends this one does <i>not</i> define\r\nan annotation type.  Also note that this interface does not itself\r\ndefine an annotation type.\r\n\r\nMore information about annotation types can be found in section 9.6 of\r\n<cite>The Java&trade; Language Specification</cite>.\r\n\r\nThe {@link java.lang.reflect.AnnotatedElement} interface discusses\r\ncompatibility concerns when evolving an annotation type from being\r\nnon-repeatable to being repeatable.","inherit":[],"name":"java.lang.annotation.Annotation","type":true},{"description":"Thrown when the annotation parser attempts to read an annotation\r\nfrom a class file and determines that the annotation is malformed.\r\nThis error can be thrown by the {@linkplain\r\njava.lang.reflect.AnnotatedElement API used to read annotations\r\nreflectively}.","inherit":["java.lang.Error"],"name":"java.lang.annotation.AnnotationFormatError","type":false},{"description":"Thrown to indicate that a program has attempted to access an element of\r\nan annotation whose type has changed after the annotation was compiled\r\n(or serialized).\r\nThis exception can be thrown by the {@linkplain\r\njava.lang.reflect.AnnotatedElement API used to read annotations\r\nreflectively}.","inherit":["java.lang.RuntimeException"],"name":"java.lang.annotation.AnnotationTypeMismatchException","type":false},{"description":"Thrown to indicate that a program has attempted to access an element of\r\nan annotation type that was added to the annotation type definition after\r\nthe annotation was compiled (or serialized).  This exception will not be\r\nthrown if the new element has a default value.\r\nThis exception can be thrown by the {@linkplain\r\njava.lang.reflect.AnnotatedElement API used to read annotations\r\nreflectively}.","inherit":["java.lang.RuntimeException"],"name":"java.lang.annotation.IncompleteAnnotationException","type":false},{"description":"An object to which <tt>char</tt> sequences and values can be appended.  The\r\n<tt>Appendable</tt> interface must be implemented by any class whose\r\ninstances are intended to receive formatted output from a {@link\r\njava.util.Formatter}.\r\n\r\n<p> The characters to be appended should be valid Unicode characters as\r\ndescribed in <a href=\"Character.html#unicode\">Unicode Character\r\nRepresentation</a>.  Note that supplementary characters may be composed of\r\nmultiple 16-bit <tt>char</tt> values.\r\n\r\n<p> Appendables are not necessarily safe for multithreaded access.  Thread\r\nsafety is the responsibility of classes that extend and implement this\r\ninterface.\r\n\r\n<p> Since this interface may be implemented by existing classes\r\nwith different styles of error handling there is no guarantee that\r\nerrors will be propagated to the invoker.","inherit":[],"name":"java.lang.Appendable","type":true},{"description":"","inherit":[],"name":"java.lang.ApplicationShutdownHooks","type":false},{"description":"Thrown when an exceptional arithmetic condition has occurred. For\r\nexample, an integer \"divide by zero\" throws an\r\ninstance of this class.\r\n\r\n{@code ArithmeticException} objects may be constructed by the\r\nvirtual machine as if {@linkplain Throwable#Throwable(String,\r\nThrowable, boolean, boolean) suppression were disabled and/or the\r\nstack trace was not writable}.","inherit":["java.lang.RuntimeException"],"name":"java.lang.ArithmeticException","type":false},{"description":"Thrown to indicate that an array has been accessed with an\r\nillegal index. The index is either negative or greater than or\r\nequal to the size of the array.","inherit":["java.lang.IndexOutOfBoundsException"],"name":"java.lang.ArrayIndexOutOfBoundsException","type":false},{"description":"Thrown to indicate that an attempt has been made to store the\r\nwrong type of object into an array of objects. For example, the\r\nfollowing code generates an <code>ArrayStoreException</code>:\r\n<blockquote><pre>\r\n    Object x[] = new String[3];\r\n    x[0] = new Integer(0);\r\n</pre></blockquote>","inherit":["java.lang.RuntimeException"],"name":"java.lang.ArrayStoreException","type":false},{"description":"Thrown to indicate that an assertion has failed.\r\n\r\n<p>The seven one-argument public constructors provided by this\r\nclass ensure that the assertion error returned by the invocation:\r\n<pre>\r\n    new AssertionError(<i>expression</i>)\r\n</pre>\r\nhas as its detail message the <i>string conversion</i> of\r\n<i>expression</i> (as defined in section 15.18.1.1 of\r\n<cite>The Java&trade; Language Specification</cite>),\r\nregardless of the type of <i>expression</i>.","inherit":["java.lang.Error"],"name":"java.lang.AssertionError","type":false},{"description":"A collection of assertion status directives (such as \"enable assertions\r\nin package p\" or \"disable assertions in class c\").  This class is used by\r\nthe JVM to communicate the assertion status directives implied by\r\nthe <tt>java</tt> command line flags <tt>-enableassertions</tt>\r\n(<tt>-ea</tt>) and <tt>-disableassertions</tt> (<tt>-da</tt>).","inherit":[],"name":"java.lang.AssertionStatusDirectives","type":false},{"description":"An object that may hold resources (such as file or socket handles)\r\nuntil it is closed. The {@link #close()} method of an {@code AutoCloseable}\r\nobject is called automatically when exiting a {@code\r\ntry}-with-resources block for which the object has been declared in\r\nthe resource specification header. This construction ensures prompt\r\nrelease, avoiding resource exhaustion exceptions and errors that\r\nmay otherwise occur.","inherit":[],"name":"java.lang.AutoCloseable","type":true},{"description":"The Boolean class wraps a value of the primitive type\r\n{@code boolean} in an object. An object of type\r\n{@code Boolean} contains a single field whose type is\r\n{@code boolean}.\r\n<p>\r\nIn addition, this class provides many methods for\r\nconverting a {@code boolean} to a {@code String} and a\r\n{@code String} to a {@code boolean}, as well as other\r\nconstants and methods useful when dealing with a\r\n{@code boolean}.","inherit":["java.io.Serializable","java.lang.Comparable"],"name":"java.lang.Boolean","type":false},{"description":"Thrown to indicate that an {@code invokedynamic} instruction has\r\nfailed to find its bootstrap method,\r\nor the bootstrap method has failed to provide a\r\n{@linkplain java.lang.invoke.CallSite call site} with a {@linkplain java.lang.invoke.CallSite#getTarget target}\r\nof the correct {@linkplain java.lang.invoke.MethodHandle#type method type}.","inherit":["java.lang.LinkageError"],"name":"java.lang.BootstrapMethodError","type":false},{"description":"The {@code Byte} class wraps a value of primitive type {@code byte}\r\nin an object.  An object of type {@code Byte} contains a single\r\nfield whose type is {@code byte}.\r\n\r\n<p>In addition, this class provides several methods for converting\r\na {@code byte} to a {@code String} and a {@code String} to a {@code\r\nbyte}, as well as other constants and methods useful when dealing\r\nwith a {@code byte}.","inherit":["java.lang.Number","java.lang.Comparable"],"name":"java.lang.Byte","type":false},{"description":"","inherit":[],"name":"java.lang.Byte.ByteCache","type":false},{"description":"The {@code Character} class wraps a value of the primitive\r\ntype {@code char} in an object. An object of class\r\n{@code Character} contains a single field whose type is\r\n{@code char}.\r\n<p>\r\nIn addition, this class provides a large number of static methods for\r\ndetermining a character's category (lowercase letter, digit, etc.)\r\nand for converting characters from uppercase to lowercase and vice\r\nversa.\r\n\r\n<h3><a id=\"conformance\">Unicode Conformance</a></h3>\r\n<p>\r\nThe fields and methods of class {@code Character} are defined in terms\r\nof character information from the Unicode Standard, specifically the\r\n<i>UnicodeData</i> file that is part of the Unicode Character Database.\r\nThis file specifies properties including name and category for every\r\nassigned Unicode code point or character range. The file is available\r\nfrom the Unicode Consortium at\r\n<a href=\"http://www.unicode.org\">http://www.unicode.org</a>.\r\n<p>\r\nThe Java SE 8 Platform uses character information from version 6.2\r\nof the Unicode Standard, with two extensions. First, the Java SE 8 Platform\r\nallows an implementation of class {@code Character} to use the Japanese Era\r\ncode point, {@code U+32FF}, from the first version of the Unicode Standard\r\nafter 6.2 that assigns the code point. Second, in recognition of the fact\r\nthat new currencies appear frequently, the Java SE 8 Platform allows an\r\nimplementation of class {@code Character} to use the Currency Symbols\r\nblock from version 10.0 of the Unicode Standard. Consequently, the\r\nbehavior of fields and methods of class {@code Character} may vary across\r\nimplementations of the Java SE 8 Platform when processing the aforementioned\r\ncode points ( outside of version 6.2 ), except for the following methods\r\nthat define Java identifiers:\r\n{@link #isJavaIdentifierStart(int)}, {@link #isJavaIdentifierStart(char)},\r\n{@link #isJavaIdentifierPart(int)}, and {@link #isJavaIdentifierPart(char)}.\r\nCode points in Java identifiers must be drawn from version 6.2 of\r\nthe Unicode Standard.\r\n\r\n<h3><a name=\"unicode\">Unicode Character Representations</a></h3>\r\n\r\n<p>The {@code char} data type (and therefore the value that a\r\n{@code Character} object encapsulates) are based on the\r\noriginal Unicode specification, which defined characters as\r\nfixed-width 16-bit entities. The Unicode Standard has since been\r\nchanged to allow for characters whose representation requires more\r\nthan 16 bits.  The range of legal <em>code point</em>s is now\r\nU+0000 to U+10FFFF, known as <em>Unicode scalar value</em>.\r\n(Refer to the <a\r\nhref=\"http://www.unicode.org/reports/tr27/#notation\"><i>\r\ndefinition</i></a> of the U+<i>n</i> notation in the Unicode\r\nStandard.)\r\n\r\n<p><a name=\"BMP\">The set of characters from U+0000 to U+FFFF</a> is\r\nsometimes referred to as the <em>Basic Multilingual Plane (BMP)</em>.\r\n<a name=\"supplementary\">Characters</a> whose code points are greater\r\nthan U+FFFF are called <em>supplementary character</em>s.  The Java\r\nplatform uses the UTF-16 representation in {@code char} arrays and\r\nin the {@code String} and {@code StringBuffer} classes. In\r\nthis representation, supplementary characters are represented as a pair\r\nof {@code char} values, the first from the <em>high-surrogates</em>\r\nrange, (&#92;uD800-&#92;uDBFF), the second from the\r\n<em>low-surrogates</em> range (&#92;uDC00-&#92;uDFFF).\r\n\r\n<p>A {@code char} value, therefore, represents Basic\r\nMultilingual Plane (BMP) code points, including the surrogate\r\ncode points, or code units of the UTF-16 encoding. An\r\n{@code int} value represents all Unicode code points,\r\nincluding supplementary code points. The lower (least significant)\r\n21 bits of {@code int} are used to represent Unicode code\r\npoints and the upper (most significant) 11 bits must be zero.\r\nUnless otherwise specified, the behavior with respect to\r\nsupplementary characters and surrogate {@code char} values is\r\nas follows:\r\n\r\n<ul>\r\n<li>The methods that only accept a {@code char} value cannot support\r\nsupplementary characters. They treat {@code char} values from the\r\nsurrogate ranges as undefined characters. For example,\r\n{@code Character.isLetter('\\u005CuD840')} returns {@code false}, even though\r\nthis specific value if followed by any low-surrogate value in a string\r\nwould represent a letter.\r\n\r\n<li>The methods that accept an {@code int} value support all\r\nUnicode characters, including supplementary characters. For\r\nexample, {@code Character.isLetter(0x2F81A)} returns\r\n{@code true} because the code point value represents a letter\r\n(a CJK ideograph).\r\n</ul>\r\n\r\n<p>In the Java SE API documentation, <em>Unicode code point</em> is\r\nused for character values in the range between U+0000 and U+10FFFF,\r\nand <em>Unicode code unit</em> is used for 16-bit\r\n{@code char} values that are code units of the <em>UTF-16</em>\r\nencoding. For more information on Unicode terminology, refer to the\r\n<a href=\"http://www.unicode.org/glossary/\">Unicode Glossary</a>.","inherit":["java.io.Serializable","java.lang.Comparable"],"name":"java.lang.Character","type":false},{"description":"Instances of this class represent particular subsets of the Unicode\r\ncharacter set.  The only family of subsets defined in the\r\n{@code Character} class is {@link Character.UnicodeBlock}.\r\nOther portions of the Java API may define other subsets for their\r\nown purposes.","inherit":[],"name":"java.lang.Character.Subset","type":false},{"description":"A family of character subsets representing the character blocks in the\r\nUnicode specification. Character blocks generally define characters\r\nused for a specific script or purpose. A character is contained by\r\nat most one Unicode block.","inherit":["java.lang.Character.Subset"],"name":"java.lang.Character.UnicodeBlock","type":false},{"description":"","inherit":[],"name":"java.lang.Character.CharacterCache","type":false},{"description":"","inherit":[],"name":"java.lang.CharacterData","type":false},{"description":"","inherit":["java.lang.CharacterData"],"name":"java.lang.CharacterData00","type":false},{"description":"","inherit":["java.lang.CharacterData"],"name":"java.lang.CharacterData01","type":false},{"description":"","inherit":["java.lang.CharacterData"],"name":"java.lang.CharacterData02","type":false},{"description":"","inherit":["java.lang.CharacterData"],"name":"java.lang.CharacterData0E","type":false},{"description":"","inherit":["java.lang.CharacterData"],"name":"java.lang.CharacterDataLatin1","type":false},{"description":"","inherit":["java.lang.CharacterData"],"name":"java.lang.CharacterDataPrivateUse","type":false},{"description":"","inherit":["java.lang.CharacterData"],"name":"java.lang.CharacterDataUndefined","type":false},{"description":"","inherit":[],"name":"java.lang.CharacterName","type":false},{"description":"","inherit":[],"name":"java.lang.CharSequence","type":true},{"description":"","inherit":["java.util.PrimitiveIterator.OfInt"],"name":"","type":false},{"description":"","inherit":["java.util.PrimitiveIterator.OfInt"],"name":"","type":false},{"description":"Instances of the class {@code Class} represent classes and\r\ninterfaces in a running Java application.  An enum is a kind of\r\nclass and an annotation is a kind of interface.  Every array also\r\nbelongs to a class that is reflected as a {@code Class} object\r\nthat is shared by all arrays with the same element type and number\r\nof dimensions.  The primitive Java types ({@code boolean},\r\n{@code byte}, {@code char}, {@code short},\r\n{@code int}, {@code long}, {@code float}, and\r\n{@code double}), and the keyword {@code void} are also\r\nrepresented as {@code Class} objects.\r\n\r\n<p> {@code Class} has no public constructor. Instead {@code Class}\r\nobjects are constructed automatically by the Java Virtual Machine as classes\r\nare loaded and by calls to the {@code defineClass} method in the class\r\nloader.\r\n\r\n<p> The following example uses a {@code Class} object to print the\r\nclass name of an object:\r\n\r\n<blockquote><pre>\r\n    void printClassName(Object obj) {\r\n        System.out.println(\"The class of \" + obj +\r\n                           \" is \" + obj.getClass().getName());\r\n    }\r\n</pre></blockquote>\r\n\r\n<p> It is also possible to get the {@code Class} object for a named\r\ntype (or for void) using a class literal.  See Section 15.8.2 of\r\n<cite>The Java&trade; Language Specification</cite>.\r\nFor example:\r\n\r\n<blockquote>\r\n    {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}\r\n</blockquote>","inherit":["java.io.Serializable","java.lang.reflect.GenericDeclaration","java.lang.reflect.Type","java.lang.reflect.AnnotatedElement"],"name":"java.lang.Class","type":false},{"description":"","inherit":[],"name":"java.lang.Class.EnclosingMethodInfo","type":false},{"description":"Atomic operations support.","inherit":[],"name":"java.lang.Class.Atomic","type":false},{"description":"","inherit":[],"name":"java.lang.Class.ReflectionData","type":false},{"description":"","inherit":[],"name":"java.lang.Class.MethodArray","type":false},{"description":"","inherit":[],"name":"java.lang.Class.AnnotationData","type":false},{"description":"Thrown to indicate that the code has attempted to cast an object\r\nto a subclass of which it is not an instance. For example, the\r\nfollowing code generates a <code>ClassCastException</code>:\r\n<blockquote><pre>\r\n    Object x = new Integer(0);\r\n    System.out.println((String)x);\r\n</pre></blockquote>","inherit":["java.lang.RuntimeException"],"name":"java.lang.ClassCastException","type":false},{"description":"Thrown when the Java Virtual Machine detects a circularity in the\r\nsuperclass hierarchy of a class being loaded.","inherit":["java.lang.LinkageError"],"name":"java.lang.ClassCircularityError","type":false},{"description":"Thrown when the Java Virtual Machine attempts to read a class\r\nfile and determines that the file is malformed or otherwise cannot\r\nbe interpreted as a class file.","inherit":["java.lang.LinkageError"],"name":"java.lang.ClassFormatError","type":false},{"description":"A class loader is an object that is responsible for loading classes. The\r\nclass <tt>ClassLoader</tt> is an abstract class.  Given the <a\r\nhref=\"#name\">binary name</a> of a class, a class loader should attempt to\r\nlocate or generate data that constitutes a definition for the class.  A\r\ntypical strategy is to transform the name into a file name and then read a\r\n\"class file\" of that name from a file system.\r\n\r\n<p> Every {@link Class <tt>Class</tt>} object contains a {@link\r\nClass#getClassLoader() reference} to the <tt>ClassLoader</tt> that defined\r\nit.\r\n\r\n<p> <tt>Class</tt> objects for array classes are not created by class\r\nloaders, but are created automatically as required by the Java runtime.\r\nThe class loader for an array class, as returned by {@link\r\nClass#getClassLoader()} is the same as the class loader for its element\r\ntype; if the element type is a primitive type, then the array class has no\r\nclass loader.\r\n\r\n<p> Applications implement subclasses of <tt>ClassLoader</tt> in order to\r\nextend the manner in which the Java virtual machine dynamically loads\r\nclasses.\r\n\r\n<p> Class loaders may typically be used by security managers to indicate\r\nsecurity domains.\r\n\r\n<p> The <tt>ClassLoader</tt> class uses a delegation model to search for\r\nclasses and resources.  Each instance of <tt>ClassLoader</tt> has an\r\nassociated parent class loader.  When requested to find a class or\r\nresource, a <tt>ClassLoader</tt> instance will delegate the search for the\r\nclass or resource to its parent class loader before attempting to find the\r\nclass or resource itself.  The virtual machine's built-in class loader,\r\ncalled the \"bootstrap class loader\", does not itself have a parent but may\r\nserve as the parent of a <tt>ClassLoader</tt> instance.\r\n\r\n<p> Class loaders that support concurrent loading of classes are known as\r\n<em>parallel capable</em> class loaders and are required to register\r\nthemselves at their class initialization time by invoking the\r\n{@link\r\n#registerAsParallelCapable <tt>ClassLoader.registerAsParallelCapable</tt>}\r\nmethod. Note that the <tt>ClassLoader</tt> class is registered as parallel\r\ncapable by default. However, its subclasses still need to register themselves\r\nif they are parallel capable. <br>\r\nIn environments in which the delegation model is not strictly\r\nhierarchical, class loaders need to be parallel capable, otherwise class\r\nloading can lead to deadlocks because the loader lock is held for the\r\nduration of the class loading process (see {@link #loadClass\r\n<tt>loadClass</tt>} methods).\r\n\r\n<p> Normally, the Java virtual machine loads classes from the local file\r\nsystem in a platform-dependent manner.  For example, on UNIX systems, the\r\nvirtual machine loads classes from the directory defined by the\r\n<tt>CLASSPATH</tt> environment variable.\r\n\r\n<p> However, some classes may not originate from a file; they may originate\r\nfrom other sources, such as the network, or they could be constructed by an\r\napplication.  The method {@link #defineClass(String, byte[], int, int)\r\n<tt>defineClass</tt>} converts an array of bytes into an instance of class\r\n<tt>Class</tt>. Instances of this newly defined class can be created using\r\n{@link Class#newInstance <tt>Class.newInstance</tt>}.\r\n\r\n<p> The methods and constructors of objects created by a class loader may\r\nreference other classes.  To determine the class(es) referred to, the Java\r\nvirtual machine invokes the {@link #loadClass <tt>loadClass</tt>} method of\r\nthe class loader that originally created the class.\r\n\r\n<p> For example, an application could create a network class loader to\r\ndownload class files from a server.  Sample code might look like:\r\n\r\n<blockquote><pre>\r\n  ClassLoader loader&nbsp;= new NetworkClassLoader(host,&nbsp;port);\r\n  Object main&nbsp;= loader.loadClass(\"Main\", true).newInstance();\r\n      &nbsp;.&nbsp;.&nbsp;.\r\n</pre></blockquote>\r\n\r\n<p> The network class loader subclass must define the methods {@link\r\n#findClass <tt>findClass</tt>} and <tt>loadClassData</tt> to load a class\r\nfrom the network.  Once it has downloaded the bytes that make up the class,\r\nit should use the method {@link #defineClass <tt>defineClass</tt>} to\r\ncreate a class instance.  A sample implementation is:\r\n\r\n<blockquote><pre>\r\n    class NetworkClassLoader extends ClassLoader {\r\n        String host;\r\n        int port;\r\n\r\n        public Class findClass(String name) {\r\n            byte[] b = loadClassData(name);\r\n            return defineClass(name, b, 0, b.length);\r\n        }\r\n\r\n        private byte[] loadClassData(String name) {\r\n            // load the class data from the connection\r\n            &nbsp;.&nbsp;.&nbsp;.\r\n        }\r\n    }\r\n</pre></blockquote>\r\n\r\n<h3> <a name=\"name\">Binary names</a> </h3>\r\n\r\n<p> Any class name provided as a {@link String} parameter to methods in\r\n<tt>ClassLoader</tt> must be a binary name as defined by\r\n<cite>The Java&trade; Language Specification</cite>.\r\n\r\n<p> Examples of valid class names include:\r\n<blockquote><pre>\r\n  \"java.lang.String\"\r\n  \"javax.swing.JSpinner$DefaultEditor\"\r\n  \"java.security.KeyStore$Builder$FileBuilder$1\"\r\n  \"java.net.URLClassLoader$3$1\"\r\n</pre></blockquote>","inherit":[],"name":"java.lang.ClassLoader","type":false},{"description":"Encapsulates the set of parallel capable loader types.","inherit":[],"name":"java.lang.ClassLoader.ParallelLoaders","type":false},{"description":"The inner class NativeLibrary denotes a loaded native library instance.\r\nEvery classloader contains a vector of loaded native libraries in the\r\nprivate field <tt>nativeLibraries</tt>.  The native libraries loaded\r\ninto the system are entered into the <tt>systemNativeLibraries</tt>\r\nvector.\r\n\r\n<p> Every native library requires a particular version of JNI. This is\r\ndenoted by the private <tt>jniVersion</tt> field.  This field is set by\r\nthe VM when it loads the library, and used by the VM to pass the correct\r\nversion of JNI to the native methods.  </p>","inherit":[],"name":"java.lang.ClassLoader.NativeLibrary","type":false},{"description":"","inherit":["java.security.PrivilegedExceptionAction"],"name":"java.lang.SystemClassLoaderAction","type":false},{"description":"","inherit":[],"name":"java.lang.ClassLoaderHelper","type":false},{"description":"Thrown when an application tries to load in a class through its\r\nstring name using:\r\n<ul>\r\n<li>The <code>forName</code> method in class <code>Class</code>.\r\n<li>The <code>findSystemClass</code> method in class\r\n    <code>ClassLoader</code> .\r\n<li>The <code>loadClass</code> method in class <code>ClassLoader</code>.\r\n</ul>\r\n<p>\r\nbut no definition for the class with the specified name could be found.\r\n\r\n<p>As of release 1.4, this exception has been retrofitted to conform to\r\nthe general purpose exception-chaining mechanism.  The \"optional exception\r\nthat was raised while loading the class\" that may be provided at\r\nconstruction time and accessed via the {@link #getException()} method is\r\nnow known as the <i>cause</i>, and may be accessed via the {@link\r\nThrowable#getCause()} method, as well as the aforementioned \"legacy method.\"","inherit":["java.lang.ReflectiveOperationException"],"name":"java.lang.ClassNotFoundException","type":false},{"description":"Lazily associate a computed value with (potentially) every type.\r\nFor example, if a dynamic language needs to construct a message dispatch\r\ntable for each class encountered at a message send call site,\r\nit can use a {@code ClassValue} to cache information needed to\r\nperform the message send quickly, for each class encountered.","inherit":[],"name":"java.lang.ClassValue","type":false},{"description":"Private key for retrieval of this object from ClassValueMap.","inherit":[],"name":"java.lang.ClassValue.Identity","type":false},{"description":"","inherit":[],"name":"java.lang.ClassValue.Version","type":false},{"description":"One binding of a value to a class via a ClassValue.\r\n States are:<ul>\r\n <li> promise if value == Entry.this\r\n <li> else dead if version == null\r\n <li> else stale if version != classValue.version\r\n <li> else live </ul>\r\n Promises are never put into the cache; they only live in the\r\n backing map while a computeValue call is in flight.\r\n Once an entry goes stale, it can be reset at any time\r\n into the dead state.","inherit":["java.lang.ref.WeakReference"],"name":"java.lang.ClassValue.Entry","type":false},{"description":"A backing map for all ClassValues, relative a single given type.\r\n Gives a fully serialized \"true state\" for each pair (ClassValue cv, Class type).\r\n Also manages an unserialized fast-path cache.","inherit":["java.util.WeakHashMap"],"name":"java.lang.ClassValue.ClassValueMap","type":false},{"description":"A class implements the <code>Cloneable</code> interface to\r\nindicate to the {@link java.lang.Object#clone()} method that it\r\nis legal for that method to make a\r\nfield-for-field copy of instances of that class.\r\n<p>\r\nInvoking Object's clone method on an instance that does not implement the\r\n<code>Cloneable</code> interface results in the exception\r\n<code>CloneNotSupportedException</code> being thrown.\r\n<p>\r\nBy convention, classes that implement this interface should override\r\n<tt>Object.clone</tt> (which is protected) with a public method.\r\nSee {@link java.lang.Object#clone()} for details on overriding this\r\nmethod.\r\n<p>\r\nNote that this interface does <i>not</i> contain the <tt>clone</tt> method.\r\nTherefore, it is not possible to clone an object merely by virtue of the\r\nfact that it implements this interface.  Even if the clone method is invoked\r\nreflectively, there is no guarantee that it will succeed.","inherit":[],"name":"java.lang.Cloneable","type":true},{"description":"","inherit":["java.lang.Exception"],"name":"java.lang.CloneNotSupportedException","type":false},{"description":"This interface imposes a total ordering on the objects of each class that\r\nimplements it.  This ordering is referred to as the class's <i>natural\r\nordering</i>, and the class's <tt>compareTo</tt> method is referred to as\r\nits <i>natural comparison method</i>.<p>\r\n\r\nLists (and arrays) of objects that implement this interface can be sorted\r\nautomatically by {@link Collections#sort(List) Collections.sort} (and\r\n{@link Arrays#sort(Object[]) Arrays.sort}).  Objects that implement this\r\ninterface can be used as keys in a {@linkplain SortedMap sorted map} or as\r\nelements in a {@linkplain SortedSet sorted set}, without the need to\r\nspecify a {@linkplain Comparator comparator}.<p>\r\n\r\nThe natural ordering for a class <tt>C</tt> is said to be <i>consistent\r\nwith equals</i> if and only if <tt>e1.compareTo(e2) == 0</tt> has\r\nthe same boolean value as <tt>e1.equals(e2)</tt> for every\r\n<tt>e1</tt> and <tt>e2</tt> of class <tt>C</tt>.  Note that <tt>null</tt>\r\nis not an instance of any class, and <tt>e.compareTo(null)</tt> should\r\nthrow a <tt>NullPointerException</tt> even though <tt>e.equals(null)</tt>\r\nreturns <tt>false</tt>.<p>\r\n\r\nIt is strongly recommended (though not required) that natural orderings be\r\nconsistent with equals.  This is so because sorted sets (and sorted maps)\r\nwithout explicit comparators behave \"strangely\" when they are used with\r\nelements (or keys) whose natural ordering is inconsistent with equals.  In\r\nparticular, such a sorted set (or sorted map) violates the general contract\r\nfor set (or map), which is defined in terms of the <tt>equals</tt>\r\nmethod.<p>\r\n\r\nFor example, if one adds two keys <tt>a</tt> and <tt>b</tt> such that\r\n{@code (!a.equals(b) && a.compareTo(b) == 0)} to a sorted\r\nset that does not use an explicit comparator, the second <tt>add</tt>\r\noperation returns false (and the size of the sorted set does not increase)\r\nbecause <tt>a</tt> and <tt>b</tt> are equivalent from the sorted set's\r\nperspective.<p>\r\n\r\nVirtually all Java core classes that implement <tt>Comparable</tt> have natural\r\norderings that are consistent with equals.  One exception is\r\n<tt>java.math.BigDecimal</tt>, whose natural ordering equates\r\n<tt>BigDecimal</tt> objects with equal values and different precisions\r\n(such as 4.0 and 4.00).<p>\r\n\r\nFor the mathematically inclined, the <i>relation</i> that defines\r\nthe natural ordering on a given class C is:<pre>\r\n      {(x, y) such that x.compareTo(y) &lt;= 0}.\r\n</pre> The <i>quotient</i> for this total order is: <pre>\r\n      {(x, y) such that x.compareTo(y) == 0}.\r\n</pre>\r\n\r\nIt follows immediately from the contract for <tt>compareTo</tt> that the\r\nquotient is an <i>equivalence relation</i> on <tt>C</tt>, and that the\r\nnatural ordering is a <i>total order</i> on <tt>C</tt>.  When we say that a\r\nclass's natural ordering is <i>consistent with equals</i>, we mean that the\r\nquotient for the natural ordering is the equivalence relation defined by\r\nthe class's {@link Object#equals(Object) equals(Object)} method:<pre>\r\n    {(x, y) such that x.equals(y)}. </pre><p>\r\n\r\nThis interface is a member of the\r\n<a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\r\nJava Collections Framework</a>.","inherit":[],"name":"java.lang.Comparable","type":true},{"description":"The {@code Compiler} class is provided to support Java-to-native-code\r\ncompilers and related services. By design, the {@code Compiler} class does\r\nnothing; it serves as a placeholder for a JIT compiler implementation.\r\n\r\n<p> When the Java Virtual Machine first starts, it determines if the system\r\nproperty {@code java.compiler} exists. (System properties are accessible\r\nthrough {@link System#getProperty(String)} and {@link\r\nSystem#getProperty(String, String)}.  If so, it is assumed to be the name of\r\na library (with a platform-dependent exact location and type); {@link\r\nSystem#loadLibrary} is called to load that library. If this loading\r\nsucceeds, the function named {@code java_lang_Compiler_start()} in that\r\nlibrary is called.\r\n\r\n<p> If no compiler is available, these methods do nothing.","inherit":[],"name":"java.lang.Compiler","type":false},{"description":"This is a utility class for <code>String.toLowerCase()</code> and\r\n<code>String.toUpperCase()</code>, that handles special casing with\r\nconditions.  In other words, it handles the mappings with conditions\r\nthat are defined in\r\n<a href=\"http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt\">Special\r\nCasing Properties</a> file.\r\n<p>\r\nNote that the unconditional case mappings (including 1:M mappings)\r\nare handled in <code>Character.toLower/UpperCase()</code>.","inherit":[],"name":"java.lang.ConditionalSpecialCasing","type":false},{"description":"An internal class that represents an entry in the Special Casing Properties.","inherit":[],"name":"java.lang.ConditionalSpecialCasing.Entry","type":false},{"description":"The {@code Double} class wraps a value of the primitive type\r\n{@code double} in an object. An object of type\r\n{@code Double} contains a single field whose type is\r\n{@code double}.\r\n\r\n<p>In addition, this class provides several methods for converting a\r\n{@code double} to a {@code String} and a\r\n{@code String} to a {@code double}, as well as other\r\nconstants and methods useful when dealing with a\r\n{@code double}.","inherit":["java.lang.Number","java.lang.Comparable"],"name":"java.lang.Double","type":false},{"description":"This is the common base class of all Java language enumeration types.\r\n\r\nMore information about enums, including descriptions of the\r\nimplicitly declared methods synthesized by the compiler, can be\r\nfound in section 8.9 of\r\n<cite>The Java&trade; Language Specification</cite>.\r\n\r\n<p> Note that when using an enumeration type as the type of a set\r\nor as the type of the keys in a map, specialized and efficient\r\n{@linkplain java.util.EnumSet set} and {@linkplain\r\njava.util.EnumMap map} implementations are available.","inherit":["java.lang.Comparable","java.io.Serializable"],"name":"java.lang.Enum","type":false},{"description":"Thrown when an application tries to access an enum constant by name\r\nand the enum type contains no constant with the specified name.\r\nThis exception can be thrown by the {@linkplain\r\njava.lang.reflect.AnnotatedElement API used to read annotations\r\nreflectively}.","inherit":["java.lang.RuntimeException"],"name":"java.lang.EnumConstantNotPresentException","type":false},{"description":"An {@code Error} is a subclass of {@code Throwable}\r\nthat indicates serious problems that a reasonable application\r\nshould not try to catch. Most such errors are abnormal conditions.\r\nThe {@code ThreadDeath} error, though a \"normal\" condition,\r\nis also a subclass of {@code Error} because most applications\r\nshould not try to catch it.\r\n<p>\r\nA method is not required to declare in its {@code throws}\r\nclause any subclasses of {@code Error} that might be thrown\r\nduring the execution of the method but not caught, since these\r\nerrors are abnormal conditions that should never occur.\r\n\r\nThat is, {@code Error} and its subclasses are regarded as unchecked\r\nexceptions for the purposes of compile-time checking of exceptions.","inherit":["java.lang.Throwable"],"name":"java.lang.Error","type":false},{"description":"The class {@code Exception} and its subclasses are a form of\r\n{@code Throwable} that indicates conditions that a reasonable\r\napplication might want to catch.\r\n\r\n<p>The class {@code Exception} and any subclasses that are not also\r\nsubclasses of {@link RuntimeException} are <em>checked\r\nexceptions</em>.  Checked exceptions need to be declared in a\r\nmethod or constructor's {@code throws} clause if they can be thrown\r\nby the execution of the method or constructor and propagate outside\r\nthe method or constructor boundary.","inherit":["java.lang.Throwable"],"name":"java.lang.Exception","type":false},{"description":"Signals that an unexpected exception has occurred in a static initializer.\r\nAn <code>ExceptionInInitializerError</code> is thrown to indicate that an\r\nexception occurred during evaluation of a static initializer or the\r\ninitializer for a static variable.\r\n\r\n<p>As of release 1.4, this exception has been retrofitted to conform to\r\nthe general purpose exception-chaining mechanism.  The \"saved throwable\r\nobject\" that may be provided at construction time and accessed via\r\nthe {@link #getException()} method is now known as the <i>cause</i>,\r\nand may be accessed via the {@link Throwable#getCause()} method, as well\r\nas the aforementioned \"legacy method.\"","inherit":["java.lang.LinkageError"],"name":"java.lang.ExceptionInInitializerError","type":false},{"description":"The {@code Float} class wraps a value of primitive type\r\n{@code float} in an object. An object of type\r\n{@code Float} contains a single field whose type is\r\n{@code float}.\r\n\r\n<p>In addition, this class provides several methods for converting a\r\n{@code float} to a {@code String} and a\r\n{@code String} to a {@code float}, as well as other\r\nconstants and methods useful when dealing with a\r\n{@code float}.","inherit":["java.lang.Number","java.lang.Comparable"],"name":"java.lang.Float","type":false},{"description":"Thrown if an application attempts to access or modify a field, or\r\nto call a method that it does not have access to.\r\n<p>\r\nNormally, this error is caught by the compiler; this error can\r\nonly occur at run time if the definition of a class has\r\nincompatibly changed.","inherit":["java.lang.IncompatibleClassChangeError"],"name":"java.lang.IllegalAccessError","type":false},{"description":"An IllegalAccessException is thrown when an application tries\r\nto reflectively create an instance (other than an array),\r\nset or get a field, or invoke a method, but the currently\r\nexecuting method does not have access to the definition of\r\nthe specified class, field, method or constructor.","inherit":["java.lang.ReflectiveOperationException"],"name":"java.lang.IllegalAccessException","type":false},{"description":"Thrown to indicate that a method has been passed an illegal or\r\ninappropriate argument.","inherit":["java.lang.RuntimeException"],"name":"java.lang.IllegalArgumentException","type":false},{"description":"Thrown to indicate that a thread has attempted to wait on an\r\nobject's monitor or to notify other threads waiting on an object's\r\nmonitor without owning the specified monitor.","inherit":["java.lang.RuntimeException"],"name":"java.lang.IllegalMonitorStateException","type":false},{"description":"Signals that a method has been invoked at an illegal or\r\ninappropriate time.  In other words, the Java environment or\r\nJava application is not in an appropriate state for the requested\r\noperation.","inherit":["java.lang.RuntimeException"],"name":"java.lang.IllegalStateException","type":false},{"description":"Thrown to indicate that a thread is not in an appropriate state\r\nfor the requested operation. See, for example, the\r\n<code>suspend</code> and <code>resume</code> methods in class\r\n<code>Thread</code>.","inherit":["java.lang.IllegalArgumentException"],"name":"java.lang.IllegalThreadStateException","type":false},{"description":"Thrown when an incompatible class change has occurred to some class\r\ndefinition. The definition of some class, on which the currently\r\nexecuting method depends, has since changed.","inherit":["java.lang.LinkageError"],"name":"java.lang.IncompatibleClassChangeError","type":false},{"description":"Thrown to indicate that an index of some sort (such as to an array, to a\r\nstring, or to a vector) is out of range.\r\n<p>\r\nApplications can subclass this class to indicate similar exceptions.","inherit":["java.lang.RuntimeException"],"name":"java.lang.IndexOutOfBoundsException","type":false},{"description":"","inherit":["java.lang.ThreadLocal"],"name":"java.lang.InheritableThreadLocal","type":false},{"description":"","inherit":["java.lang.IncompatibleClassChangeError"],"name":"java.lang.InstantiationError","type":false},{"description":"Thrown when an application tries to create an instance of a class\r\nusing the {@code newInstance} method in class\r\n{@code Class}, but the specified class object cannot be\r\ninstantiated.  The instantiation can fail for a variety of\r\nreasons including but not limited to:\r\n\r\n<ul>\r\n<li> the class object represents an abstract class, an interface,\r\n     an array class, a primitive type, or {@code void}\r\n<li> the class has no nullary constructor\r\n</ul>","inherit":["java.lang.ReflectiveOperationException"],"name":"java.lang.InstantiationException","type":false},{"description":"This class serves as a parameter block to the <code>Instrumentation.redefineClasses</code> method.\r\nServes to bind the <code>Class</code> that needs redefining together with the new class file bytes.","inherit":[],"name":"java.lang.instrument.ClassDefinition","type":false},{"description":"","inherit":[],"name":"java.lang.instrument.ClassFileTransformer","type":true},{"description":"Thrown by an implementation of\r\n{@link java.lang.instrument.ClassFileTransformer#transform ClassFileTransformer.transform}\r\nwhen its input parameters are invalid.\r\nThis may occur either because the initial class file bytes were\r\ninvalid or a previously applied transform corrupted the bytes.","inherit":["java.lang.Exception"],"name":"java.lang.instrument.IllegalClassFormatException","type":false},{"description":"This class provides services needed to instrument Java\r\nprogramming language code.\r\nInstrumentation is the addition of byte-codes to methods for the\r\npurpose of gathering data to be utilized by tools.\r\nSince the changes are purely additive, these tools do not modify\r\napplication state or behavior.\r\nExamples of such benign tools include monitoring agents, profilers,\r\ncoverage analyzers, and event loggers.\r\n\r\n<P>\r\nThere are two ways to obtain an instance of the\r\n<code>Instrumentation</code> interface:\r\n\r\n<ol>\r\n  <li><p> When a JVM is launched in a way that indicates an agent\r\n    class. In that case an <code>Instrumentation</code> instance\r\n    is passed to the <code>premain</code> method of the agent class.\r\n    </p></li>\r\n  <li><p> When a JVM provides a mechanism to start agents sometime\r\n    after the JVM is launched. In that case an <code>Instrumentation</code>\r\n    instance is passed to the <code>agentmain</code> method of the\r\n    agent code. </p> </li>\r\n</ol>\r\n<p>\r\nThese mechanisms are described in the\r\n{@linkplain java.lang.instrument package specification}.\r\n<p>\r\nOnce an agent acquires an <code>Instrumentation</code> instance,\r\nthe agent may call methods on the instance at any time.","inherit":[],"name":"java.lang.instrument.Instrumentation","type":true},{"description":"Thrown by an implementation of\r\n{@link java.lang.instrument.Instrumentation#redefineClasses Instrumentation.redefineClasses}\r\nwhen one of the specified classes cannot be modified.","inherit":["java.lang.Exception"],"name":"java.lang.instrument.UnmodifiableClassException","type":false},{"description":"The {@code Integer} class wraps a value of the primitive type\r\n{@code int} in an object. An object of type {@code Integer}\r\ncontains a single field whose type is {@code int}.\r\n\r\n<p>In addition, this class provides several methods for converting\r\nan {@code int} to a {@code String} and a {@code String} to an\r\n{@code int}, as well as other constants and methods useful when\r\ndealing with an {@code int}.\r\n\r\n<p>Implementation note: The implementations of the \"bit twiddling\"\r\nmethods (such as {@link #highestOneBit(int) highestOneBit} and\r\n{@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\r\nbased on material from Henry S. Warren, Jr.'s <i>Hacker's\r\nDelight</i>, (Addison Wesley, 2002).","inherit":["java.lang.Number","java.lang.Comparable"],"name":"java.lang.Integer","type":false},{"description":"","inherit":[],"name":"java.lang.Integer.IntegerCache","type":false},{"description":"Thrown to indicate some unexpected internal error has occurred in\r\nthe Java Virtual Machine.","inherit":["java.lang.VirtualMachineError"],"name":"java.lang.InternalError","type":false},{"description":"Thrown when a thread is waiting, sleeping, or otherwise occupied,\r\nand the thread is interrupted, either before or during the activity.\r\nOccasionally a method may wish to test whether the current\r\nthread has been interrupted, and if so, to immediately throw\r\nthis exception.  The following code can be used to achieve\r\nthis effect:\r\n<pre>\r\n if (Thread.interrupted())  // Clears interrupted status!\r\n     throw new InterruptedException();\r\n</pre>","inherit":["java.lang.Exception"],"name":"java.lang.InterruptedException","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.AbstractValidatingLambdaMetafactory","type":false},{"description":"","inherit":["java.lang.invoke.MethodHandle"],"name":"java.lang.invoke.BoundMethodHandle","type":false},{"description":"","inherit":["java.lang.invoke.BoundMethodHandle"],"name":"java.lang.invoke.BoundMethodHandle.Species_L","type":false},{"description":"Meta-data wrapper for concrete BMH types.\r\nEach BMH type corresponds to a given sequence of basic field types (LIJFD).\r\nThe fields are immutable; their values are fully specified at object construction.\r\nEach BMH type supplies an array of getter functions which may be used in lambda forms.\r\nA BMH is constructed by cloning a shorter BMH and adding one or more new field values.\r\nThe shortest possible BMH has zero fields; its class is SimpleMethodHandle.\r\nBMH species are not interrelated by subtyping, even though it would appear that\r\na shorter BMH could serve as a supertype of a longer one which extends it.","inherit":[],"name":"java.lang.invoke.BoundMethodHandle.SpeciesData","type":false},{"description":"Generation of concrete BMH classes.\r\n\r\nA concrete BMH species is fit for binding a number of values adhering to a\r\ngiven type pattern. Reference types are erased.\r\n\r\nBMH species are cached by type pattern.\r\n\r\nA BMH species has a number of fields with the concrete (possibly erased) types of\r\nbound values. Setters are provided as an API in BMH. Getters are exposed as MHs,\r\nwhich can be included as names in lambda forms.","inherit":[],"name":"java.lang.invoke.BoundMethodHandle.Factory","type":false},{"description":"A {@code CallSite} is a holder for a variable {@link MethodHandle},\r\nwhich is called its {@code target}.\r\nAn {@code invokedynamic} instruction linked to a {@code CallSite} delegates\r\nall calls to the site's current target.\r\nA {@code CallSite} may be associated with several {@code invokedynamic}\r\ninstructions, or it may be \"free floating\", associated with none.\r\nIn any case, it may be invoked through an associated method handle\r\ncalled its {@linkplain #dynamicInvoker dynamic invoker}.\r\n<p>\r\n{@code CallSite} is an abstract class which does not allow\r\ndirect subclassing by users.  It has three immediate,\r\nconcrete subclasses that may be either instantiated or subclassed.\r\n<ul>\r\n<li>If a mutable target is not required, an {@code invokedynamic} instruction\r\nmay be permanently bound by means of a {@linkplain ConstantCallSite constant call site}.\r\n<li>If a mutable target is required which has volatile variable semantics,\r\nbecause updates to the target must be immediately and reliably witnessed by other threads,\r\na {@linkplain VolatileCallSite volatile call site} may be used.\r\n<li>Otherwise, if a mutable target is required,\r\na {@linkplain MutableCallSite mutable call site} may be used.\r\n</ul>\r\n<p>\r\nA non-constant call site may be <em>relinked</em> by changing its target.\r\nThe new target must have the same {@linkplain MethodHandle#type() type}\r\nas the previous target.\r\nThus, though a call site can be relinked to a series of\r\nsuccessive targets, it cannot change its type.\r\n<p>\r\nHere is a sample use of call sites and bootstrap methods which links every\r\ndynamic call site to print its arguments:\r\n<blockquote><pre>{@code\r\nstatic void test() throws Throwable {\r\n    // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION\r\n    InvokeDynamic[#bootstrapDynamic].baz(\"baz arg\", 2, 3.14);\r\n}\r\nprivate static void printArgs(Object... args) {\r\n  System.out.println(java.util.Arrays.deepToString(args));\r\n}\r\nprivate static final MethodHandle printArgs;\r\nstatic {\r\n  MethodHandles.Lookup lookup = MethodHandles.lookup();\r\n  Class thisClass = lookup.lookupClass();  // (who am I?)\r\n  printArgs = lookup.findStatic(thisClass,\r\n      \"printArgs\", MethodType.methodType(void.class, Object[].class));\r\n}\r\nprivate static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {\r\n  // ignore caller and name, but match the type:\r\n  return new ConstantCallSite(printArgs.asType(type));\r\n}\r\n}</pre></blockquote>","inherit":[],"name":"java.lang.invoke.CallSite","type":false},{"description":"A {@code ConstantCallSite} is a {@link CallSite} whose target is permanent, and can never be changed.\r\nAn {@code invokedynamic} instruction linked to a {@code ConstantCallSite} is permanently\r\nbound to the call site's target.","inherit":["java.lang.invoke.CallSite"],"name":"java.lang.invoke.ConstantCallSite","type":false},{"description":"","inherit":["java.lang.invoke.MethodHandle"],"name":"java.lang.invoke.DelegatingMethodHandle","type":false},{"description":"The flavor of method handle which implements a constant reference\r\nto a class member.","inherit":["java.lang.invoke.MethodHandle"],"name":"java.lang.invoke.DirectMethodHandle","type":false},{"description":"","inherit":["java.lang.ClassValue"],"name":"java.lang.invoke.DirectMethodHandle.EnsureInitialized","type":false},{"description":"This subclass represents invokespecial instructions.","inherit":["java.lang.invoke.DirectMethodHandle"],"name":"java.lang.invoke.DirectMethodHandle.Special","type":false},{"description":"This subclass represents invokeinterface instructions.","inherit":["java.lang.invoke.DirectMethodHandle"],"name":"java.lang.invoke.DirectMethodHandle.Interface","type":false},{"description":"This subclass handles constructor references.","inherit":["java.lang.invoke.DirectMethodHandle"],"name":"java.lang.invoke.DirectMethodHandle.Constructor","type":false},{"description":"This subclass handles non-static field references.","inherit":["java.lang.invoke.DirectMethodHandle"],"name":"java.lang.invoke.DirectMethodHandle.Accessor","type":false},{"description":"This subclass handles static field references.","inherit":["java.lang.invoke.DirectMethodHandle"],"name":"java.lang.invoke.DirectMethodHandle.StaticAccessor","type":false},{"description":"Pre-initialized NamedFunctions for bootstrapping purposes.\r\nFactored in an inner class to delay initialization until first usage.","inherit":[],"name":"java.lang.invoke.DirectMethodHandle.Lazy","type":false},{"description":"","inherit":["java.lang.invoke.MethodHandleInfo"],"name":"java.lang.invoke.InfoFromMemberName","type":false},{"description":"","inherit":["java.lang.invoke.AbstractValidatingLambdaMetafactory"],"name":"java.lang.invoke.InnerClassLambdaMetafactory","type":false},{"description":"This class generates a method body which calls the lambda implementation\r\nmethod, converting arguments, as needed.","inherit":["java.lang.invoke.TypeConvertingMethodAdapter"],"name":"java.lang.invoke.InnerClassLambdaMetafactory.ForwardingMethodGenerator","type":false},{"description":"This is a place-holder class.  Some HotSpot implementations need to see it.","inherit":[],"name":"java.lang.invoke.InvokeDynamic","type":false},{"description":"Code generation backend for LambdaForm.\r\n<p>","inherit":[],"name":"java.lang.invoke.InvokerBytecodeGenerator","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.InvokerBytecodeGenerator.CpPatch","type":false},{"description":"Construction and caching of often-used invokers.","inherit":[],"name":"java.lang.invoke.Invokers","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.Invokers.Lazy","type":false},{"description":"LambdaConversionException","inherit":["java.lang.Exception"],"name":"java.lang.invoke.LambdaConversionException","type":false},{"description":"The symbolic, non-executable form of a method handle's invocation semantics.\r\nIt consists of a series of names.\r\nThe first N (N=arity) names are parameters,\r\nwhile any remaining names are temporary values.\r\nEach temporary specifies the application of a function to some arguments.\r\nThe functions are method handles, while the arguments are mixes of\r\nconstant values and local names.\r\nThe result of the lambda is defined as one of the names, often the last one.\r\n<p>\r\nHere is an approximate grammar:\r\n<blockquote><pre>{@code\r\nLambdaForm = \"(\" ArgName* \")=>{\" TempName* Result \"}\"\r\nArgName = \"a\" N \":\" T\r\nTempName = \"t\" N \":\" T \"=\" Function \"(\" Argument* \");\"\r\nFunction = ConstantValue\r\nArgument = NameRef | ConstantValue\r\nResult = NameRef | \"void\"\r\nNameRef = \"a\" N | \"t\" N\r\nN = (any whole number)\r\nT = \"L\" | \"I\" | \"J\" | \"F\" | \"D\" | \"V\"\r\n}</pre></blockquote>\r\nNames are numbered consecutively from left to right starting at zero.\r\n(The letters are merely a taste of syntax sugar.)\r\nThus, the first temporary (if any) is always numbered N (where N=arity).\r\nEvery occurrence of a name reference in an argument list must refer to\r\na name previously defined within the same lambda.\r\nA lambda has a void result if and only if its result index is -1.\r\nIf a temporary has the type \"V\", it cannot be the subject of a NameRef,\r\neven though possesses a number.\r\nNote that all reference types are erased to \"L\", which stands for {@code Object}.\r\nAll subword types (boolean, byte, short, char) are erased to \"I\" which is {@code int}.\r\nThe other types stand for the usual primitive types.\r\n<p>\r\nFunction invocation closely follows the static rules of the Java verifier.\r\nArguments and return values must exactly match when their \"Name\" types are\r\nconsidered.\r\nConversions are allowed only if they do not change the erased type.\r\n<ul>\r\n<li>L = Object: casts are used freely to convert into and out of reference types\r\n<li>I = int: subword types are forcibly narrowed when passed as arguments (see {@code explicitCastArguments})\r\n<li>J = long: no implicit conversions\r\n<li>F = float: no implicit conversions\r\n<li>D = double: no implicit conversions\r\n<li>V = void: a function result may be void if and only if its Name is of type \"V\"\r\n</ul>\r\nAlthough implicit conversions are not allowed, explicit ones can easily be\r\nencoded by using temporary expressions which call type-transformed identity functions.\r\n<p>\r\nExamples:\r\n<blockquote><pre>{@code\r\n(a0:J)=>{ a0 }\r\n    == identity(long)\r\n(a0:I)=>{ t1:V = System.out#println(a0); void }\r\n    == System.out#println(int)\r\n(a0:L)=>{ t1:V = System.out#println(a0); a0 }\r\n    == identity, with printing side-effect\r\n(a0:L, a1:L)=>{ t2:L = BoundMethodHandle#argument(a0);\r\n                t3:L = BoundMethodHandle#target(a0);\r\n                t4:L = MethodHandle#invoke(t3, t2, a1); t4 }\r\n    == general invoker for unary insertArgument combination\r\n(a0:L, a1:L)=>{ t2:L = FilterMethodHandle#filter(a0);\r\n                t3:L = MethodHandle#invoke(t2, a1);\r\n                t4:L = FilterMethodHandle#target(a0);\r\n                t5:L = MethodHandle#invoke(t4, t3); t5 }\r\n    == general invoker for unary filterArgument combination\r\n(a0:L, a1:L)=>{ ...(same as previous example)...\r\n                t5:L = MethodHandle#invoke(t4, t3, a1); t5 }\r\n    == general invoker for unary/unary foldArgument combination\r\n(a0:L, a1:I)=>{ t2:I = identity(long).asType((int)->long)(a1); t2 }\r\n    == invoker for identity method handle which performs i2l\r\n(a0:L, a1:L)=>{ t2:L = BoundMethodHandle#argument(a0);\r\n                t3:L = Class#cast(t2,a1); t3 }\r\n    == invoker for identity method handle which performs cast\r\n}</pre></blockquote>\r\n<p>","inherit":[],"name":"java.lang.invoke.LambdaForm","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.LambdaForm.NamedFunction","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.LambdaForm.Name","type":false},{"description":"Working storage for an LF that is being transformed.\r\n Similarly to a StringBuffer, the editing can take place in multiple steps.","inherit":[],"name":"java.lang.invoke.LambdaFormBuffer","type":false},{"description":"Transforms on LFs.\r\n A lambda-form editor can derive new LFs from its base LF.\r\n The editor can cache derived LFs, which simplifies the reuse of their underlying bytecodes.\r\n To support this caching, a LF has an optional pointer to its editor.","inherit":[],"name":"java.lang.invoke.LambdaFormEditor","type":false},{"description":"A description of a cached transform, possibly associated with the result of the transform.\r\n The logical content is a sequence of byte values, starting with a Kind.ordinal value.\r\n The sequence is unterminated, ending with an indefinite number of zero bytes.\r\n Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.","inherit":["java.lang.ref.SoftReference"],"name":"java.lang.invoke.LambdaFormEditor.Transform","type":false},{"description":"<p>Methods to facilitate the creation of simple \"function objects\" that\r\nimplement one or more interfaces by delegation to a provided {@link MethodHandle},\r\npossibly after type adaptation and partial evaluation of arguments.  These\r\nmethods are typically used as <em>bootstrap methods</em> for {@code invokedynamic}\r\ncall sites, to support the <em>lambda expression</em> and <em>method\r\nreference expression</em> features of the Java Programming Language.\r\n\r\n<p>Indirect access to the behavior specified by the provided {@code MethodHandle}\r\nproceeds in order through three phases:\r\n<ul>\r\n    <li><em>Linkage</em> occurs when the methods in this class are invoked.\r\n    They take as arguments an interface to be implemented (typically a\r\n    <em>functional interface</em>, one with a single abstract method), a\r\n    name and signature of a method from that interface to be implemented, a\r\n    method handle describing the desired implementation behavior\r\n    for that method, and possibly other additional metadata, and produce a\r\n    {@link CallSite} whose target can be used to create suitable function\r\n    objects.  Linkage may involve dynamically loading a new class that\r\n    implements the target interface. The {@code CallSite} can be considered a\r\n    \"factory\" for function objects and so these linkage methods are referred\r\n    to as \"metafactories\".</li>\r\n\r\n    <li><em>Capture</em> occurs when the {@code CallSite}'s target is\r\n    invoked, typically through an {@code invokedynamic} call site,\r\n    producing a function object.  This may occur many times for\r\n    a single factory {@code CallSite}.  Capture may involve allocation of a\r\n    new function object, or may return an existing function object.  The\r\n    behavior {@code MethodHandle} may have additional parameters beyond those\r\n    of the specified interface method; these are referred to as <em>captured\r\n    parameters</em>, which must be provided as arguments to the\r\n    {@code CallSite} target, and which may be early-bound to the behavior\r\n    {@code MethodHandle}.  The number of captured parameters and their types\r\n    are determined during linkage.</li>\r\n\r\n    <li><em>Invocation</em> occurs when an implemented interface method\r\n    is invoked on a function object.  This may occur many times for a single\r\n    function object.  The method referenced by the behavior {@code MethodHandle}\r\n    is invoked with the captured arguments and any additional arguments\r\n    provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.</li>\r\n</ul>\r\n\r\n<p>It is sometimes useful to restrict the set of inputs or results permitted\r\nat invocation.  For example, when the generic interface {@code Predicate<T>}\r\nis parameterized as {@code Predicate<String>}, the input must be a\r\n{@code String}, even though the method to implement allows any {@code Object}.\r\nAt linkage time, an additional {@link MethodType} parameter describes the\r\n\"instantiated\" method type; on invocation, the arguments and eventual result\r\nare checked against this {@code MethodType}.\r\n\r\n<p>This class provides two forms of linkage methods: a standard version\r\n({@link #metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)})\r\nusing an optimized protocol, and an alternate version\r\n{@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}).\r\nThe alternate version is a generalization of the standard version, providing\r\nadditional control over the behavior of the generated function objects via\r\nflags and additional arguments.  The alternate version adds the ability to\r\nmanage the following attributes of function objects:\r\n\r\n<ul>\r\n    <li><em>Bridging.</em>  It is sometimes useful to implement multiple\r\n    variations of the method signature, involving argument or return type\r\n    adaptation.  This occurs when multiple distinct VM signatures for a method\r\n    are logically considered to be the same method by the language.  The\r\n    flag {@code FLAG_BRIDGES} indicates that a list of additional\r\n    {@code MethodType}s will be provided, each of which will be implemented\r\n    by the resulting function object.  These methods will share the same\r\n    name and instantiated type.</li>\r\n\r\n    <li><em>Multiple interfaces.</em>  If needed, more than one interface\r\n    can be implemented by the function object.  (These additional interfaces\r\n    are typically marker interfaces with no methods.)  The flag {@code FLAG_MARKERS}\r\n    indicates that a list of additional interfaces will be provided, each of\r\n    which should be implemented by the resulting function object.</li>\r\n\r\n    <li><em>Serializability.</em>  The generated function objects do not\r\n    generally support serialization.  If desired, {@code FLAG_SERIALIZABLE}\r\n    can be used to indicate that the function objects should be serializable.\r\n    Serializable function objects will use, as their serialized form,\r\n    instances of the class {@code SerializedLambda}, which requires additional\r\n    assistance from the capturing class (the class described by the\r\n    {@link MethodHandles.Lookup} parameter {@code caller}); see\r\n    {@link SerializedLambda} for details.</li>\r\n</ul>\r\n\r\n<p>Assume the linkage arguments are as follows:\r\n<ul>\r\n     <li>{@code invokedType} (describing the {@code CallSite} signature) has\r\n     K parameters of types (D1..Dk) and return type Rd;</li>\r\n     <li>{@code samMethodType} (describing the implemented method type) has N\r\n     parameters, of types (U1..Un) and return type Ru;</li>\r\n     <li>{@code implMethod} (the {@code MethodHandle} providing the\r\n     implementation has M parameters, of types (A1..Am) and return type Ra\r\n     (if the method describes an instance method, the method type of this\r\n     method handle already includes an extra first argument corresponding to\r\n     the receiver);</li>\r\n     <li>{@code instantiatedMethodType} (allowing restrictions on invocation)\r\n     has N parameters, of types (T1..Tn) and return type Rt.</li>\r\n</ul>\r\n\r\n<p>Then the following linkage invariants must hold:\r\n<ul>\r\n    <li>Rd is an interface</li>\r\n    <li>{@code implMethod} is a <em>direct method handle</em></li>\r\n    <li>{@code samMethodType} and {@code instantiatedMethodType} have the same\r\n    arity N, and for i=1..N, Ti and Ui are the same type, or Ti and Ui are\r\n    both reference types and Ti is a subtype of Ui</li>\r\n    <li>Either Rt and Ru are the same type, or both are reference types and\r\n    Rt is a subtype of Ru</li>\r\n    <li>K + N = M</li>\r\n    <li>For i=1..K, Di = Ai</li>\r\n    <li>For i=1..N, Ti is adaptable to Aj, where j=i+k</li>\r\n    <li>The return type Rt is void, or the return type Ra is not void and is\r\n    adaptable to Rt</li>\r\n</ul>\r\n\r\n<p>Further, at capture time, if {@code implMethod} corresponds to an instance\r\nmethod, and there are any capture arguments ({@code K > 0}), then the first\r\ncapture argument (corresponding to the receiver) must be non-null.\r\n\r\n<p>A type Q is considered adaptable to S as follows:\r\n<table summary=\"adaptable types\">\r\n    <tr><th>Q</th><th>S</th><th>Link-time checks</th><th>Invocation-time checks</th></tr>\r\n    <tr>\r\n        <td>Primitive</td><td>Primitive</td>\r\n        <td>Q can be converted to S via a primitive widening conversion</td>\r\n        <td>None</td>\r\n    </tr>\r\n    <tr>\r\n        <td>Primitive</td><td>Reference</td>\r\n        <td>S is a supertype of the Wrapper(Q)</td>\r\n        <td>Cast from Wrapper(Q) to S</td>\r\n    </tr>\r\n    <tr>\r\n        <td>Reference</td><td>Primitive</td>\r\n        <td>for parameter types: Q is a primitive wrapper and Primitive(Q)\r\n        can be widened to S\r\n        <br>for return types: If Q is a primitive wrapper, check that\r\n        Primitive(Q) can be widened to S</td>\r\n        <td>If Q is not a primitive wrapper, cast Q to the base Wrapper(S);\r\n        for example Number for numeric types</td>\r\n    </tr>\r\n    <tr>\r\n        <td>Reference</td><td>Reference</td>\r\n        <td>for parameter types: S is a supertype of Q\r\n        <br>for return types: none</td>\r\n        <td>Cast from Q to S</td>\r\n    </tr>\r\n</table>","inherit":[],"name":"java.lang.invoke.LambdaMetafactory","type":false},{"description":"","inherit":["java.lang.reflect.Member","java.lang.Cloneable"],"name":"java.lang.invoke.MemberName","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.MemberName.Factory","type":false},{"description":"A method handle is a typed, directly executable reference to an underlying method,\r\nconstructor, field, or similar low-level operation, with optional\r\ntransformations of arguments or return values.\r\nThese transformations are quite general, and include such patterns as\r\n{@linkplain #asType conversion},\r\n{@linkplain #bindTo insertion},\r\n{@linkplain java.lang.invoke.MethodHandles#dropArguments deletion},\r\nand {@linkplain java.lang.invoke.MethodHandles#filterArguments substitution}.\r\n\r\n<h1>Method handle contents</h1>\r\nMethod handles are dynamically and strongly typed according to their parameter and return types.\r\nThey are not distinguished by the name or the defining class of their underlying methods.\r\nA method handle must be invoked using a symbolic type descriptor which matches\r\nthe method handle's own {@linkplain #type type descriptor}.\r\n<p>\r\nEvery method handle reports its type descriptor via the {@link #type type} accessor.\r\nThis type descriptor is a {@link java.lang.invoke.MethodType MethodType} object,\r\nwhose structure is a series of classes, one of which is\r\nthe return type of the method (or {@code void.class} if none).\r\n<p>\r\nA method handle's type controls the types of invocations it accepts,\r\nand the kinds of transformations that apply to it.\r\n<p>\r\nA method handle contains a pair of special invoker methods\r\ncalled {@link #invokeExact invokeExact} and {@link #invoke invoke}.\r\nBoth invoker methods provide direct access to the method handle's\r\nunderlying method, constructor, field, or other operation,\r\nas modified by transformations of arguments and return values.\r\nBoth invokers accept calls which exactly match the method handle's own type.\r\nThe plain, inexact invoker also accepts a range of other call types.\r\n<p>\r\nMethod handles are immutable and have no visible state.\r\nOf course, they can be bound to underlying methods or data which exhibit state.\r\nWith respect to the Java Memory Model, any method handle will behave\r\nas if all of its (internal) fields are final variables.  This means that any method\r\nhandle made visible to the application will always be fully formed.\r\nThis is true even if the method handle is published through a shared\r\nvariable in a data race.\r\n<p>\r\nMethod handles cannot be subclassed by the user.\r\nImplementations may (or may not) create internal subclasses of {@code MethodHandle}\r\nwhich may be visible via the {@link java.lang.Object#getClass Object.getClass}\r\noperation.  The programmer should not draw conclusions about a method handle\r\nfrom its specific class, as the method handle class hierarchy (if any)\r\nmay change from time to time or across implementations from different vendors.\r\n\r\n<h1>Method handle compilation</h1>\r\nA Java method call expression naming {@code invokeExact} or {@code invoke}\r\ncan invoke a method handle from Java source code.\r\nFrom the viewpoint of source code, these methods can take any arguments\r\nand their result can be cast to any return type.\r\nFormally this is accomplished by giving the invoker methods\r\n{@code Object} return types and variable arity {@code Object} arguments,\r\nbut they have an additional quality called <em>signature polymorphism</em>\r\nwhich connects this freedom of invocation directly to the JVM execution stack.\r\n<p>\r\nAs is usual with virtual methods, source-level calls to {@code invokeExact}\r\nand {@code invoke} compile to an {@code invokevirtual} instruction.\r\nMore unusually, the compiler must record the actual argument types,\r\nand may not perform method invocation conversions on the arguments.\r\nInstead, it must push them on the stack according to their own unconverted types.\r\nThe method handle object itself is pushed on the stack before the arguments.\r\nThe compiler then calls the method handle with a symbolic type descriptor which\r\ndescribes the argument and return types.\r\n<p>\r\nTo issue a complete symbolic type descriptor, the compiler must also determine\r\nthe return type.  This is based on a cast on the method invocation expression,\r\nif there is one, or else {@code Object} if the invocation is an expression\r\nor else {@code void} if the invocation is a statement.\r\nThe cast may be to a primitive type (but not {@code void}).\r\n<p>\r\nAs a corner case, an uncasted {@code null} argument is given\r\na symbolic type descriptor of {@code java.lang.Void}.\r\nThe ambiguity with the type {@code Void} is harmless, since there are no references of type\r\n{@code Void} except the null reference.\r\n\r\n<h1>Method handle invocation</h1>\r\nThe first time a {@code invokevirtual} instruction is executed\r\nit is linked, by symbolically resolving the names in the instruction\r\nand verifying that the method call is statically legal.\r\nThis is true of calls to {@code invokeExact} and {@code invoke}.\r\nIn this case, the symbolic type descriptor emitted by the compiler is checked for\r\ncorrect syntax and names it contains are resolved.\r\nThus, an {@code invokevirtual} instruction which invokes\r\na method handle will always link, as long\r\nas the symbolic type descriptor is syntactically well-formed\r\nand the types exist.\r\n<p>\r\nWhen the {@code invokevirtual} is executed after linking,\r\nthe receiving method handle's type is first checked by the JVM\r\nto ensure that it matches the symbolic type descriptor.\r\nIf the type match fails, it means that the method which the\r\ncaller is invoking is not present on the individual\r\nmethod handle being invoked.\r\n<p>\r\nIn the case of {@code invokeExact}, the type descriptor of the invocation\r\n(after resolving symbolic type names) must exactly match the method type\r\nof the receiving method handle.\r\nIn the case of plain, inexact {@code invoke}, the resolved type descriptor\r\nmust be a valid argument to the receiver's {@link #asType asType} method.\r\nThus, plain {@code invoke} is more permissive than {@code invokeExact}.\r\n<p>\r\nAfter type matching, a call to {@code invokeExact} directly\r\nand immediately invoke the method handle's underlying method\r\n(or other behavior, as the case may be).\r\n<p>\r\nA call to plain {@code invoke} works the same as a call to\r\n{@code invokeExact}, if the symbolic type descriptor specified by the caller\r\nexactly matches the method handle's own type.\r\nIf there is a type mismatch, {@code invoke} attempts\r\nto adjust the type of the receiving method handle,\r\nas if by a call to {@link #asType asType},\r\nto obtain an exactly invokable method handle {@code M2}.\r\nThis allows a more powerful negotiation of method type\r\nbetween caller and callee.\r\n<p>\r\n(<em>Note:</em> The adjusted method handle {@code M2} is not directly observable,\r\nand implementations are therefore not required to materialize it.)\r\n\r\n<h1>Invocation checking</h1>\r\nIn typical programs, method handle type matching will usually succeed.\r\nBut if a match fails, the JVM will throw a {@link WrongMethodTypeException},\r\neither directly (in the case of {@code invokeExact}) or indirectly as if\r\nby a failed call to {@code asType} (in the case of {@code invoke}).\r\n<p>\r\nThus, a method type mismatch which might show up as a linkage error\r\nin a statically typed program can show up as\r\na dynamic {@code WrongMethodTypeException}\r\nin a program which uses method handles.\r\n<p>\r\nBecause method types contain \"live\" {@code Class} objects,\r\nmethod type matching takes into account both types names and class loaders.\r\nThus, even if a method handle {@code M} is created in one\r\nclass loader {@code L1} and used in another {@code L2},\r\nmethod handle calls are type-safe, because the caller's symbolic type\r\ndescriptor, as resolved in {@code L2},\r\nis matched against the original callee method's symbolic type descriptor,\r\nas resolved in {@code L1}.\r\nThe resolution in {@code L1} happens when {@code M} is created\r\nand its type is assigned, while the resolution in {@code L2} happens\r\nwhen the {@code invokevirtual} instruction is linked.\r\n<p>\r\nApart from the checking of type descriptors,\r\na method handle's capability to call its underlying method is unrestricted.\r\nIf a method handle is formed on a non-public method by a class\r\nthat has access to that method, the resulting handle can be used\r\nin any place by any caller who receives a reference to it.\r\n<p>\r\nUnlike with the Core Reflection API, where access is checked every time\r\na reflective method is invoked,\r\nmethod handle access checking is performed\r\n<a href=\"MethodHandles.Lookup.html#access\">when the method handle is created</a>.\r\nIn the case of {@code ldc} (see below), access checking is performed as part of linking\r\nthe constant pool entry underlying the constant method handle.\r\n<p>\r\nThus, handles to non-public methods, or to methods in non-public classes,\r\nshould generally be kept secret.\r\nThey should not be passed to untrusted code unless their use from\r\nthe untrusted code would be harmless.\r\n\r\n<h1>Method handle creation</h1>\r\nJava code can create a method handle that directly accesses\r\nany method, constructor, or field that is accessible to that code.\r\nThis is done via a reflective, capability-based API called\r\n{@link java.lang.invoke.MethodHandles.Lookup MethodHandles.Lookup}\r\nFor example, a static method handle can be obtained\r\nfrom {@link java.lang.invoke.MethodHandles.Lookup#findStatic Lookup.findStatic}.\r\nThere are also conversion methods from Core Reflection API objects,\r\nsuch as {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.\r\n<p>\r\nLike classes and strings, method handles that correspond to accessible\r\nfields, methods, and constructors can also be represented directly\r\nin a class file's constant pool as constants to be loaded by {@code ldc} bytecodes.\r\nA new type of constant pool entry, {@code CONSTANT_MethodHandle},\r\nrefers directly to an associated {@code CONSTANT_Methodref},\r\n{@code CONSTANT_InterfaceMethodref}, or {@code CONSTANT_Fieldref}\r\nconstant pool entry.\r\n(For full details on method handle constants,\r\nsee sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)\r\n<p>\r\nMethod handles produced by lookups or constant loads from methods or\r\nconstructors with the variable arity modifier bit ({@code 0x0080})\r\nhave a corresponding variable arity, as if they were defined with\r\nthe help of {@link #asVarargsCollector asVarargsCollector}.\r\n<p>\r\nA method reference may refer either to a static or non-static method.\r\nIn the non-static case, the method handle type includes an explicit\r\nreceiver argument, prepended before any other arguments.\r\nIn the method handle's type, the initial receiver argument is typed\r\naccording to the class under which the method was initially requested.\r\n(E.g., if a non-static method handle is obtained via {@code ldc},\r\nthe type of the receiver is the class named in the constant pool entry.)\r\n<p>\r\nMethod handle constants are subject to the same link-time access checks\r\ntheir corresponding bytecode instructions, and the {@code ldc} instruction\r\nwill throw corresponding linkage errors if the bytecode behaviors would\r\nthrow such errors.\r\n<p>\r\nAs a corollary of this, access to protected members is restricted\r\nto receivers only of the accessing class, or one of its subclasses,\r\nand the accessing class must in turn be a subclass (or package sibling)\r\nof the protected member's defining class.\r\nIf a method reference refers to a protected non-static method or field\r\nof a class outside the current package, the receiver argument will\r\nbe narrowed to the type of the accessing class.\r\n<p>\r\nWhen a method handle to a virtual method is invoked, the method is\r\nalways looked up in the receiver (that is, the first argument).\r\n<p>\r\nA non-virtual method handle to a specific virtual method implementation\r\ncan also be created.  These do not perform virtual lookup based on\r\nreceiver type.  Such a method handle simulates the effect of\r\nan {@code invokespecial} instruction to the same method.\r\n\r\n<h1>Usage examples</h1>\r\nHere are some examples of usage:\r\n<blockquote><pre>{@code\r\nObject x, y; String s; int i;\r\nMethodType mt; MethodHandle mh;\r\nMethodHandles.Lookup lookup = MethodHandles.lookup();\r\n// mt is (char,char)String\r\nmt = MethodType.methodType(String.class, char.class, char.class);\r\nmh = lookup.findVirtual(String.class, \"replace\", mt);\r\ns = (String) mh.invokeExact(\"daddy\",'d','n');\r\n// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;\r\nassertEquals(s, \"nanny\");\r\n// weakly typed invocation (using MHs.invoke)\r\ns = (String) mh.invokeWithArguments(\"sappy\", 'p', 'v');\r\nassertEquals(s, \"savvy\");\r\n// mt is (Object[])List\r\nmt = MethodType.methodType(java.util.List.class, Object[].class);\r\nmh = lookup.findStatic(java.util.Arrays.class, \"asList\", mt);\r\nassert(mh.isVarargsCollector());\r\nx = mh.invoke(\"one\", \"two\");\r\n// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;\r\nassertEquals(x, java.util.Arrays.asList(\"one\",\"two\"));\r\n// mt is (Object,Object,Object)Object\r\nmt = MethodType.genericMethodType(3);\r\nmh = mh.asType(mt);\r\nx = mh.invokeExact((Object)1, (Object)2, (Object)3);\r\n// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\r\nassertEquals(x, java.util.Arrays.asList(1,2,3));\r\n// mt is ()int\r\nmt = MethodType.methodType(int.class);\r\nmh = lookup.findVirtual(java.util.List.class, \"size\", mt);\r\ni = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));\r\n// invokeExact(Ljava/util/List;)I\r\nassert(i == 3);\r\nmt = MethodType.methodType(void.class, String.class);\r\nmh = lookup.findVirtual(java.io.PrintStream.class, \"println\", mt);\r\nmh.invokeExact(System.out, \"Hello, world.\");\r\n// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V\r\n}</pre></blockquote>\r\nEach of the above calls to {@code invokeExact} or plain {@code invoke}\r\ngenerates a single invokevirtual instruction with\r\nthe symbolic type descriptor indicated in the following comment.\r\nIn these examples, the helper method {@code assertEquals} is assumed to\r\nbe a method which calls {@link java.util.Objects#equals(Object,Object) Objects.equals}\r\non its arguments, and asserts that the result is true.\r\n\r\n<h1>Exceptions</h1>\r\nThe methods {@code invokeExact} and {@code invoke} are declared\r\nto throw {@link java.lang.Throwable Throwable},\r\nwhich is to say that there is no static restriction on what a method handle\r\ncan throw.  Since the JVM does not distinguish between checked\r\nand unchecked exceptions (other than by their class, of course),\r\nthere is no particular effect on bytecode shape from ascribing\r\nchecked exceptions to method handle invocations.  But in Java source\r\ncode, methods which perform method handle calls must either explicitly\r\nthrow {@code Throwable}, or else must catch all\r\nthrowables locally, rethrowing only those which are legal in the context,\r\nand wrapping ones which are illegal.\r\n\r\n<h1><a name=\"sigpoly\"></a>Signature polymorphism</h1>\r\nThe unusual compilation and linkage behavior of\r\n{@code invokeExact} and plain {@code invoke}\r\nis referenced by the term <em>signature polymorphism</em>.\r\nAs defined in the Java Language Specification,\r\na signature polymorphic method is one which can operate with\r\nany of a wide range of call signatures and return types.\r\n<p>\r\nIn source code, a call to a signature polymorphic method will\r\ncompile, regardless of the requested symbolic type descriptor.\r\nAs usual, the Java compiler emits an {@code invokevirtual}\r\ninstruction with the given symbolic type descriptor against the named method.\r\nThe unusual part is that the symbolic type descriptor is derived from\r\nthe actual argument and return types, not from the method declaration.\r\n<p>\r\nWhen the JVM processes bytecode containing signature polymorphic calls,\r\nit will successfully link any such call, regardless of its symbolic type descriptor.\r\n(In order to retain type safety, the JVM will guard such calls with suitable\r\ndynamic type checks, as described elsewhere.)\r\n<p>\r\nBytecode generators, including the compiler back end, are required to emit\r\nuntransformed symbolic type descriptors for these methods.\r\nTools which determine symbolic linkage are required to accept such\r\nuntransformed descriptors, without reporting linkage errors.\r\n\r\n<h1>Interoperation between method handles and the Core Reflection API</h1>\r\nUsing factory methods in the {@link java.lang.invoke.MethodHandles.Lookup Lookup} API,\r\nany class member represented by a Core Reflection API object\r\ncan be converted to a behaviorally equivalent method handle.\r\nFor example, a reflective {@link java.lang.reflect.Method Method} can\r\nbe converted to a method handle using\r\n{@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.\r\nThe resulting method handles generally provide more direct and efficient\r\naccess to the underlying class members.\r\n<p>\r\nAs a special case,\r\nwhen the Core Reflection API is used to view the signature polymorphic\r\nmethods {@code invokeExact} or plain {@code invoke} in this class,\r\nthey appear as ordinary non-polymorphic methods.\r\nTheir reflective appearance, as viewed by\r\n{@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},\r\nis unaffected by their special status in this API.\r\nFor example, {@link java.lang.reflect.Method#getModifiers Method.getModifiers}\r\nwill report exactly those modifier bits required for any similarly\r\ndeclared method, including in this case {@code native} and {@code varargs} bits.\r\n<p>\r\nAs with any reflected method, these methods (when reflected) may be\r\ninvoked via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.\r\nHowever, such reflective calls do not result in method handle invocations.\r\nSuch a call, if passed the required argument\r\n(a single one, of type {@code Object[]}), will ignore the argument and\r\nwill throw an {@code UnsupportedOperationException}.\r\n<p>\r\nSince {@code invokevirtual} instructions can natively\r\ninvoke method handles under any symbolic type descriptor, this reflective view conflicts\r\nwith the normal presentation of these methods via bytecodes.\r\nThus, these two native methods, when reflectively viewed by\r\n{@code Class.getDeclaredMethod}, may be regarded as placeholders only.\r\n<p>\r\nIn order to obtain an invoker method for a particular type descriptor,\r\nuse {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker},\r\nor {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}.\r\nThe {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}\r\nAPI is also able to return a method handle\r\nto call {@code invokeExact} or plain {@code invoke},\r\nfor any specified type descriptor .\r\n\r\n<h1>Interoperation between method handles and Java generics</h1>\r\nA method handle can be obtained on a method, constructor, or field\r\nwhich is declared with Java generic types.\r\nAs with the Core Reflection API, the type of the method handle\r\nwill constructed from the erasure of the source-level type.\r\nWhen a method handle is invoked, the types of its arguments\r\nor the return value cast type may be generic types or type instances.\r\nIf this occurs, the compiler will replace those\r\ntypes by their erasures when it constructs the symbolic type descriptor\r\nfor the {@code invokevirtual} instruction.\r\n<p>\r\nMethod handles do not represent\r\ntheir function-like types in terms of Java parameterized (generic) types,\r\nbecause there are three mismatches between function-like types and parameterized\r\nJava types.\r\n<ul>\r\n<li>Method types range over all possible arities,\r\nfrom no arguments to up to the  <a href=\"MethodHandle.html#maxarity\">maximum number</a> of allowed arguments.\r\nGenerics are not variadic, and so cannot represent this.</li>\r\n<li>Method types can specify arguments of primitive types,\r\nwhich Java generic types cannot range over.</li>\r\n<li>Higher order functions over method handles (combinators) are\r\noften generic across a wide range of function types, including\r\nthose of multiple arities.  It is impossible to represent such\r\ngenericity with a Java type parameter.</li>\r\n</ul>\r\n\r\n<h1><a name=\"maxarity\"></a>Arity limits</h1>\r\nThe JVM imposes on all methods and constructors of any kind an absolute\r\nlimit of 255 stacked arguments.  This limit can appear more restrictive\r\nin certain cases:\r\n<ul>\r\n<li>A {@code long} or {@code double} argument counts (for purposes of arity limits) as two argument slots.\r\n<li>A non-static method consumes an extra argument for the object on which the method is called.\r\n<li>A constructor consumes an extra argument for the object which is being constructed.\r\n<li>Since a method handle&rsquo;s {@code invoke} method (or other signature-polymorphic method) is non-virtual,\r\n    it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object.\r\n</ul>\r\nThese limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments.\r\nFor example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it.\r\nAttempts to create method handles with impossible method types lead to an {@link IllegalArgumentException}.\r\nIn particular, a method handle&rsquo;s type must not have an arity of the exact maximum 255.","inherit":[],"name":"java.lang.invoke.MethodHandle","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.MethodHandleImpl","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.MethodHandleImpl.ArrayAccessor","type":false},{"description":"","inherit":["java.lang.invoke.DelegatingMethodHandle"],"name":"java.lang.invoke.MethodHandleImpl.AsVarargsCollector","type":false},{"description":"Pre-initialized NamedFunctions for bootstrapping purposes.\r\nFactored in an inner class to delay initialization until first usage.","inherit":[],"name":"java.lang.invoke.MethodHandleImpl.Lazy","type":false},{"description":"Counting method handle. It has 2 states: counting and non-counting.\r\nIt is in counting state for the first n invocations and then transitions to non-counting state.\r\nBehavior in counting and non-counting states is determined by lambda forms produced by\r\ncountingFormProducer & nonCountingFormProducer respectively.","inherit":["java.lang.invoke.DelegatingMethodHandle"],"name":"java.lang.invoke.MethodHandleImpl.CountingWrapper","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.MethodHandleImpl.BindCaller","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.MethodHandleImpl.BindCaller.T","type":false},{"description":"This subclass allows a wrapped method handle to be re-associated with an arbitrary member name.","inherit":["java.lang.invoke.DelegatingMethodHandle"],"name":"java.lang.invoke.MethodHandleImpl.WrappedMember","type":false},{"description":"Mark arbitrary method handle as intrinsic.\r\nInvokerBytecodeGenerator uses this info to produce more efficient bytecode shape.","inherit":["java.lang.invoke.DelegatingMethodHandle"],"name":"java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle","type":false},{"description":"A symbolic reference obtained by cracking a direct method handle\r\ninto its consitutent symbolic parts.\r\nTo crack a direct method handle, call {@link Lookup#revealDirect Lookup.revealDirect}.\r\n<h1><a name=\"directmh\"></a>Direct Method Handles</h1>\r\nA <em>direct method handle</em> represents a method, constructor, or field without\r\nany intervening argument bindings or other transformations.\r\nThe method, constructor, or field referred to by a direct method handle is called\r\nits <em>underlying member</em>.\r\nDirect method handles may be obtained in any of these ways:\r\n<ul>\r\n<li>By executing an {@code ldc} instruction on a {@code CONSTANT_MethodHandle} constant.\r\n    (See the Java Virtual Machine Specification, sections 4.4.8 and 5.4.3.)\r\n<li>By calling one of the <a href=\"MethodHandles.Lookup.html#lookups\">Lookup Factory Methods</a>,\r\n    such as {@link Lookup#findVirtual Lookup.findVirtual},\r\n    to resolve a symbolic reference into a method handle.\r\n    A symbolic reference consists of a class, name string, and type.\r\n<li>By calling the factory method {@link Lookup#unreflect Lookup.unreflect}\r\n    or {@link Lookup#unreflectSpecial Lookup.unreflectSpecial}\r\n    to convert a {@link Method} into a method handle.\r\n<li>By calling the factory method {@link Lookup#unreflectConstructor Lookup.unreflectConstructor}\r\n    to convert a {@link Constructor} into a method handle.\r\n<li>By calling the factory method {@link Lookup#unreflectGetter Lookup.unreflectGetter}\r\n    or {@link Lookup#unreflectSetter Lookup.unreflectSetter}\r\n    to convert a {@link Field} into a method handle.\r\n</ul>\r\n\r\n<h1>Restrictions on Cracking</h1>\r\nGiven a suitable {@code Lookup} object, it is possible to crack any direct method handle\r\nto recover a symbolic reference for the underlying method, constructor, or field.\r\nCracking must be done via a {@code Lookup} object equivalent to that which created\r\nthe target method handle, or which has enough access permissions to recreate\r\nan equivalent method handle.\r\n<p>\r\nIf the underlying method is <a href=\"MethodHandles.Lookup.html#callsens\">caller sensitive</a>,\r\nthe direct method handle will have been \"bound\" to a particular caller class, the\r\n{@linkplain java.lang.invoke.MethodHandles.Lookup#lookupClass() lookup class}\r\nof the lookup object used to create it.\r\nCracking this method handle with a different lookup class will fail\r\neven if the underlying method is public (like {@code Class.forName}).\r\n<p>\r\nThe requirement of lookup object matching provides a \"fast fail\" behavior\r\nfor programs which may otherwise trust erroneous revelation of a method\r\nhandle with symbolic information (or caller binding) from an unexpected scope.\r\nUse {@link java.lang.invoke.MethodHandles#reflectAs} to override this limitation.\r\n\r\n<h1><a name=\"refkinds\"></a>Reference kinds</h1>\r\nThe <a href=\"MethodHandles.Lookup.html#lookups\">Lookup Factory Methods</a>\r\ncorrespond to all major use cases for methods, constructors, and fields.\r\nThese use cases may be distinguished using small integers as follows:\r\n<table border=1 cellpadding=5 summary=\"reference kinds\">\r\n<tr><th>reference kind</th><th>descriptive name</th><th>scope</th><th>member</th><th>behavior</th></tr>\r\n<tr>\r\n    <td>{@code 1}</td><td>{@code REF_getField}</td><td>{@code class}</td>\r\n    <td>{@code FT f;}</td><td>{@code (T) this.f;}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@code 2}</td><td>{@code REF_getStatic}</td><td>{@code class} or {@code interface}</td>\r\n    <td>{@code static}<br>{@code FT f;}</td><td>{@code (T) C.f;}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@code 3}</td><td>{@code REF_putField}</td><td>{@code class}</td>\r\n    <td>{@code FT f;}</td><td>{@code this.f = x;}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@code 4}</td><td>{@code REF_putStatic}</td><td>{@code class}</td>\r\n    <td>{@code static}<br>{@code FT f;}</td><td>{@code C.f = arg;}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@code 5}</td><td>{@code REF_invokeVirtual}</td><td>{@code class}</td>\r\n    <td>{@code T m(A*);}</td><td>{@code (T) this.m(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@code 6}</td><td>{@code REF_invokeStatic}</td><td>{@code class} or {@code interface}</td>\r\n    <td>{@code static}<br>{@code T m(A*);}</td><td>{@code (T) C.m(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@code 7}</td><td>{@code REF_invokeSpecial}</td><td>{@code class} or {@code interface}</td>\r\n    <td>{@code T m(A*);}</td><td>{@code (T) super.m(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@code 8}</td><td>{@code REF_newInvokeSpecial}</td><td>{@code class}</td>\r\n    <td>{@code C(A*);}</td><td>{@code new C(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@code 9}</td><td>{@code REF_invokeInterface}</td><td>{@code interface}</td>\r\n    <td>{@code T m(A*);}</td><td>{@code (T) this.m(arg*);}</td>\r\n</tr>\r\n</table>","inherit":[],"name":"java.lang.invoke.MethodHandleInfo","type":true},{"description":"The JVM interface for the method handles package is all here.\r\nThis is an interface internal and private to an implementation of JSR 292.\r\n<em>This class is not part of the JSR 292 standard.</em>","inherit":[],"name":"java.lang.invoke.MethodHandleNatives","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.MethodHandleNatives.Constants","type":false},{"description":"This class consists exclusively of static methods that help adapt\r\nmethod handles to other JVM types, such as interfaces.","inherit":[],"name":"java.lang.invoke.MethodHandleProxies","type":false},{"description":"This class consists exclusively of static methods that operate on or return\r\nmethod handles. They fall into several categories:\r\n<ul>\r\n<li>Lookup methods which help create method handles for methods and fields.\r\n<li>Combinator methods, which combine or transform pre-existing method handles into new ones.\r\n<li>Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.\r\n</ul>\r\n<p>","inherit":[],"name":"java.lang.invoke.MethodHandles","type":false},{"description":"A <em>lookup object</em> is a factory for creating method handles,\r\nwhen the creation requires access checking.\r\nMethod handles do not perform\r\naccess checks when they are called, but rather when they are created.\r\nTherefore, method handle access\r\nrestrictions must be enforced when a method handle is created.\r\nThe caller class against which those restrictions are enforced\r\nis known as the {@linkplain #lookupClass lookup class}.\r\n<p>\r\nA lookup class which needs to create method handles will call\r\n{@link MethodHandles#lookup MethodHandles.lookup} to create a factory for itself.\r\nWhen the {@code Lookup} factory object is created, the identity of the lookup class is\r\ndetermined, and securely stored in the {@code Lookup} object.\r\nThe lookup class (or its delegates) may then use factory methods\r\non the {@code Lookup} object to create method handles for access-checked members.\r\nThis includes all methods, constructors, and fields which are allowed to the lookup class,\r\neven private ones.\r\n\r\n<h1><a name=\"lookups\"></a>Lookup Factory Methods</h1>\r\nThe factory methods on a {@code Lookup} object correspond to all major\r\nuse cases for methods, constructors, and fields.\r\nEach method handle created by a factory method is the functional\r\nequivalent of a particular <em>bytecode behavior</em>.\r\n(Bytecode behaviors are described in section 5.4.3.5 of the Java Virtual Machine Specification.)\r\nHere is a summary of the correspondence between these factory methods and\r\nthe behavior the resulting method handles:\r\n<table border=1 cellpadding=5 summary=\"lookup method behaviors\">\r\n<tr>\r\n    <th><a name=\"equiv\"></a>lookup expression</th>\r\n    <th>member</th>\r\n    <th>bytecode behavior</th>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,\"f\",FT.class)}</td>\r\n    <td>{@code FT f;}</td><td>{@code (T) this.f;}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,\"f\",FT.class)}</td>\r\n    <td>{@code static}<br>{@code FT f;}</td><td>{@code (T) C.f;}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,\"f\",FT.class)}</td>\r\n    <td>{@code FT f;}</td><td>{@code this.f = x;}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#findStaticSetter lookup.findStaticSetter(C.class,\"f\",FT.class)}</td>\r\n    <td>{@code static}<br>{@code FT f;}</td><td>{@code C.f = arg;}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#findVirtual lookup.findVirtual(C.class,\"m\",MT)}</td>\r\n    <td>{@code T m(A*);}</td><td>{@code (T) this.m(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#findStatic lookup.findStatic(C.class,\"m\",MT)}</td>\r\n    <td>{@code static}<br>{@code T m(A*);}</td><td>{@code (T) C.m(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#findSpecial lookup.findSpecial(C.class,\"m\",MT,this.class)}</td>\r\n    <td>{@code T m(A*);}</td><td>{@code (T) super.m(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#findConstructor lookup.findConstructor(C.class,MT)}</td>\r\n    <td>{@code C(A*);}</td><td>{@code new C(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#unreflectGetter lookup.unreflectGetter(aField)}</td>\r\n    <td>({@code static})?<br>{@code FT f;}</td><td>{@code (FT) aField.get(thisOrNull);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#unreflectSetter lookup.unreflectSetter(aField)}</td>\r\n    <td>({@code static})?<br>{@code FT f;}</td><td>{@code aField.set(thisOrNull, arg);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}</td>\r\n    <td>({@code static})?<br>{@code T m(A*);}</td><td>{@code (T) aMethod.invoke(thisOrNull, arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)}</td>\r\n    <td>{@code C(A*);}</td><td>{@code (C) aConstructor.newInstance(arg*);}</td>\r\n</tr>\r\n<tr>\r\n    <td>{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}</td>\r\n    <td>({@code static})?<br>{@code T m(A*);}</td><td>{@code (T) aMethod.invoke(thisOrNull, arg*);}</td>\r\n</tr>\r\n</table>\r\n\r\nHere, the type {@code C} is the class or interface being searched for a member,\r\ndocumented as a parameter named {@code refc} in the lookup methods.\r\nThe method type {@code MT} is composed from the return type {@code T}\r\nand the sequence of argument types {@code A*}.\r\nThe constructor also has a sequence of argument types {@code A*} and\r\nis deemed to return the newly-created object of type {@code C}.\r\nBoth {@code MT} and the field type {@code FT} are documented as a parameter named {@code type}.\r\nThe formal parameter {@code this} stands for the self-reference of type {@code C};\r\nif it is present, it is always the leading argument to the method handle invocation.\r\n(In the case of some {@code protected} members, {@code this} may be\r\nrestricted in type to the lookup class; see below.)\r\nThe name {@code arg} stands for all the other method handle arguments.\r\nIn the code examples for the Core Reflection API, the name {@code thisOrNull}\r\nstands for a null reference if the accessed method or field is static,\r\nand {@code this} otherwise.\r\nThe names {@code aMethod}, {@code aField}, and {@code aConstructor} stand\r\nfor reflective objects corresponding to the given members.\r\n<p>\r\nIn cases where the given member is of variable arity (i.e., a method or constructor)\r\nthe returned method handle will also be of {@linkplain MethodHandle#asVarargsCollector variable arity}.\r\nIn all other cases, the returned method handle will be of fixed arity.\r\n<p style=\"font-size:smaller;\">\r\n<em>Discussion:</em>\r\nThe equivalence between looked-up method handles and underlying\r\nclass members and bytecode behaviors\r\ncan break down in a few ways:\r\n<ul style=\"font-size:smaller;\">\r\n<li>If {@code C} is not symbolically accessible from the lookup class's loader,\r\nthe lookup can still succeed, even when there is no equivalent\r\nJava expression or bytecoded constant.\r\n<li>Likewise, if {@code T} or {@code MT}\r\nis not symbolically accessible from the lookup class's loader,\r\nthe lookup can still succeed.\r\nFor example, lookups for {@code MethodHandle.invokeExact} and\r\n{@code MethodHandle.invoke} will always succeed, regardless of requested type.\r\n<li>If there is a security manager installed, it can forbid the lookup\r\non various grounds (<a href=\"MethodHandles.Lookup.html#secmgr\">see below</a>).\r\nBy contrast, the {@code ldc} instruction on a {@code CONSTANT_MethodHandle}\r\nconstant is not subject to security manager checks.\r\n<li>If the looked-up method has a\r\n<a href=\"MethodHandle.html#maxarity\">very large arity</a>,\r\nthe method handle creation may fail, due to the method handle\r\ntype having too many parameters.\r\n</ul>\r\n\r\n<h1><a name=\"access\"></a>Access checking</h1>\r\nAccess checks are applied in the factory methods of {@code Lookup},\r\nwhen a method handle is created.\r\nThis is a key difference from the Core Reflection API, since\r\n{@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}\r\nperforms access checking against every caller, on every call.\r\n<p>\r\nAll access checks start from a {@code Lookup} object, which\r\ncompares its recorded lookup class against all requests to\r\ncreate method handles.\r\nA single {@code Lookup} object can be used to create any number\r\nof access-checked method handles, all checked against a single\r\nlookup class.\r\n<p>\r\nA {@code Lookup} object can be shared with other trusted code,\r\nsuch as a metaobject protocol.\r\nA shared {@code Lookup} object delegates the capability\r\nto create method handles on private members of the lookup class.\r\nEven if privileged code uses the {@code Lookup} object,\r\nthe access checking is confined to the privileges of the\r\noriginal lookup class.\r\n<p>\r\nA lookup can fail, because\r\nthe containing class is not accessible to the lookup class, or\r\nbecause the desired class member is missing, or because the\r\ndesired class member is not accessible to the lookup class, or\r\nbecause the lookup object is not trusted enough to access the member.\r\nIn any of these cases, a {@code ReflectiveOperationException} will be\r\nthrown from the attempted lookup.  The exact class will be one of\r\nthe following:\r\n<ul>\r\n<li>NoSuchMethodException &mdash; if a method is requested but does not exist\r\n<li>NoSuchFieldException &mdash; if a field is requested but does not exist\r\n<li>IllegalAccessException &mdash; if the member exists but an access check fails\r\n</ul>\r\n<p>\r\nIn general, the conditions under which a method handle may be\r\nlooked up for a method {@code M} are no more restrictive than the conditions\r\nunder which the lookup class could have compiled, verified, and resolved a call to {@code M}.\r\nWhere the JVM would raise exceptions like {@code NoSuchMethodError},\r\na method handle lookup will generally raise a corresponding\r\nchecked exception, such as {@code NoSuchMethodException}.\r\nAnd the effect of invoking the method handle resulting from the lookup\r\nis <a href=\"MethodHandles.Lookup.html#equiv\">exactly equivalent</a>\r\nto executing the compiled, verified, and resolved call to {@code M}.\r\nThe same point is true of fields and constructors.\r\n<p style=\"font-size:smaller;\">\r\n<em>Discussion:</em>\r\nAccess checks only apply to named and reflected methods,\r\nconstructors, and fields.\r\nOther method handle creation methods, such as\r\n{@link MethodHandle#asType MethodHandle.asType},\r\ndo not require any access checks, and are used\r\nindependently of any {@code Lookup} object.\r\n<p>\r\nIf the desired member is {@code protected}, the usual JVM rules apply,\r\nincluding the requirement that the lookup class must be either be in the\r\nsame package as the desired member, or must inherit that member.\r\n(See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.)\r\nIn addition, if the desired member is a non-static field or method\r\nin a different package, the resulting method handle may only be applied\r\nto objects of the lookup class or one of its subclasses.\r\nThis requirement is enforced by narrowing the type of the leading\r\n{@code this} parameter from {@code C}\r\n(which will necessarily be a superclass of the lookup class)\r\nto the lookup class itself.\r\n<p>\r\nThe JVM imposes a similar requirement on {@code invokespecial} instruction,\r\nthat the receiver argument must match both the resolved method <em>and</em>\r\nthe current class.  Again, this requirement is enforced by narrowing the\r\ntype of the leading parameter to the resulting method handle.\r\n(See the Java Virtual Machine Specification, section 4.10.1.9.)\r\n<p>\r\nThe JVM represents constructors and static initializer blocks as internal methods\r\nwith special names ({@code \"<init>\"} and {@code \"<clinit>\"}).\r\nThe internal syntax of invocation instructions allows them to refer to such internal\r\nmethods as if they were normal methods, but the JVM bytecode verifier rejects them.\r\nA lookup of such an internal method will produce a {@code NoSuchMethodException}.\r\n<p>\r\nIn some cases, access between nested classes is obtained by the Java compiler by creating\r\nan wrapper method to access a private method of another class\r\nin the same top-level declaration.\r\nFor example, a nested class {@code C.D}\r\ncan access private members within other related classes such as\r\n{@code C}, {@code C.D.E}, or {@code C.B},\r\nbut the Java compiler may need to generate wrapper methods in\r\nthose related classes.  In such cases, a {@code Lookup} object on\r\n{@code C.E} would be unable to those private members.\r\nA workaround for this limitation is the {@link Lookup#in Lookup.in} method,\r\nwhich can transform a lookup on {@code C.E} into one on any of those other\r\nclasses, without special elevation of privilege.\r\n<p>\r\nThe accesses permitted to a given lookup object may be limited,\r\naccording to its set of {@link #lookupModes lookupModes},\r\nto a subset of members normally accessible to the lookup class.\r\nFor example, the {@link MethodHandles#publicLookup publicLookup}\r\nmethod produces a lookup object which is only allowed to access\r\npublic members in public classes.\r\nThe caller sensitive method {@link MethodHandles#lookup lookup}\r\nproduces a lookup object with full capabilities relative to\r\nits caller class, to emulate all supported bytecode behaviors.\r\nAlso, the {@link Lookup#in Lookup.in} method may produce a lookup object\r\nwith fewer access modes than the original lookup object.\r\n\r\n<p style=\"font-size:smaller;\">\r\n<a name=\"privacc\"></a>\r\n<em>Discussion of private access:</em>\r\nWe say that a lookup has <em>private access</em>\r\nif its {@linkplain #lookupModes lookup modes}\r\ninclude the possibility of accessing {@code private} members.\r\nAs documented in the relevant methods elsewhere,\r\nonly lookups with private access possess the following capabilities:\r\n<ul style=\"font-size:smaller;\">\r\n<li>access private fields, methods, and constructors of the lookup class\r\n<li>create method handles which invoke <a href=\"MethodHandles.Lookup.html#callsens\">caller sensitive</a> methods,\r\n    such as {@code Class.forName}\r\n<li>create method handles which {@link Lookup#findSpecial emulate invokespecial} instructions\r\n<li>avoid <a href=\"MethodHandles.Lookup.html#secmgr\">package access checks</a>\r\n    for classes accessible to the lookup class\r\n<li>create {@link Lookup#in delegated lookup objects} which have private access to other classes\r\n    within the same package member\r\n</ul>\r\n<p style=\"font-size:smaller;\">\r\nEach of these permissions is a consequence of the fact that a lookup object\r\nwith private access can be securely traced back to an originating class,\r\nwhose <a href=\"MethodHandles.Lookup.html#equiv\">bytecode behaviors</a> and Java language access permissions\r\ncan be reliably determined and emulated by method handles.\r\n\r\n<h1><a name=\"secmgr\"></a>Security manager interactions</h1>\r\nAlthough bytecode instructions can only refer to classes in\r\na related class loader, this API can search for methods in any\r\nclass, as long as a reference to its {@code Class} object is\r\navailable.  Such cross-loader references are also possible with the\r\nCore Reflection API, and are impossible to bytecode instructions\r\nsuch as {@code invokestatic} or {@code getfield}.\r\nThere is a {@linkplain java.lang.SecurityManager security manager API}\r\nto allow applications to check such cross-loader references.\r\nThese checks apply to both the {@code MethodHandles.Lookup} API\r\nand the Core Reflection API\r\n(as found on {@link java.lang.Class Class}).\r\n<p>\r\nIf a security manager is present, member lookups are subject to\r\nadditional checks.\r\nFrom one to three calls are made to the security manager.\r\nAny of these calls can refuse access by throwing a\r\n{@link java.lang.SecurityException SecurityException}.\r\nDefine {@code smgr} as the security manager,\r\n{@code lookc} as the lookup class of the current lookup object,\r\n{@code refc} as the containing class in which the member\r\nis being sought, and {@code defc} as the class in which the\r\nmember is actually defined.\r\nThe value {@code lookc} is defined as <em>not present</em>\r\nif the current lookup object does not have\r\n<a href=\"MethodHandles.Lookup.html#privacc\">private access</a>.\r\nThe calls are made according to the following rules:\r\n<ul>\r\n<li><b>Step 1:</b>\r\n    If {@code lookc} is not present, or if its class loader is not\r\n    the same as or an ancestor of the class loader of {@code refc},\r\n    then {@link SecurityManager#checkPackageAccess\r\n    smgr.checkPackageAccess(refcPkg)} is called,\r\n    where {@code refcPkg} is the package of {@code refc}.\r\n<li><b>Step 2:</b>\r\n    If the retrieved member is not public and\r\n    {@code lookc} is not present, then\r\n    {@link SecurityManager#checkPermission smgr.checkPermission}\r\n    with {@code RuntimePermission(\"accessDeclaredMembers\")} is called.\r\n<li><b>Step 3:</b>\r\n    If the retrieved member is not public,\r\n    and if {@code lookc} is not present,\r\n    and if {@code defc} and {@code refc} are different,\r\n    then {@link SecurityManager#checkPackageAccess\r\n    smgr.checkPackageAccess(defcPkg)} is called,\r\n    where {@code defcPkg} is the package of {@code defc}.\r\n</ul>\r\nSecurity checks are performed after other access checks have passed.\r\nTherefore, the above rules presuppose a member that is public,\r\nor else that is being accessed from a lookup class that has\r\nrights to access the member.\r\n\r\n<h1><a name=\"callsens\"></a>Caller sensitive methods</h1>\r\nA small number of Java methods have a special property called caller sensitivity.\r\nA <em>caller-sensitive</em> method can behave differently depending on the\r\nidentity of its immediate caller.\r\n<p>\r\nIf a method handle for a caller-sensitive method is requested,\r\nthe general rules for <a href=\"MethodHandles.Lookup.html#equiv\">bytecode behaviors</a> apply,\r\nbut they take account of the lookup class in a special way.\r\nThe resulting method handle behaves as if it were called\r\nfrom an instruction contained in the lookup class,\r\nso that the caller-sensitive method detects the lookup class.\r\n(By contrast, the invoker of the method handle is disregarded.)\r\nThus, in the case of caller-sensitive methods,\r\ndifferent lookup classes may give rise to\r\ndifferently behaving method handles.\r\n<p>\r\nIn cases where the lookup object is\r\n{@link MethodHandles#publicLookup() publicLookup()},\r\nor some other lookup object without\r\n<a href=\"MethodHandles.Lookup.html#privacc\">private access</a>,\r\nthe lookup class is disregarded.\r\nIn such cases, no caller-sensitive method handle can be created,\r\naccess is forbidden, and the lookup fails with an\r\n{@code IllegalAccessException}.\r\n<p style=\"font-size:smaller;\">\r\n<em>Discussion:</em>\r\nFor example, the caller-sensitive method\r\n{@link java.lang.Class#forName(String) Class.forName(x)}\r\ncan return varying classes or throw varying exceptions,\r\ndepending on the class loader of the class that calls it.\r\nA public lookup of {@code Class.forName} will fail, because\r\nthere is no reasonable way to determine its bytecode behavior.\r\n<p style=\"font-size:smaller;\">\r\nIf an application caches method handles for broad sharing,\r\nit should use {@code publicLookup()} to create them.\r\nIf there is a lookup of {@code Class.forName}, it will fail,\r\nand the application must take appropriate action in that case.\r\nIt may be that a later lookup, perhaps during the invocation of a\r\nbootstrap method, can incorporate the specific identity\r\nof the caller, making the method accessible.\r\n<p style=\"font-size:smaller;\">\r\nThe function {@code MethodHandles.lookup} is caller sensitive\r\nso that there can be a secure foundation for lookups.\r\nNearly all other methods in the JSR 292 API rely on lookup\r\nobjects to check access requests.","inherit":[],"name":"java.lang.invoke.MethodHandles.Lookup","type":false},{"description":"","inherit":[],"name":"java.lang.invoke.MethodHandleStatics","type":false},{"description":"A method type represents the arguments and return type accepted and\r\nreturned by a method handle, or the arguments and return type passed\r\nand expected  by a method handle caller.  Method types must be properly\r\nmatched between a method handle and all its callers,\r\nand the JVM's operations enforce this matching at, specifically\r\nduring calls to {@link MethodHandle#invokeExact MethodHandle.invokeExact}\r\nand {@link MethodHandle#invoke MethodHandle.invoke}, and during execution\r\nof {@code invokedynamic} instructions.\r\n<p>\r\nThe structure is a return type accompanied by any number of parameter types.\r\nThe types (primitive, {@code void}, and reference) are represented by {@link Class} objects.\r\n(For ease of exposition, we treat {@code void} as if it were a type.\r\nIn fact, it denotes the absence of a return type.)\r\n<p>\r\nAll instances of {@code MethodType} are immutable.\r\nTwo instances are completely interchangeable if they compare equal.\r\nEquality depends on pairwise correspondence of the return and parameter types and on nothing else.\r\n<p>\r\nThis type can be created only by factory methods.\r\nAll factory methods may cache values, though caching is not guaranteed.\r\nSome factory methods are static, while others are virtual methods which\r\nmodify precursor method types, e.g., by changing a selected parameter.\r\n<p>\r\nFactory methods which operate on groups of parameter types\r\nare systematically presented in two versions, so that both Java arrays and\r\nJava lists can be used to work with groups of parameter types.\r\nThe query methods {@code parameterArray} and {@code parameterList}\r\nalso provide a choice between arrays and lists.\r\n<p>\r\n{@code MethodType} objects are sometimes derived from bytecode instructions\r\nsuch as {@code invokedynamic}, specifically from the type descriptor strings associated\r\nwith the instructions in a class file's constant pool.\r\n<p>\r\nLike classes and strings, method types can also be represented directly\r\nin a class file's constant pool as constants.\r\nA method type may be loaded by an {@code ldc} instruction which refers\r\nto a suitable {@code CONSTANT_MethodType} constant pool entry.\r\nThe entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.\r\n(For full details on method type constants,\r\nsee sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)\r\n<p>\r\nWhen the JVM materializes a {@code MethodType} from a descriptor string,\r\nall classes named in the descriptor must be accessible, and will be loaded.\r\n(But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)\r\nThis loading may occur at any time before the {@code MethodType} object is first derived.","inherit":["java.io.Serializable"],"name":"java.lang.invoke.MethodType","type":false},{"description":"Simple implementation of weak concurrent intern set.","inherit":[],"name":"java.lang.invoke.MethodType.ConcurrentWeakInternSet","type":false},{"description":"","inherit":["java.lang.ref.WeakReference"],"name":"java.lang.invoke.MethodType.ConcurrentWeakInternSet.WeakEntry","type":false},{"description":"Shared information for a group of method types, which differ\r\nonly by reference types, and therefore share a common erasure\r\nand wrapping.\r\n<p>\r\nFor an empirical discussion of the structure of method types,\r\nsee <a href=\"http://groups.google.com/group/jvm-languages/browse_thread/thread/ac9308ae74da9b7e/\">\r\nthe thread \"Avoiding Boxing\" on jvm-languages</a>.\r\nThere are approximately 2000 distinct erased method types in the JDK.\r\nThere are a little over 10 times that number of unerased types.\r\nNo more than half of these are likely to be loaded at once.","inherit":[],"name":"java.lang.invoke.MethodTypeForm","type":false},{"description":"A {@code MutableCallSite} is a {@link CallSite} whose target variable\r\nbehaves like an ordinary field.\r\nAn {@code invokedynamic} instruction linked to a {@code MutableCallSite} delegates\r\nall calls to the site's current target.\r\nThe {@linkplain CallSite#dynamicInvoker dynamic invoker} of a mutable call site\r\nalso delegates each call to the site's current target.\r\n<p>\r\nHere is an example of a mutable call site which introduces a\r\nstate variable into a method handle chain.\r\n<!-- JavaDocExamplesTest.testMutableCallSite -->\r\n<blockquote><pre>{@code\r\nMutableCallSite name = new MutableCallSite(MethodType.methodType(String.class));\r\nMethodHandle MH_name = name.dynamicInvoker();\r\nMethodType MT_str1 = MethodType.methodType(String.class);\r\nMethodHandle MH_upcase = MethodHandles.lookup()\r\n    .findVirtual(String.class, \"toUpperCase\", MT_str1);\r\nMethodHandle worker1 = MethodHandles.filterReturnValue(MH_name, MH_upcase);\r\nname.setTarget(MethodHandles.constant(String.class, \"Rocky\"));\r\nassertEquals(\"ROCKY\", (String) worker1.invokeExact());\r\nname.setTarget(MethodHandles.constant(String.class, \"Fred\"));\r\nassertEquals(\"FRED\", (String) worker1.invokeExact());\r\n// (mutation can be continued indefinitely)\r\n}</pre></blockquote>\r\n<p>\r\nThe same call site may be used in several places at once.\r\n<blockquote><pre>{@code\r\nMethodType MT_str2 = MethodType.methodType(String.class, String.class);\r\nMethodHandle MH_cat = lookup().findVirtual(String.class,\r\n  \"concat\", methodType(String.class, String.class));\r\nMethodHandle MH_dear = MethodHandles.insertArguments(MH_cat, 1, \", dear?\");\r\nMethodHandle worker2 = MethodHandles.filterReturnValue(MH_name, MH_dear);\r\nassertEquals(\"Fred, dear?\", (String) worker2.invokeExact());\r\nname.setTarget(MethodHandles.constant(String.class, \"Wilma\"));\r\nassertEquals(\"WILMA\", (String) worker1.invokeExact());\r\nassertEquals(\"Wilma, dear?\", (String) worker2.invokeExact());\r\n}</pre></blockquote>\r\n<p>\r\n<em>Non-synchronization of target values:</em>\r\nA write to a mutable call site's target does not force other threads\r\nto become aware of the updated value.  Threads which do not perform\r\nsuitable synchronization actions relative to the updated call site\r\nmay cache the old target value and delay their use of the new target\r\nvalue indefinitely.\r\n(This is a normal consequence of the Java Memory Model as applied\r\nto object fields.)\r\n<p>\r\nThe {@link #syncAll syncAll} operation provides a way to force threads\r\nto accept a new target value, even if there is no other synchronization.\r\n<p>\r\nFor target values which will be frequently updated, consider using\r\na {@linkplain VolatileCallSite volatile call site} instead.","inherit":["java.lang.invoke.CallSite"],"name":"java.lang.invoke.MutableCallSite","type":false},{"description":"Helper class used by InnerClassLambdaMetafactory to log generated classes","inherit":[],"name":"java.lang.invoke.ProxyClassesDumper","type":false},{"description":"Serialized form of a lambda expression.  The properties of this class\r\nrepresent the information that is present at the lambda factory site, including\r\nstatic metafactory arguments such as the identity of the primary functional\r\ninterface method and the identity of the implementation method, as well as\r\ndynamic metafactory arguments such as values captured from the lexical scope\r\nat the time of lambda capture.\r\n\r\n<p>Implementors of serializable lambdas, such as compilers or language\r\nruntime libraries, are expected to ensure that instances deserialize properly.\r\nOne means to do so is to ensure that the {@code writeReplace} method returns\r\nan instance of {@code SerializedLambda}, rather than allowing default\r\nserialization to proceed.\r\n\r\n<p>{@code SerializedLambda} has a {@code readResolve} method that looks for\r\na (possibly private) static method called\r\n{@code $deserializeLambda$(SerializedLambda)} in the capturing class, invokes\r\nthat with itself as the first argument, and returns the result.  Lambda classes\r\nimplementing {@code $deserializeLambda$} are responsible for validating\r\nthat the properties of the {@code SerializedLambda} are consistent with a\r\nlambda actually captured by that class.","inherit":["java.io.Serializable"],"name":"java.lang.invoke.SerializedLambda","type":false},{"description":"A method handle whose behavior is determined only by its LambdaForm.","inherit":["java.lang.invoke.BoundMethodHandle"],"name":"java.lang.invoke.SimpleMethodHandle","type":false},{"description":"<p>\r\nA {@code SwitchPoint} is an object which can publish state transitions to other threads.\r\nA switch point is initially in the <em>valid</em> state, but may at any time be\r\nchanged to the <em>invalid</em> state.  Invalidation cannot be reversed.\r\nA switch point can combine a <em>guarded pair</em> of method handles into a\r\n<em>guarded delegator</em>.\r\nThe guarded delegator is a method handle which delegates to one of the old method handles.\r\nThe state of the switch point determines which of the two gets the delegation.\r\n<p>\r\nA single switch point may be used to control any number of method handles.\r\n(Indirectly, therefore, it can control any number of call sites.)\r\nThis is done by using the single switch point as a factory for combining\r\nany number of guarded method handle pairs into guarded delegators.\r\n<p>\r\nWhen a guarded delegator is created from a guarded pair, the pair\r\nis wrapped in a new method handle {@code M},\r\nwhich is permanently associated with the switch point that created it.\r\nEach pair consists of a target {@code T} and a fallback {@code F}.\r\nWhile the switch point is valid, invocations to {@code M} are delegated to {@code T}.\r\nAfter it is invalidated, invocations are delegated to {@code F}.\r\n<p>\r\nInvalidation is global and immediate, as if the switch point contained a\r\nvolatile boolean variable consulted on every call to {@code M}.\r\nThe invalidation is also permanent, which means the switch point\r\ncan change state only once.\r\nThe switch point will always delegate to {@code F} after being invalidated.\r\nAt that point {@code guardWithTest} may ignore {@code T} and return {@code F}.\r\n<p>\r\nHere is an example of a switch point in action:\r\n<pre>{@code\r\nMethodHandle MH_strcat = MethodHandles.lookup()\r\n    .findVirtual(String.class, \"concat\", MethodType.methodType(String.class, String.class));\r\nSwitchPoint spt = new SwitchPoint();\r\nassert(!spt.hasBeenInvalidated());\r\n// the following steps may be repeated to re-use the same switch point:\r\nMethodHandle worker1 = MH_strcat;\r\nMethodHandle worker2 = MethodHandles.permuteArguments(MH_strcat, MH_strcat.type(), 1, 0);\r\nMethodHandle worker = spt.guardWithTest(worker1, worker2);\r\nassertEquals(\"method\", (String) worker.invokeExact(\"met\", \"hod\"));\r\nSwitchPoint.invalidateAll(new SwitchPoint[]{ spt });\r\nassert(spt.hasBeenInvalidated());\r\nassertEquals(\"hodmet\", (String) worker.invokeExact(\"met\", \"hod\"));\r\n}</pre>\r\n<p style=\"font-size:smaller;\">\r\n<em>Discussion:</em>\r\nSwitch points are useful without subclassing.  They may also be subclassed.\r\nThis may be useful in order to associate application-specific invalidation logic\r\nwith the switch point.\r\nNotice that there is no permanent association between a switch point and\r\nthe method handles it produces and consumes.\r\nThe garbage collector may collect method handles produced or consumed\r\nby a switch point independently of the lifetime of the switch point itself.\r\n<p style=\"font-size:smaller;\">\r\n<em>Implementation Note:</em>\r\nA switch point behaves as if implemented on top of {@link MutableCallSite},\r\napproximately as follows:\r\n<pre>{@code\r\npublic class SwitchPoint {\r\n    private static final MethodHandle\r\n        K_true  = MethodHandles.constant(boolean.class, true),\r\n        K_false = MethodHandles.constant(boolean.class, false);\r\n    private final MutableCallSite mcs;\r\n    private final MethodHandle mcsInvoker;\r\n    public SwitchPoint() {\r\n        this.mcs = new MutableCallSite(K_true);\r\n        this.mcsInvoker = mcs.dynamicInvoker();\r\n    }\r\n    public MethodHandle guardWithTest(\r\n            MethodHandle target, MethodHandle fallback) {\r\n        // Note:  mcsInvoker is of type ()boolean.\r\n        // Target and fallback may take any arguments, but must have the same type.\r\n        return MethodHandles.guardWithTest(this.mcsInvoker, target, fallback);\r\n    }\r\n    public static void invalidateAll(SwitchPoint[] spts) {\r\n        List<MutableCallSite> mcss = new ArrayList<>();\r\n        for (SwitchPoint spt : spts)  mcss.add(spt.mcs);\r\n        for (MutableCallSite mcs : mcss)  mcs.setTarget(K_false);\r\n        MutableCallSite.syncAll(mcss.toArray(new MutableCallSite[0]));\r\n    }\r\n}\r\n}</pre>","inherit":[],"name":"java.lang.invoke.SwitchPoint","type":false},{"description":"","inherit":["jdk.internal.org.objectweb.asm.MethodVisitor"],"name":"java.lang.invoke.TypeConvertingMethodAdapter","type":false},{"description":"A {@code VolatileCallSite} is a {@link CallSite} whose target acts like a volatile variable.\r\nAn {@code invokedynamic} instruction linked to a {@code VolatileCallSite} sees updates\r\nto its call site target immediately, even if the update occurs in another thread.\r\nThere may be a performance penalty for such tight coupling between threads.\r\n<p>\r\nUnlike {@code MutableCallSite}, there is no\r\n{@linkplain MutableCallSite#syncAll syncAll operation} on volatile\r\ncall sites, since every write to a volatile variable is implicitly\r\nsynchronized with reader threads.\r\n<p>\r\nIn other respects, a {@code VolatileCallSite} is interchangeable\r\nwith {@code MutableCallSite}.","inherit":["java.lang.invoke.CallSite"],"name":"java.lang.invoke.VolatileCallSite","type":false},{"description":"Thrown to indicate that code has attempted to call a method handle\r\nvia the wrong method type.  As with the bytecode representation of\r\nnormal Java method calls, method handle calls are strongly typed\r\nto a specific type descriptor associated with a call site.\r\n<p>\r\nThis exception may also be thrown when two method handles are\r\ncomposed, and the system detects that their types cannot be\r\nmatched up correctly.  This amounts to an early evaluation\r\nof the type mismatch, at method handle construction time,\r\ninstead of when the mismatched method handle is called.","inherit":["java.lang.RuntimeException"],"name":"java.lang.invoke.WrongMethodTypeException","type":false},{"description":"Implementing this interface allows an object to be the target of\r\nthe \"for-each loop\" statement. See\r\n<strong>\r\n<a href=\"{@docRoot}/../technotes/guides/language/foreach.html\">For-each Loop</a>\r\n</strong>","inherit":[],"name":"java.lang.Iterable","type":true},{"description":"Subclasses of {@code LinkageError} indicate that a class has\r\nsome dependency on another class; however, the latter class has\r\nincompatibly changed after the compilation of the former class.","inherit":["java.lang.Error"],"name":"java.lang.LinkageError","type":false},{"description":"The {@code Long} class wraps a value of the primitive type {@code\r\nlong} in an object. An object of type {@code Long} contains a\r\nsingle field whose type is {@code long}.\r\n\r\n<p> In addition, this class provides several methods for converting\r\na {@code long} to a {@code String} and a {@code String} to a {@code\r\nlong}, as well as other constants and methods useful when dealing\r\nwith a {@code long}.\r\n\r\n<p>Implementation note: The implementations of the \"bit twiddling\"\r\nmethods (such as {@link #highestOneBit(long) highestOneBit} and\r\n{@link #numberOfTrailingZeros(long) numberOfTrailingZeros}) are\r\nbased on material from Henry S. Warren, Jr.'s <i>Hacker's\r\nDelight</i>, (Addison Wesley, 2002).","inherit":["java.lang.Number","java.lang.Comparable"],"name":"java.lang.Long","type":false},{"description":"","inherit":[],"name":"java.lang.Long.LongCache","type":false},{"description":"The management interface for a buffer pool, for example a pool of\r\n{@link java.nio.ByteBuffer#allocateDirect direct} or {@link\r\njava.nio.MappedByteBuffer mapped} buffers.\r\n\r\n<p> A class implementing this interface is an\r\n{@link javax.management.MXBean}. A Java\r\nvirtual machine has one or more implementations of this interface. The {@link\r\njava.lang.management.ManagementFactory#getPlatformMXBeans getPlatformMXBeans}\r\nmethod can be used to obtain the list of {@code BufferPoolMXBean} objects\r\nrepresenting the management interfaces for pools of buffers as follows:\r\n<pre>\r\n    List&lt;BufferPoolMXBean&gt; pools = ManagementFactory.getPlatformMXBeans(BufferPoolMXBean.class);\r\n</pre>\r\n\r\n<p> The management interfaces are also registered with the platform {@link\r\njavax.management.MBeanServer MBeanServer}. The {@link\r\njavax.management.ObjectName ObjectName} that uniquely identifies the\r\nmanagement interface within the {@code MBeanServer} takes the form:\r\n<pre>\r\n    java.nio:type=BufferPool,name=<i>pool name</i>\r\n</pre>\r\nwhere <em>pool name</em> is the {@link #getName name} of the buffer pool.","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.BufferPoolMXBean","type":true},{"description":"The management interface for the class loading system of\r\nthe Java virtual machine.\r\n\r\n<p> A Java virtual machine has a single instance of the implementation\r\nclass of this interface.  This instance implementing this interface is\r\nan <a href=\"ManagementFactory.html#MXBean\">MXBean</a>\r\nthat can be obtained by calling\r\nthe {@link ManagementFactory#getClassLoadingMXBean} method or\r\nfrom the {@link ManagementFactory#getPlatformMBeanServer\r\nplatform <tt>MBeanServer</tt>}.\r\n\r\n<p>The <tt>ObjectName</tt> for uniquely identifying the MXBean for\r\nthe class loading system within an <tt>MBeanServer</tt> is:\r\n<blockquote>\r\n{@link ManagementFactory#CLASS_LOADING_MXBEAN_NAME\r\n       <tt>java.lang:type=ClassLoading</tt>}\r\n</blockquote>\r\n\r\nIt can be obtained by calling the\r\n{@link PlatformManagedObject#getObjectName} method.","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.ClassLoadingMXBean","type":true},{"description":"The management interface for the compilation system of\r\nthe Java virtual machine.\r\n\r\n<p> A Java virtual machine has a single instance of the implementation\r\nclass of this interface.  This instance implementing this interface is\r\nan <a href=\"ManagementFactory.html#MXBean\">MXBean</a>\r\nthat can be obtained by calling\r\nthe {@link ManagementFactory#getCompilationMXBean} method or\r\nfrom the {@link ManagementFactory#getPlatformMBeanServer\r\nplatform <tt>MBeanServer</tt>} method.\r\n\r\n<p>The <tt>ObjectName</tt> for uniquely identifying the MXBean for\r\nthe compilation system within an MBeanServer is:\r\n<blockquote>\r\n {@link ManagementFactory#COMPILATION_MXBEAN_NAME\r\n        <tt>java.lang:type=Compilation</tt>}\r\n</blockquote>\r\n\r\nIt can be obtained by calling the\r\n{@link PlatformManagedObject#getObjectName} method.","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.CompilationMXBean","type":true},{"description":"The management interface for the garbage collection of\r\nthe Java virtual machine.  Garbage collection is the process\r\nthat the Java virtual machine uses to find and reclaim unreachable\r\nobjects to free up memory space.  A garbage collector is one type of\r\n{@link MemoryManagerMXBean memory manager}.\r\n\r\n<p> A Java virtual machine may have one or more instances of\r\nthe implementation class of this interface.\r\nAn instance implementing this interface is\r\nan <a href=\"ManagementFactory.html#MXBean\">MXBean</a>\r\nthat can be obtained by calling\r\nthe {@link ManagementFactory#getGarbageCollectorMXBeans} method or\r\nfrom the {@link ManagementFactory#getPlatformMBeanServer\r\nplatform <tt>MBeanServer</tt>} method.\r\n\r\n<p>The <tt>ObjectName</tt> for uniquely identifying the MXBean for\r\na garbage collector within an MBeanServer is:\r\n<blockquote>\r\n  {@link ManagementFactory#GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE\r\n   <tt>java.lang:type=GarbageCollector</tt>}<tt>,name=</tt><i>collector's name</i>\r\n</blockquote>\r\n\r\nIt can be obtained by calling the\r\n{@link PlatformManagedObject#getObjectName} method.\r\n\r\nA platform usually includes additional platform-dependent information\r\nspecific to a garbage collection algorithm for monitoring.","inherit":["java.lang.management.MemoryManagerMXBean"],"name":"java.lang.management.GarbageCollectorMXBean","type":true},{"description":"","inherit":[],"name":"java.lang.management.LockInfo","type":false},{"description":"The {@code ManagementFactory} class is a factory class for getting\r\nmanaged beans for the Java platform.\r\nThis class consists of static methods each of which returns\r\none or more <i>platform MXBeans</i> representing\r\nthe management interface of a component of the Java virtual\r\nmachine.\r\n\r\n<h3><a name=\"MXBean\">Platform MXBeans</a></h3>\r\n<p>\r\nA platform MXBean is a <i>managed bean</i> that\r\nconforms to the <a href=\"../../../javax/management/package-summary.html\">JMX</a>\r\nInstrumentation Specification and only uses a set of basic data types.\r\nA JMX management application and the {@linkplain\r\n#getPlatformMBeanServer platform MBeanServer}\r\ncan interoperate without requiring classes for MXBean specific\r\ndata types.\r\nThe data types being transmitted between the JMX connector\r\nserver and the connector client are\r\n{@linkplain javax.management.openmbean.OpenType open types}\r\nand this allows interoperation across versions.\r\nSee <a href=\"../../../javax/management/MXBean.html#MXBean-spec\">\r\nthe specification of MXBeans</a> for details.\r\n\r\n<a name=\"MXBeanNames\"></a>\r\n<p>Each platform MXBean is a {@link PlatformManagedObject}\r\nand it has a unique\r\n{@link javax.management.ObjectName ObjectName} for\r\nregistration in the platform {@code MBeanServer} as returned by\r\nby the {@link PlatformManagedObject#getObjectName getObjectName}\r\nmethod.\r\n\r\n<p>\r\nAn application can access a platform MXBean in the following ways:\r\n<h4>1. Direct access to an MXBean interface</h4>\r\n<blockquote>\r\n<ul>\r\n    <li>Get an MXBean instance by calling the\r\n        {@link #getPlatformMXBean(Class) getPlatformMXBean} or\r\n        {@link #getPlatformMXBeans(Class) getPlatformMXBeans} method\r\n        and access the MXBean locally in the running\r\n        virtual machine.\r\n        </li>\r\n    <li>Construct an MXBean proxy instance that forwards the\r\n        method calls to a given {@link MBeanServer MBeanServer} by calling\r\n        the {@link #getPlatformMXBean(MBeanServerConnection, Class)} or\r\n        {@link #getPlatformMXBeans(MBeanServerConnection, Class)} method.\r\n        The {@link #newPlatformMXBeanProxy newPlatformMXBeanProxy} method\r\n        can also be used to construct an MXBean proxy instance of\r\n        a given {@code ObjectName}.\r\n        A proxy is typically constructed to remotely access\r\n        an MXBean of another running virtual machine.\r\n        </li>\r\n</ul>\r\n<h4>2. Indirect access to an MXBean interface via MBeanServer</h4>\r\n<ul>\r\n    <li>Go through the platform {@code MBeanServer} to access MXBeans\r\n        locally or a specific <tt>MBeanServerConnection</tt> to access\r\n        MXBeans remotely.\r\n        The attributes and operations of an MXBean use only\r\n        <em>JMX open types</em> which include basic data types,\r\n        {@link javax.management.openmbean.CompositeData CompositeData},\r\n        and {@link javax.management.openmbean.TabularData TabularData}\r\n        defined in\r\n        {@link javax.management.openmbean.OpenType OpenType}.\r\n        The mapping is specified in\r\n        the {@linkplain javax.management.MXBean MXBean} specification\r\n        for details.\r\n       </li>\r\n</ul>\r\n</blockquote>\r\n\r\n<p>\r\nThe {@link #getPlatformManagementInterfaces getPlatformManagementInterfaces}\r\nmethod returns all management interfaces supported in the Java virtual machine\r\nincluding the standard management interfaces listed in the tables\r\nbelow as well as the management interfaces extended by the JDK implementation.\r\n<p>\r\nA Java virtual machine has a single instance of the following management\r\ninterfaces:\r\n\r\n<blockquote>\r\n<table border summary=\"The list of Management Interfaces and their single instances\">\r\n<tr>\r\n<th>Management Interface</th>\r\n<th>ObjectName</th>\r\n</tr>\r\n<tr>\r\n<td> {@link ClassLoadingMXBean} </td>\r\n<td> {@link #CLASS_LOADING_MXBEAN_NAME\r\n            java.lang:type=ClassLoading}</td>\r\n</tr>\r\n<tr>\r\n<td> {@link MemoryMXBean} </td>\r\n<td> {@link #MEMORY_MXBEAN_NAME\r\n            java.lang:type=Memory}</td>\r\n</tr>\r\n<tr>\r\n<td> {@link ThreadMXBean} </td>\r\n<td> {@link #THREAD_MXBEAN_NAME\r\n            java.lang:type=Threading}</td>\r\n</tr>\r\n<tr>\r\n<td> {@link RuntimeMXBean} </td>\r\n<td> {@link #RUNTIME_MXBEAN_NAME\r\n            java.lang:type=Runtime}</td>\r\n</tr>\r\n<tr>\r\n<td> {@link OperatingSystemMXBean} </td>\r\n<td> {@link #OPERATING_SYSTEM_MXBEAN_NAME\r\n            java.lang:type=OperatingSystem}</td>\r\n</tr>\r\n<tr>\r\n<td> {@link PlatformLoggingMXBean} </td>\r\n<td> {@link java.util.logging.LogManager#LOGGING_MXBEAN_NAME\r\n            java.util.logging:type=Logging}</td>\r\n</tr>\r\n</table>\r\n</blockquote>\r\n\r\n<p>\r\nA Java virtual machine has zero or a single instance of\r\nthe following management interfaces.\r\n\r\n<blockquote>\r\n<table border summary=\"The list of Management Interfaces and their single instances\">\r\n<tr>\r\n<th>Management Interface</th>\r\n<th>ObjectName</th>\r\n</tr>\r\n<tr>\r\n<td> {@link CompilationMXBean} </td>\r\n<td> {@link #COMPILATION_MXBEAN_NAME\r\n            java.lang:type=Compilation}</td>\r\n</tr>\r\n</table>\r\n</blockquote>\r\n\r\n<p>\r\nA Java virtual machine may have one or more instances of the following\r\nmanagement interfaces.\r\n<blockquote>\r\n<table border summary=\"The list of Management Interfaces and their single instances\">\r\n<tr>\r\n<th>Management Interface</th>\r\n<th>ObjectName</th>\r\n</tr>\r\n<tr>\r\n<td> {@link GarbageCollectorMXBean} </td>\r\n<td> {@link #GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE\r\n            java.lang:type=GarbageCollector}<tt>,name=</tt><i>collector's name</i></td>\r\n</tr>\r\n<tr>\r\n<td> {@link MemoryManagerMXBean} </td>\r\n<td> {@link #MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE\r\n            java.lang:type=MemoryManager}<tt>,name=</tt><i>manager's name</i></td>\r\n</tr>\r\n<tr>\r\n<td> {@link MemoryPoolMXBean} </td>\r\n<td> {@link #MEMORY_POOL_MXBEAN_DOMAIN_TYPE\r\n            java.lang:type=MemoryPool}<tt>,name=</tt><i>pool's name</i></td>\r\n</tr>\r\n<tr>\r\n<td> {@link BufferPoolMXBean} </td>\r\n<td> {@code java.nio:type=BufferPool,name=}<i>pool name</i></td>\r\n</tr>\r\n</table>\r\n</blockquote>","inherit":[],"name":"java.lang.management.ManagementFactory","type":false},{"description":"","inherit":["java.security.BasicPermission"],"name":"java.lang.management.ManagementPermission","type":false},{"description":"The management interface for a memory manager.\r\nA memory manager manages one or more memory pools of the\r\nJava virtual machine.\r\n\r\n<p> A Java virtual machine has one or more memory managers.\r\nAn instance implementing this interface is\r\nan <a href=\"ManagementFactory.html#MXBean\">MXBean</a>\r\nthat can be obtained by calling\r\nthe {@link ManagementFactory#getMemoryManagerMXBeans} method or\r\nfrom the {@link ManagementFactory#getPlatformMBeanServer\r\nplatform <tt>MBeanServer</tt>} method.\r\n\r\n<p>The <tt>ObjectName</tt> for uniquely identifying the MXBean for\r\na memory manager within an MBeanServer is:\r\n<blockquote>\r\n  {@link ManagementFactory#MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE\r\n   <tt>java.lang:type=MemoryManager</tt>}<tt>,name=</tt><i>manager's name</i>\r\n</blockquote>\r\n\r\nIt can be obtained by calling the\r\n{@link PlatformManagedObject#getObjectName} method.","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.MemoryManagerMXBean","type":true},{"description":"The management interface for the memory system of\r\nthe Java virtual machine.\r\n\r\n<p> A Java virtual machine has a single instance of the implementation\r\nclass of this interface.  This instance implementing this interface is\r\nan <a href=\"ManagementFactory.html#MXBean\">MXBean</a>\r\nthat can be obtained by calling\r\nthe {@link ManagementFactory#getMemoryMXBean} method or\r\nfrom the {@link ManagementFactory#getPlatformMBeanServer\r\nplatform <tt>MBeanServer</tt>} method.\r\n\r\n<p>The <tt>ObjectName</tt> for uniquely identifying the MXBean for\r\nthe memory system within an MBeanServer is:\r\n<blockquote>\r\n   {@link ManagementFactory#MEMORY_MXBEAN_NAME\r\n          <tt>java.lang:type=Memory</tt>}\r\n</blockquote>\r\n\r\nIt can be obtained by calling the\r\n{@link PlatformManagedObject#getObjectName} method.\r\n\r\n<h3> Memory </h3>\r\nThe memory system of the Java virtual machine manages\r\nthe following kinds of memory:\r\n\r\n<h3> 1. Heap </h3>\r\nThe Java virtual machine has a <i>heap</i> that is the runtime\r\ndata area from which memory for all class instances and arrays\r\nare allocated.  It is created at the Java virtual machine start-up.\r\nHeap memory for objects is reclaimed by an automatic memory management\r\nsystem which is known as a <i>garbage collector</i>.\r\n\r\n<p>The heap may be of a fixed size or may be expanded and shrunk.\r\nThe memory for the heap does not need to be contiguous.\r\n\r\n<h3> 2. Non-Heap Memory</h3>\r\nThe Java virtual machine manages memory other than the heap\r\n(referred as <i>non-heap memory</i>).\r\n\r\n<p> The Java virtual machine has a <i>method area</i> that is shared\r\namong all threads.\r\nThe method area belongs to non-heap memory.  It stores per-class structures\r\nsuch as a runtime constant pool, field and method data, and the code for\r\nmethods and constructors.  It is created at the Java virtual machine\r\nstart-up.\r\n\r\n<p> The method area is logically part of the heap but a Java virtual\r\nmachine implementation may choose not to either garbage collect\r\nor compact it.  Similar to the heap, the method area may be of a\r\nfixed size or may be expanded and shrunk.  The memory for the\r\nmethod area does not need to be contiguous.\r\n\r\n<p>In addition to the method area, a Java virtual machine\r\nimplementation may require memory for internal processing or\r\noptimization which also belongs to non-heap memory.\r\nFor example, the JIT compiler requires memory for storing the native\r\nmachine code translated from the Java virtual machine code for\r\nhigh performance.\r\n\r\n<h3>Memory Pools and Memory Managers</h3>\r\n{@link MemoryPoolMXBean Memory pools} and\r\n{@link MemoryManagerMXBean memory managers} are the abstract entities\r\nthat monitor and manage the memory system\r\nof the Java virtual machine.\r\n\r\n<p>A memory pool represents a memory area that the Java virtual machine\r\nmanages.  The Java virtual machine has at least one memory pool\r\nand it may create or remove memory pools during execution.\r\nA memory pool can belong to either the heap or the non-heap memory.\r\n\r\n<p>A memory manager is responsible for managing one or more memory pools.\r\nThe garbage collector is one type of memory manager responsible\r\nfor reclaiming memory occupied by unreachable objects.  A Java virtual\r\nmachine may have one or more memory managers.   It may\r\nadd or remove memory managers during execution.\r\nA memory pool can be managed by more than one memory manager.\r\n\r\n<h3>Memory Usage Monitoring</h3>\r\n\r\nMemory usage is a very important monitoring attribute for the memory system.\r\nThe memory usage, for example, could indicate:\r\n<ul>\r\n  <li>the memory usage of an application,</li>\r\n  <li>the workload being imposed on the automatic memory management system,</li>\r\n  <li>potential memory leakage.</li>\r\n</ul>\r\n\r\n<p>\r\nThe memory usage can be monitored in three ways:\r\n<ul>\r\n  <li>Polling</li>\r\n  <li>Usage Threshold Notification</li>\r\n  <li>Collection Usage Threshold Notification</li>\r\n</ul>\r\n\r\nDetails are specified in the {@link MemoryPoolMXBean} interface.\r\n\r\n<p>The memory usage monitoring mechanism is intended for load-balancing\r\nor workload distribution use.  For example, an application would stop\r\nreceiving any new workload when its memory usage exceeds a\r\ncertain threshold. It is not intended for an application to detect\r\nand recover from a low memory condition.\r\n\r\n<h3>Notifications</h3>\r\n\r\n<p>This <tt>MemoryMXBean</tt> is a\r\n{@link javax.management.NotificationEmitter NotificationEmitter}\r\nthat emits two types of memory {@link javax.management.Notification\r\nnotifications} if any one of the memory pools\r\nsupports a <a href=\"MemoryPoolMXBean.html#UsageThreshold\">usage threshold</a>\r\nor a <a href=\"MemoryPoolMXBean.html#CollectionThreshold\">collection usage\r\nthreshold</a> which can be determined by calling the\r\n{@link MemoryPoolMXBean#isUsageThresholdSupported} and\r\n{@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} methods.\r\n<ul>\r\n  <li>{@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED\r\n      usage threshold exceeded notification} - for notifying that\r\n      the memory usage of a memory pool is increased and has reached\r\n      or exceeded its\r\n      <a href=\"MemoryPoolMXBean.html#UsageThreshold\"> usage threshold</a> value.\r\n      </li>\r\n  <li>{@link MemoryNotificationInfo#MEMORY_COLLECTION_THRESHOLD_EXCEEDED\r\n      collection usage threshold exceeded notification} - for notifying that\r\n      the memory usage of a memory pool is greater than or equal to its\r\n      <a href=\"MemoryPoolMXBean.html#CollectionThreshold\">\r\n      collection usage threshold</a> after the Java virtual machine\r\n      has expended effort in recycling unused objects in that\r\n      memory pool.</li>\r\n</ul>\r\n\r\n<p>\r\nThe notification emitted is a {@link javax.management.Notification}\r\ninstance whose {@link javax.management.Notification#setUserData\r\nuser data} is set to a {@link CompositeData CompositeData}\r\nthat represents a {@link MemoryNotificationInfo} object\r\ncontaining information about the memory pool when the notification\r\nwas constructed. The <tt>CompositeData</tt> contains the attributes\r\nas described in {@link MemoryNotificationInfo#from\r\nMemoryNotificationInfo}.\r\n\r\n<hr>\r\n<h3>NotificationEmitter</h3>\r\nThe <tt>MemoryMXBean</tt> object returned by\r\n{@link ManagementFactory#getMemoryMXBean} implements\r\nthe {@link javax.management.NotificationEmitter NotificationEmitter}\r\ninterface that allows a listener to be registered within the\r\n<tt>MemoryMXBean</tt> as a notification listener.\r\n\r\nBelow is an example code that registers a <tt>MyListener</tt> to handle\r\nnotification emitted by the <tt>MemoryMXBean</tt>.\r\n\r\n<blockquote><pre>\r\nclass MyListener implements javax.management.NotificationListener {\r\n    public void handleNotification(Notification notif, Object handback) {\r\n        // handle notification\r\n        ....\r\n    }\r\n}\r\n\r\nMemoryMXBean mbean = ManagementFactory.getMemoryMXBean();\r\nNotificationEmitter emitter = (NotificationEmitter) mbean;\r\nMyListener listener = new MyListener();\r\nemitter.addNotificationListener(listener, null, null);\r\n</pre></blockquote>","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.MemoryMXBean","type":true},{"description":"The information about a memory notification.\r\n\r\n<p>\r\nA memory notification is emitted by {@link MemoryMXBean}\r\nwhen the Java virtual machine detects that the memory usage\r\nof a memory pool is exceeding a threshold value.\r\nThe notification emitted will contain the memory notification\r\ninformation about the detected condition:\r\n<ul>\r\n  <li>The name of the memory pool.</li>\r\n  <li>The memory usage of the memory pool when the notification\r\n      was constructed.</li>\r\n  <li>The number of times that the memory usage has crossed\r\n      a threshold when the notification was constructed.\r\n      For usage threshold notifications, this count will be the\r\n      {@link MemoryPoolMXBean#getUsageThresholdCount usage threshold\r\n      count}.  For collection threshold notifications,\r\n      this count will be the\r\n      {@link MemoryPoolMXBean#getCollectionUsageThresholdCount\r\n      collection usage threshold count}.\r\n      </li>\r\n</ul>\r\n\r\n<p>\r\nA {@link CompositeData CompositeData} representing\r\nthe <tt>MemoryNotificationInfo</tt> object\r\nis stored in the\r\n{@link javax.management.Notification#setUserData user data}\r\nof a {@link javax.management.Notification notification}.\r\nThe {@link #from from} method is provided to convert from\r\na <tt>CompositeData</tt> to a <tt>MemoryNotificationInfo</tt>\r\nobject. For example:\r\n\r\n<blockquote><pre>\r\n     Notification notif;\r\n\r\n     // receive the notification emitted by MemoryMXBean and set to notif\r\n     ...\r\n\r\n     String notifType = notif.getType();\r\n     if (notifType.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED) ||\r\n         notifType.equals(MemoryNotificationInfo.MEMORY_COLLECTION_THRESHOLD_EXCEEDED)) {\r\n         // retrieve the memory notification information\r\n         CompositeData cd = (CompositeData) notif.getUserData();\r\n         MemoryNotificationInfo info = MemoryNotificationInfo.from(cd);\r\n         ....\r\n     }\r\n</pre></blockquote>\r\n\r\n<p>\r\nThe types of notifications emitted by <tt>MemoryMXBean</tt> are:\r\n<ul>\r\n  <li>A {@link #MEMORY_THRESHOLD_EXCEEDED\r\n      usage threshold exceeded notification}.\r\n      <br>This notification will be emitted when\r\n      the memory usage of a memory pool is increased and has reached\r\n      or exceeded its\r\n      <a href=\"MemoryPoolMXBean.html#UsageThreshold\"> usage threshold</a> value.\r\n      Subsequent crossing of the usage threshold value does not cause\r\n      further notification until the memory usage has returned\r\n      to become less than the usage threshold value.\r\n      <p></li>\r\n  <li>A {@link #MEMORY_COLLECTION_THRESHOLD_EXCEEDED\r\n      collection usage threshold exceeded notification}.\r\n      <br>This notification will be emitted when\r\n      the memory usage of a memory pool is greater than or equal to its\r\n      <a href=\"MemoryPoolMXBean.html#CollectionThreshold\">\r\n      collection usage threshold</a> after the Java virtual machine\r\n      has expended effort in recycling unused objects in that\r\n      memory pool.</li>\r\n</ul>","inherit":[],"name":"java.lang.management.MemoryNotificationInfo","type":false},{"description":"The management interface for a memory pool.  A memory pool\r\nrepresents the memory resource managed by the Java virtual machine\r\nand is managed by one or more {@link MemoryManagerMXBean memory managers}.\r\n\r\n<p> A Java virtual machine has one or more instances of the\r\nimplementation class of this interface.  An instance\r\nimplementing this interface is\r\nan <a href=\"ManagementFactory.html#MXBean\">MXBean</a>\r\nthat can be obtained by calling\r\nthe {@link ManagementFactory#getMemoryPoolMXBeans} method or\r\nfrom the {@link ManagementFactory#getPlatformMBeanServer\r\nplatform <tt>MBeanServer</tt>} method.\r\n\r\n<p>The <tt>ObjectName</tt> for uniquely identifying the MXBean for\r\na memory pool within an <tt>MBeanServer</tt> is:\r\n<blockquote>\r\n   {@link ManagementFactory#MEMORY_POOL_MXBEAN_DOMAIN_TYPE\r\n   <tt>java.lang:type=MemoryPool</tt>}<tt>,name=</tt><i>pool's name</i>\r\n</blockquote>\r\n\r\nIt can be obtained by calling the\r\n{@link PlatformManagedObject#getObjectName} method.\r\n\r\n<h3>Memory Type</h3>\r\n<p>The Java virtual machine has a heap for object allocation and also\r\nmaintains non-heap memory for the method area and the Java virtual\r\nmachine execution.  The Java virtual machine can have one or more\r\nmemory pools.  Each memory pool represents a memory area\r\nof one of the following types:\r\n<ul>\r\n  <li>{@link MemoryType#HEAP heap}</li>\r\n  <li>{@link MemoryType#NON_HEAP non-heap}</li>\r\n</ul>\r\n\r\n<h3>Memory Usage Monitoring</h3>\r\n\r\nA memory pool has the following attributes:\r\n<ul>\r\n  <li><a href=\"#Usage\">Memory usage</a></li>\r\n  <li><a href=\"#PeakUsage\">Peak memory usage</a></li>\r\n  <li><a href=\"#UsageThreshold\">Usage Threshold</a></li>\r\n  <li><a href=\"#CollectionThreshold\">Collection Usage Threshold</a>\r\n      (only supported by some <em>garbage-collected</em> memory pools)</li>\r\n</ul>\r\n\r\n<h3><a name=\"Usage\">1. Memory Usage</a></h3>\r\n\r\nThe {@link #getUsage} method provides an estimate\r\nof the current usage of a memory pool.\r\nFor a garbage-collected memory pool, the amount of used memory\r\nincludes the memory occupied by all objects in the pool\r\nincluding both <em>reachable</em> and <em>unreachable</em> objects.\r\n\r\n<p>In general, this method is a lightweight operation for getting\r\nan approximate memory usage.  For some memory pools, for example,\r\nwhen objects are not packed contiguously, this method may be\r\nan expensive operation that requires some computation to determine\r\nthe current memory usage.  An implementation should document when\r\nthis is the case.\r\n\r\n<h3><a name=\"PeakUsage\">2. Peak Memory Usage</a></h3>\r\n\r\nThe Java virtual machine maintains the peak memory usage of a memory\r\npool since the virtual machine was started or the peak was reset.\r\nThe peak memory usage is returned by the {@link #getPeakUsage} method\r\nand reset by calling the {@link #resetPeakUsage} method.\r\n\r\n<h3><a name=\"UsageThreshold\">3. Usage Threshold</a></h3>\r\n\r\nEach memory pool has a manageable attribute\r\ncalled the <i>usage threshold</i> which has a default value supplied\r\nby the Java virtual machine.  The default value is platform-dependent.\r\nThe usage threshold can be set via the\r\n{@link #setUsageThreshold setUsageThreshold} method.\r\nIf the threshold is set to a positive value, the usage threshold crossing\r\nchecking is enabled in this memory pool.\r\nIf the usage threshold is set to zero, usage\r\nthreshold crossing checking on this memory pool is disabled.\r\nThe {@link MemoryPoolMXBean#isUsageThresholdSupported} method can\r\nbe used to determine if this functionality is supported.\r\n<p>\r\nA Java virtual machine performs usage threshold crossing checking on a\r\nmemory pool basis at its best appropriate time, typically,\r\nat garbage collection time.\r\nEach memory pool maintains a {@link #getUsageThresholdCount\r\nusage threshold count} that will get incremented\r\nevery time when the Java virtual machine\r\ndetects that the memory pool usage is crossing the threshold.\r\n<p>\r\nThis manageable usage threshold attribute is designed for monitoring the\r\nincreasing trend of memory usage with low overhead.\r\nUsage threshold may not be appropriate for some memory pools.\r\nFor example, a generational garbage collector, a common garbage collection\r\nalgorithm used in many Java virtual machine implementations,\r\nmanages two or more generations segregating objects by age.\r\nMost of the objects are allocated in\r\nthe <em>youngest generation</em> (say a nursery memory pool).\r\nThe nursery memory pool is designed to be filled up and\r\ncollecting the nursery memory pool will free most of its memory space\r\nsince it is expected to contain mostly short-lived objects\r\nand mostly are unreachable at garbage collection time.\r\nIn this case, it is more appropriate for the nursery memory pool\r\nnot to support a usage threshold.  In addition,\r\nif the cost of an object allocation\r\nin one memory pool is very low (for example, just atomic pointer exchange),\r\nthe Java virtual machine would probably not support the usage threshold\r\nfor that memory pool since the overhead in comparing the usage with\r\nthe threshold is higher than the cost of object allocation.\r\n\r\n<p>\r\nThe memory usage of the system can be monitored using\r\n<a href=\"#Polling\">polling</a> or\r\n<a href=\"#ThresholdNotification\">threshold notification</a> mechanisms.\r\n\r\n<ol type=\"a\">\r\n  <li><a name=\"Polling\"><b>Polling</b></a>\r\n      <p>\r\n      An application can continuously monitor its memory usage\r\n      by calling either the {@link #getUsage} method for all\r\n      memory pools or the {@link #isUsageThresholdExceeded} method\r\n      for those memory pools that support a usage threshold.\r\n      Below is example code that has a thread dedicated for\r\n      task distribution and processing.  At every interval,\r\n      it will determine if it should receive and process new tasks based\r\n      on its memory usage.  If the memory usage exceeds its usage threshold,\r\n      it will redistribute all outstanding tasks to other VMs and\r\n      stop receiving new tasks until the memory usage returns\r\n      below its usage threshold.\r\n\r\n      <pre>\r\n      // Assume the usage threshold is supported for this pool.\r\n      // Set the threshold to myThreshold above which no new tasks\r\n      // should be taken.\r\n      pool.setUsageThreshold(myThreshold);\r\n      ....\r\n\r\n      boolean lowMemory = false;\r\n      while (true) {\r\n         if (pool.isUsageThresholdExceeded()) {\r\n             // potential low memory, so redistribute tasks to other VMs\r\n             lowMemory = true;\r\n             redistributeTasks();\r\n             // stop receiving new tasks\r\n             stopReceivingTasks();\r\n         } else {\r\n             if (lowMemory) {\r\n                 // resume receiving tasks\r\n                 lowMemory = false;\r\n                 resumeReceivingTasks();\r\n             }\r\n             // processing outstanding task\r\n             ...\r\n         }\r\n         // sleep for sometime\r\n         try {\r\n             Thread.sleep(sometime);\r\n         } catch (InterruptedException e) {\r\n             ...\r\n         }\r\n      }\r\n      </pre>\r\n\r\n<hr>\r\n      The above example does not differentiate the case where\r\n      the memory usage has temporarily dropped below the usage threshold\r\n      from the case where the memory usage remains above the threshold\r\n      between two iterations.  The usage threshold count returned by\r\n      the {@link #getUsageThresholdCount} method\r\n      can be used to determine\r\n      if the memory usage has returned below the threshold\r\n      between two polls.\r\n      <p>\r\n      Below shows another example that takes some action if a\r\n      memory pool is under low memory and ignores the memory usage\r\n      changes during the action processing time.\r\n\r\n      <pre>\r\n      // Assume the usage threshold is supported for this pool.\r\n      // Set the threshold to myThreshold which determines if\r\n      // the application will take some action under low memory condition.\r\n      pool.setUsageThreshold(myThreshold);\r\n\r\n      int prevCrossingCount = 0;\r\n      while (true) {\r\n          // A busy loop to detect when the memory usage\r\n          // has exceeded the threshold.\r\n          while (!pool.isUsageThresholdExceeded() ||\r\n                 pool.getUsageThresholdCount() == prevCrossingCount) {\r\n              try {\r\n                  Thread.sleep(sometime)\r\n              } catch (InterruptException e) {\r\n                  ....\r\n              }\r\n          }\r\n\r\n          // Do some processing such as check for memory usage\r\n          // and issue a warning\r\n          ....\r\n\r\n          // Gets the current threshold count. The busy loop will then\r\n          // ignore any crossing of threshold happens during the processing.\r\n          prevCrossingCount = pool.getUsageThresholdCount();\r\n      }\r\n      </pre><hr>\r\n  </li>\r\n  <li><a name=\"ThresholdNotification\"><b>Usage Threshold Notifications</b></a>\r\n      <p>\r\n      Usage threshold notification will be emitted by {@link MemoryMXBean}.\r\n      When the Java virtual machine detects that the memory usage of\r\n      a memory pool has reached or exceeded the usage threshold\r\n      the virtual machine will trigger the <tt>MemoryMXBean</tt> to emit an\r\n      {@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED\r\n      usage threshold exceeded notification}.\r\n      Another usage threshold exceeded notification will not be\r\n      generated until the usage has fallen below the threshold and\r\n      then exceeded it again.\r\n      <p>\r\n      Below is an example code implementing the same logic as the\r\n      first example above but using the usage threshold notification\r\n      mechanism to detect low memory conditions instead of polling.\r\n      In this example code, upon receiving notification, the notification\r\n      listener notifies another thread to perform the actual action\r\n      such as to redistribute outstanding tasks, stop receiving tasks,\r\n      or resume receiving tasks.\r\n      The <tt>handleNotification</tt> method should be designed to\r\n      do a very minimal amount of work and return without delay to avoid\r\n      causing delay in delivering subsequent notifications.  Time-consuming\r\n      actions should be performed by a separate thread.\r\n      The notification listener may be invoked by multiple threads\r\n      concurrently; so the tasks performed by the listener\r\n      should be properly synchronized.\r\n\r\n      <pre>\r\n      class MyListener implements javax.management.NotificationListener {\r\n           public void handleNotification(Notification notification, Object handback)  {\r\n               String notifType = notification.getType();\r\n               if (notifType.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED)) {\r\n                   // potential low memory, notify another thread\r\n                   // to redistribute outstanding tasks to other VMs\r\n                   // and stop receiving new tasks.\r\n                   lowMemory = true;\r\n                   notifyAnotherThread(lowMemory);\r\n               }\r\n           }\r\n      }\r\n\r\n      // Register MyListener with MemoryMXBean\r\n      MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();\r\n      NotificationEmitter emitter = (NotificationEmitter) mbean;\r\n      MyListener listener = new MyListener();\r\n      emitter.addNotificationListener(listener, null, null);\r\n\r\n      // Assume this pool supports a usage threshold.\r\n      // Set the threshold to myThreshold above which no new tasks\r\n      // should be taken.\r\n      pool.setUsageThreshold(myThreshold);\r\n\r\n      // Usage threshold detection is enabled and notification will be\r\n      // handled by MyListener.  Continue for other processing.\r\n      ....\r\n\r\n      </pre>\r\n<hr>\r\n      <p>\r\n      There is no guarantee about when the <tt>MemoryMXBean</tt> will emit\r\n      a threshold notification and when the notification will be delivered.\r\n      When a notification listener is invoked, the memory usage of\r\n      the memory pool may have crossed the usage threshold more\r\n      than once.\r\n      The {@link MemoryNotificationInfo#getCount} method returns the number\r\n      of times that the memory usage has crossed the usage threshold\r\n      at the point in time when the notification was constructed.\r\n      It can be compared with the current usage threshold count returned\r\n      by the {@link #getUsageThresholdCount} method to determine if\r\n      such situation has occurred.\r\n  </li>\r\n</ol>\r\n\r\n<h3><a name=\"CollectionThreshold\">4. Collection Usage Threshold</a></h3>\r\n\r\nCollection usage threshold is a manageable attribute only applicable\r\nto some garbage-collected memory pools.\r\nAfter a Java virtual machine has expended effort in reclaiming memory\r\nspace by recycling unused objects in a memory pool at garbage collection\r\ntime, some number of bytes in the memory pools that are garbaged\r\ncollected will still be in use.  The collection usage threshold\r\nallows a value to be set for this number of bytes such\r\nthat if the threshold is exceeded,\r\na {@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED\r\ncollection usage threshold exceeded notification}\r\nwill be emitted by the {@link MemoryMXBean}.\r\nIn addition, the {@link #getCollectionUsageThresholdCount\r\ncollection usage threshold count} will then be incremented.\r\n\r\n<p>\r\nThe {@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} method can\r\nbe used to determine if this functionality is supported.\r\n\r\n<p>\r\nA Java virtual machine performs collection usage threshold checking\r\non a memory pool basis.  This checking is enabled if the collection\r\nusage threshold is set to a positive value.\r\nIf the collection usage threshold is set to zero, this checking\r\nis disabled on this memory pool.  Default value is zero.\r\nThe Java virtual machine performs the collection usage threshold\r\nchecking at garbage collection time.\r\n\r\n<p>\r\nSome garbage-collected memory pools may\r\nchoose not to support the collection usage threshold.  For example,\r\na memory pool is only managed by a continuous concurrent garbage\r\ncollector.  Objects can be allocated in this memory pool by some thread\r\nwhile the unused objects are reclaimed by the concurrent garbage\r\ncollector simultaneously.  Unless there is a well-defined\r\ngarbage collection time which is the best appropriate time\r\nto check the memory usage, the collection usage threshold should not\r\nbe supported.\r\n\r\n<p>\r\nThe collection usage threshold is designed for monitoring the memory usage\r\nafter the Java virtual machine has expended effort in reclaiming\r\nmemory space.  The collection usage could also be monitored\r\nby the polling and threshold notification mechanism\r\ndescribed above for the <a href=\"#UsageThreshold\">usage threshold</a>\r\nin a similar fashion.","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.MemoryPoolMXBean","type":true},{"description":"A <tt>MemoryUsage</tt> object represents a snapshot of memory usage.\r\nInstances of the <tt>MemoryUsage</tt> class are usually constructed\r\nby methods that are used to obtain memory usage\r\ninformation about individual memory pool of the Java virtual machine or\r\nthe heap or non-heap memory of the Java virtual machine as a whole.\r\n\r\n<p> A <tt>MemoryUsage</tt> object contains four values:\r\n<table summary=\"Describes the MemoryUsage object content\">\r\n<tr>\r\n<td valign=top> <tt>init</tt> </td>\r\n<td valign=top> represents the initial amount of memory (in bytes) that\r\n     the Java virtual machine requests from the operating system\r\n     for memory management during startup.  The Java virtual machine\r\n     may request additional memory from the operating system and\r\n     may also release memory to the system over time.\r\n     The value of <tt>init</tt> may be undefined.\r\n</td>\r\n</tr>\r\n<tr>\r\n<td valign=top> <tt>used</tt> </td>\r\n<td valign=top> represents the amount of memory currently used (in bytes).\r\n</td>\r\n</tr>\r\n<tr>\r\n<td valign=top> <tt>committed</tt> </td>\r\n<td valign=top> represents the amount of memory (in bytes) that is\r\n     guaranteed to be available for use by the Java virtual machine.\r\n     The amount of committed memory may change over time (increase\r\n     or decrease).  The Java virtual machine may release memory to\r\n     the system and <tt>committed</tt> could be less than <tt>init</tt>.\r\n     <tt>committed</tt> will always be greater than\r\n     or equal to <tt>used</tt>.\r\n</td>\r\n</tr>\r\n<tr>\r\n<td valign=top> <tt>max</tt> </td>\r\n<td valign=top> represents the maximum amount of memory (in bytes)\r\n     that can be used for memory management. Its value may be undefined.\r\n     The maximum amount of memory may change over time if defined.\r\n     The amount of used and committed memory will always be less than\r\n     or equal to <tt>max</tt> if <tt>max</tt> is defined.\r\n     A memory allocation may fail if it attempts to increase the\r\n     used memory such that <tt>used &gt; committed</tt> even\r\n     if <tt>used &lt;= max</tt> would still be true (for example,\r\n     when the system is low on virtual memory).\r\n</td>\r\n</tr>\r\n</table>\r\n\r\nBelow is a picture showing an example of a memory pool:\r\n\r\n<pre>\r\n       +----------------------------------------------+\r\n       +////////////////           |                  +\r\n       +////////////////           |                  +\r\n       +----------------------------------------------+\r\n\r\n       |--------|\r\n          init\r\n       |---------------|\r\n              used\r\n       |---------------------------|\r\n                 committed\r\n       |----------------------------------------------|\r\n                           max\r\n</pre>\r\n\r\n<h3>MXBean Mapping</h3>\r\n<tt>MemoryUsage</tt> is mapped to a {@link CompositeData CompositeData}\r\nwith attributes as specified in the {@link #from from} method.","inherit":[],"name":"java.lang.management.MemoryUsage","type":false},{"description":"Information about an object monitor lock.  An object monitor is locked\r\nwhen entering a synchronization block or method on that object.\r\n\r\n<h3>MXBean Mapping</h3>\r\n<tt>MonitorInfo</tt> is mapped to a {@link CompositeData CompositeData}\r\nwith attributes as specified in\r\nthe {@link #from from} method.","inherit":["java.lang.management.LockInfo"],"name":"java.lang.management.MonitorInfo","type":false},{"description":"The management interface for the operating system on which\r\nthe Java virtual machine is running.\r\n\r\n<p> A Java virtual machine has a single instance of the implementation\r\nclass of this interface.  This instance implementing this interface is\r\nan <a href=\"ManagementFactory.html#MXBean\">MXBean</a>\r\nthat can be obtained by calling\r\nthe {@link ManagementFactory#getOperatingSystemMXBean} method or\r\nfrom the {@link ManagementFactory#getPlatformMBeanServer\r\nplatform <tt>MBeanServer</tt>} method.\r\n\r\n<p>The <tt>ObjectName</tt> for uniquely identifying the MXBean for\r\nthe operating system within an MBeanServer is:\r\n<blockquote>\r\n   {@link ManagementFactory#OPERATING_SYSTEM_MXBEAN_NAME\r\n     <tt>java.lang:type=OperatingSystem</tt>}\r\n</blockquote>\r\n\r\nIt can be obtained by calling the\r\n{@link PlatformManagedObject#getObjectName} method.\r\n\r\n<p> This interface defines several convenient methods for accessing\r\nsystem properties about the operating system on which the Java\r\nvirtual machine is running.","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.OperatingSystemMXBean","type":true},{"description":"A task that returns the MXBeans for a component.","inherit":[],"name":"java.lang.management.PlatformComponent.MXBeanFetcher","type":true},{"description":"The management interface for the {@linkplain java.util.logging logging} facility.\r\n\r\n<p>There is a single global instance of the <tt>PlatformLoggingMXBean</tt>.\r\nThe {@link java.lang.management.ManagementFactory#getPlatformMXBean(Class)\r\nManagementFactory.getPlatformMXBean} method can be used to obtain\r\nthe {@code PlatformLoggingMXBean} object as follows:\r\n<pre>\r\n    PlatformLoggingMXBean logging = ManagementFactory.getPlatformMXBean(PlatformLoggingMXBean.class);\r\n</pre>\r\nThe {@code PlatformLoggingMXBean} object is also registered with the\r\nplatform {@linkplain java.lang.management.ManagementFactory#getPlatformMBeanServer\r\nMBeanServer}.\r\nThe {@link javax.management.ObjectName ObjectName} for uniquely\r\nidentifying the {@code PlatformLoggingMXBean} within an MBeanServer is:\r\n<pre>\r\n     {@link java.util.logging.LogManager#LOGGING_MXBEAN_NAME java.util.logging:type=Logging}\r\n</pre>\r\n\r\n<p>The instance registered in the platform <tt>MBeanServer</tt> with\r\nthis {@code ObjectName} implements all attributes defined by\r\n{@link java.util.logging.LoggingMXBean}.","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.PlatformLoggingMXBean","type":true},{"description":"A platform managed object is a {@linkplain javax.management.MXBean JMX MXBean}\r\nfor monitoring and managing a component in the Java platform.\r\nEach platform managed object has a unique\r\n<a href=\"ManagementFactory.html#MXBean\">object name</a>\r\nfor the {@linkplain ManagementFactory#getPlatformMBeanServer\r\nplatform MBeanServer} access.\r\nAll platform MXBeans will implement this interface.\r\n\r\n<p>\r\nNote:\r\nThe platform MXBean interfaces (i.e. all subinterfaces\r\nof {@code PlatformManagedObject}) are implemented\r\nby the Java platform only.  New methods may be added in these interfaces\r\nin future Java SE releases.\r\nIn addition, this {@code PlatformManagedObject} interface is only\r\nintended for the management interfaces for the platform to extend but\r\nnot for applications.","inherit":[],"name":"java.lang.management.PlatformManagedObject","type":true},{"description":"The management interface for the runtime system of\r\nthe Java virtual machine.\r\n\r\n<p> A Java virtual machine has a single instance of the implementation\r\nclass of this interface.  This instance implementing this interface is\r\nan <a href=\"ManagementFactory.html#MXBean\">MXBean</a>\r\nthat can be obtained by calling\r\nthe {@link ManagementFactory#getRuntimeMXBean} method or\r\nfrom the {@link ManagementFactory#getPlatformMBeanServer\r\nplatform <tt>MBeanServer</tt>} method.\r\n\r\n<p>The <tt>ObjectName</tt> for uniquely identifying the MXBean for\r\nthe runtime system within an MBeanServer is:\r\n<blockquote>\r\n   {@link ManagementFactory#RUNTIME_MXBEAN_NAME\r\n          <tt>java.lang:type=Runtime</tt>}\r\n</blockquote>\r\n\r\nIt can be obtained by calling the\r\n{@link PlatformManagedObject#getObjectName} method.\r\n\r\n<p> This interface defines several convenient methods for accessing\r\nsystem properties about the Java virtual machine.","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.RuntimeMXBean","type":true},{"description":"","inherit":[],"name":"java.lang.management.ThreadInfo","type":false},{"description":"","inherit":["java.lang.management.PlatformManagedObject"],"name":"java.lang.management.ThreadMXBean","type":true},{"description":"","inherit":[],"name":"java.lang.Math","type":false},{"description":"","inherit":[],"name":"java.lang.Math.RandomNumberGeneratorHolder","type":false},{"description":"Thrown if an application tries to create an array with negative size.","inherit":["java.lang.RuntimeException"],"name":"java.lang.NegativeArraySizeException","type":false},{"description":"Thrown if the Java Virtual Machine or a <code>ClassLoader</code> instance\r\ntries to load in the definition of a class (as part of a normal method call\r\nor as part of creating a new instance using the <code>new</code> expression)\r\nand no definition of the class could be found.\r\n<p>\r\nThe searched-for class definition existed when the currently\r\nexecuting class was compiled, but the definition can no longer be\r\nfound.","inherit":["java.lang.LinkageError"],"name":"java.lang.NoClassDefFoundError","type":false},{"description":"Thrown if an application tries to access or modify a specified\r\nfield of an object, and that object no longer has that field.\r\n<p>\r\nNormally, this error is caught by the compiler; this error can\r\nonly occur at run time if the definition of a class has\r\nincompatibly changed.","inherit":["java.lang.IncompatibleClassChangeError"],"name":"java.lang.NoSuchFieldError","type":false},{"description":"Signals that the class doesn't have a field of a specified name.","inherit":["java.lang.ReflectiveOperationException"],"name":"java.lang.NoSuchFieldException","type":false},{"description":"Thrown if an application tries to call a specified method of a\r\nclass (either static or instance), and that class no longer has a\r\ndefinition of that method.\r\n<p>\r\nNormally, this error is caught by the compiler; this error can\r\nonly occur at run time if the definition of a class has\r\nincompatibly changed.","inherit":["java.lang.IncompatibleClassChangeError"],"name":"java.lang.NoSuchMethodError","type":false},{"description":"Thrown when a particular method cannot be found.","inherit":["java.lang.ReflectiveOperationException"],"name":"java.lang.NoSuchMethodException","type":false},{"description":"Thrown when an application attempts to use {@code null} in a\r\ncase where an object is required. These include:\r\n<ul>\r\n<li>Calling the instance method of a {@code null} object.\r\n<li>Accessing or modifying the field of a {@code null} object.\r\n<li>Taking the length of {@code null} as if it were an array.\r\n<li>Accessing or modifying the slots of {@code null} as if it\r\n    were an array.\r\n<li>Throwing {@code null} as if it were a {@code Throwable}\r\n    value.\r\n</ul>\r\n<p>\r\nApplications should throw instances of this class to indicate\r\nother illegal uses of the {@code null} object.\r\n\r\n{@code NullPointerException} objects may be constructed by the\r\nvirtual machine as if {@linkplain Throwable#Throwable(String,\r\nThrowable, boolean, boolean) suppression were disabled and/or the\r\nstack trace was not writable}.","inherit":["java.lang.RuntimeException"],"name":"java.lang.NullPointerException","type":false},{"description":"The abstract class {@code Number} is the superclass of platform\r\nclasses representing numeric values that are convertible to the\r\nprimitive types {@code byte}, {@code double}, {@code float}, {@code\r\nint}, {@code long}, and {@code short}.\r\n\r\nThe specific semantics of the conversion from the numeric value of\r\na particular {@code Number} implementation to a given primitive\r\ntype is defined by the {@code Number} implementation in question.\r\n\r\nFor platform classes, the conversion is often analogous to a\r\nnarrowing primitive conversion or a widening primitive conversion\r\nas defining in <cite>The Java&trade; Language Specification</cite>\r\nfor converting between primitive types.  Therefore, conversions may\r\nlose information about the overall magnitude of a numeric value, may\r\nlose precision, and may even return a result of a different sign\r\nthan the input.\r\n\r\nSee the documentation of a given {@code Number} implementation for\r\nconversion details.","inherit":["java.io.Serializable"],"name":"java.lang.Number","type":false},{"description":"Thrown to indicate that the application has attempted to convert\r\na string to one of the numeric types, but that the string does not\r\nhave the appropriate format.","inherit":["java.lang.IllegalArgumentException"],"name":"java.lang.NumberFormatException","type":false},{"description":"Class {@code Object} is the root of the class hierarchy.\r\nEvery class has {@code Object} as a superclass. All objects,\r\nincluding arrays, implement the methods of this class.","inherit":[],"name":"java.lang.Object","type":false},{"description":"Thrown when the Java Virtual Machine cannot allocate an object\r\nbecause it is out of memory, and no more memory could be made\r\navailable by the garbage collector.\r\n\r\n{@code OutOfMemoryError} objects may be constructed by the virtual\r\nmachine as if {@linkplain Throwable#Throwable(String, Throwable,\r\nboolean, boolean) suppression were disabled and/or the stack trace was not\r\nwritable}.","inherit":["java.lang.VirtualMachineError"],"name":"java.lang.OutOfMemoryError","type":false},{"description":"{@code Package} objects contain version information\r\nabout the implementation and specification of a Java package.\r\nThis versioning information is retrieved and made available\r\nby the {@link ClassLoader} instance that\r\nloaded the class(es).  Typically, it is stored in the manifest that is\r\ndistributed with the classes.\r\n\r\n<p>The set of classes that make up the package may implement a\r\nparticular specification and if so the specification title, version number,\r\nand vendor strings identify that specification.\r\nAn application can ask if the package is\r\ncompatible with a particular version, see the {@link\r\n#isCompatibleWith isCompatibleWith}\r\nmethod for details.\r\n\r\n<p>Specification version numbers use a syntax that consists of nonnegative\r\ndecimal integers separated by periods \".\", for example \"2.0\" or\r\n\"1.2.3.4.5.6.7\".  This allows an extensible number to be used to represent\r\nmajor, minor, micro, etc. versions.  The version specification is described\r\nby the following formal grammar:\r\n<blockquote>\r\n<dl>\r\n<dt><i>SpecificationVersion:</i>\r\n<dd><i>Digits RefinedVersion<sub>opt</sub></i>\r\n\r\n<dt><i>RefinedVersion:</i>\r\n<dd>{@code .} <i>Digits</i>\r\n<dd>{@code .} <i>Digits RefinedVersion</i>\r\n\r\n<dt><i>Digits:</i>\r\n<dd><i>Digit</i>\r\n<dd><i>Digits</i>\r\n\r\n<dt><i>Digit:</i>\r\n<dd>any character for which {@link Character#isDigit} returns {@code true},\r\ne.g. 0, 1, 2, ...\r\n</dl>\r\n</blockquote>\r\n\r\n<p>The implementation title, version, and vendor strings identify an\r\nimplementation and are made available conveniently to enable accurate\r\nreporting of the packages involved when a problem occurs. The contents\r\nall three implementation strings are vendor specific. The\r\nimplementation version strings have no specified syntax and should\r\nonly be compared for equality with desired version identifiers.\r\n\r\n<p>Within each {@code ClassLoader} instance all classes from the same\r\njava package have the same Package object.  The static methods allow a package\r\nto be found by name or the set of all packages known to the current class\r\nloader to be found.","inherit":["java.lang.reflect.AnnotatedElement"],"name":"java.lang.Package","type":false},{"description":"","inherit":[],"name":"","type":false},{"description":"The {@link ProcessBuilder#start()} and\r\n{@link Runtime#exec(String[],String[],File) Runtime.exec}\r\nmethods create a native process and return an instance of a\r\nsubclass of {@code Process} that can be used to control the process\r\nand obtain information about it.  The class {@code Process}\r\nprovides methods for performing input from the process, performing\r\noutput to the process, waiting for the process to complete,\r\nchecking the exit status of the process, and destroying (killing)\r\nthe process.\r\n\r\n<p>The methods that create processes may not work well for special\r\nprocesses on certain native platforms, such as native windowing\r\nprocesses, daemon processes, Win16/DOS processes on Microsoft\r\nWindows, or shell scripts.\r\n\r\n<p>By default, the created subprocess does not have its own terminal\r\nor console.  All its standard I/O (i.e. stdin, stdout, stderr)\r\noperations will be redirected to the parent process, where they can\r\nbe accessed via the streams obtained using the methods\r\n{@link #getOutputStream()},\r\n{@link #getInputStream()}, and\r\n{@link #getErrorStream()}.\r\nThe parent process uses these streams to feed input to and get output\r\nfrom the subprocess.  Because some native platforms only provide\r\nlimited buffer size for standard input and output streams, failure\r\nto promptly write the input stream or read the output stream of\r\nthe subprocess may cause the subprocess to block, or even deadlock.\r\n\r\n<p>Where desired, <a href=\"ProcessBuilder.html#redirect-input\">\r\nsubprocess I/O can also be redirected</a>\r\nusing methods of the {@link ProcessBuilder} class.\r\n\r\n<p>The subprocess is not killed when there are no more references to\r\nthe {@code Process} object, but rather the subprocess\r\ncontinues executing asynchronously.\r\n\r\n<p>There is no requirement that a process represented by a {@code\r\nProcess} object execute asynchronously or concurrently with respect\r\nto the Java process that owns the {@code Process} object.\r\n\r\n<p>As of 1.5, {@link ProcessBuilder#start()} is the preferred way\r\nto create a {@code Process}.","inherit":[],"name":"java.lang.Process","type":false},{"description":"","inherit":[],"name":"java.lang.ProcessBuilder","type":false},{"description":"Implements a <a href=\"#redirect-output\">null input stream</a>.","inherit":["java.io.InputStream"],"name":"java.lang.ProcessBuilder.NullInputStream","type":false},{"description":"Implements a <a href=\"#redirect-input\">null output stream</a>.","inherit":["java.io.OutputStream"],"name":"java.lang.ProcessBuilder.NullOutputStream","type":false},{"description":"Represents a source of subprocess input or a destination of\r\nsubprocess output.\r\n\r\nEach {@code Redirect} instance is one of the following:\r\n\r\n<ul>\r\n<li>the special value {@link #PIPE Redirect.PIPE}\r\n<li>the special value {@link #INHERIT Redirect.INHERIT}\r\n<li>a redirection to read from a file, created by an invocation of\r\n    {@link Redirect#from Redirect.from(File)}\r\n<li>a redirection to write to a file,  created by an invocation of\r\n    {@link Redirect#to Redirect.to(File)}\r\n<li>a redirection to append to a file, created by an invocation of\r\n    {@link Redirect#appendTo Redirect.appendTo(File)}\r\n</ul>\r\n\r\n<p>Each of the above categories has an associated unique\r\n{@link Type Type}.","inherit":[],"name":"java.lang.ProcessBuilder.Redirect","type":false},{"description":"","inherit":["java.util.HashMap"],"name":"java.lang.ProcessEnvironment","type":false},{"description":"","inherit":["java.util.Map.Entry"],"name":"java.lang.ProcessEnvironment.CheckedEntry","type":false},{"description":"","inherit":["java.util.AbstractSet"],"name":"java.lang.ProcessEnvironment.CheckedEntrySet","type":false},{"description":"","inherit":["java.util.AbstractCollection"],"name":"java.lang.ProcessEnvironment.CheckedValues","type":false},{"description":"","inherit":["java.util.AbstractSet"],"name":"java.lang.ProcessEnvironment.CheckedKeySet","type":false},{"description":"","inherit":["java.util.Comparator"],"name":"java.lang.ProcessEnvironment.NameComparator","type":false},{"description":"","inherit":["java.util.Comparator"],"name":"java.lang.ProcessEnvironment.EntryComparator","type":false},{"description":"","inherit":["java.lang.Process"],"name":"java.lang.ProcessImpl","type":false},{"description":"","inherit":[],"name":"java.lang.ProcessImpl.LazyPattern","type":false},{"description":"A <tt>Readable</tt> is a source of characters. Characters from\r\na <tt>Readable</tt> are made available to callers of the read\r\nmethod via a {@link java.nio.CharBuffer CharBuffer}.","inherit":[],"name":"java.lang.Readable","type":true},{"description":"","inherit":["java.lang.ref.FinalReference"],"name":"java.lang.ref.Finalizer","type":false},{"description":"","inherit":["java.lang.Thread"],"name":"java.lang.ref.Finalizer.FinalizerThread","type":false},{"description":"","inherit":[],"name":"java.lang.ref.FinalizerHistogram","type":false},{"description":"","inherit":[],"name":"java.lang.ref.FinalizerHistogram.Entry","type":false},{"description":"Final references, used to implement finalization","inherit":["java.lang.ref.Reference"],"name":"java.lang.ref.FinalReference","type":false},{"description":"","inherit":["java.lang.ref.Reference"],"name":"java.lang.ref.PhantomReference","type":false},{"description":"","inherit":[],"name":"java.lang.ref.Reference","type":false},{"description":"","inherit":[],"name":"java.lang.ref.Reference.Lock","type":false},{"description":"","inherit":["java.lang.Thread"],"name":"java.lang.ref.Reference.ReferenceHandler","type":false},{"description":"","inherit":[],"name":"java.lang.ref.ReferenceQueue","type":false},{"description":"","inherit":["java.lang.ref.ReferenceQueue"],"name":"java.lang.ref.ReferenceQueue.Null","type":false},{"description":"","inherit":[],"name":"java.lang.ref.ReferenceQueue.Lock","type":false},{"description":"","inherit":["java.lang.ref.Reference"],"name":"java.lang.ref.SoftReference","type":false},{"description":"","inherit":["java.lang.ref.Reference"],"name":"java.lang.ref.WeakReference","type":false},{"description":"The AccessibleObject class is the base class for Field, Method and\r\nConstructor objects.  It provides the ability to flag a reflected\r\nobject as suppressing default Java language access control checks\r\nwhen it is used.  The access checks--for public, default (package)\r\naccess, protected, and private members--are performed when Fields,\r\nMethods or Constructors are used to set or get fields, to invoke\r\nmethods, or to create and initialize new instances of classes,\r\nrespectively.\r\n\r\n<p>Setting the {@code accessible} flag in a reflected object\r\npermits sophisticated applications with sufficient privilege, such\r\nas Java Object Serialization or other persistence mechanisms, to\r\nmanipulate objects in a manner that would normally be prohibited.\r\n\r\n<p>By default, a reflected object is <em>not</em> accessible.","inherit":["java.lang.reflect.AnnotatedElement"],"name":"java.lang.reflect.AccessibleObject","type":false},{"description":"{@code AnnotatedArrayType} represents the potentially annotated use of an\r\narray type, whose component type may itself represent the annotated use of a\r\ntype.","inherit":["java.lang.reflect.AnnotatedType"],"name":"java.lang.reflect.AnnotatedArrayType","type":true},{"description":"Represents an annotated element of the program currently running in this\r\nVM.  This interface allows annotations to be read reflectively.  All\r\nannotations returned by methods in this interface are immutable and\r\nserializable. The arrays returned by methods of this interface may be modified\r\nby callers without affecting the arrays returned to other callers.\r\n\r\n<p>The {@link #getAnnotationsByType(Class)} and {@link\r\n#getDeclaredAnnotationsByType(Class)} methods support multiple\r\nannotations of the same type on an element. If the argument to\r\neither method is a repeatable annotation type (JLS 9.6), then the\r\nmethod will \"look through\" a container annotation (JLS 9.7), if\r\npresent, and return any annotations inside the container. Container\r\nannotations may be generated at compile-time to wrap multiple\r\nannotations of the argument type.\r\n\r\n<p>The terms <em>directly present</em>, <em>indirectly present</em>,\r\n<em>present</em>, and <em>associated</em> are used throughout this\r\ninterface to describe precisely which annotations are returned by\r\nmethods:\r\n\r\n<ul>\r\n\r\n<li> An annotation <i>A</i> is <em>directly present</em> on an\r\nelement <i>E</i> if <i>E</i> has a {@code\r\nRuntimeVisibleAnnotations} or {@code\r\nRuntimeVisibleParameterAnnotations} or {@code\r\nRuntimeVisibleTypeAnnotations} attribute, and the attribute\r\ncontains <i>A</i>.\r\n\r\n<li>An annotation <i>A</i> is <em>indirectly present</em> on an\r\nelement <i>E</i> if <i>E</i> has a {@code RuntimeVisibleAnnotations} or\r\n{@code RuntimeVisibleParameterAnnotations} or {@code RuntimeVisibleTypeAnnotations}\r\nattribute, and <i>A</i> 's type is repeatable, and the attribute contains\r\nexactly one annotation whose value element contains <i>A</i> and whose\r\ntype is the containing annotation type of <i>A</i> 's type.\r\n\r\n<li>An annotation <i>A</i> is present on an element <i>E</i> if either:\r\n\r\n<ul>\r\n\r\n<li><i>A</i> is directly present on <i>E</i>; or\r\n\r\n<li>No annotation of <i>A</i> 's type is directly present on\r\n<i>E</i>, and <i>E</i> is a class, and <i>A</i> 's type is\r\ninheritable, and <i>A</i> is present on the superclass of <i>E</i>.\r\n\r\n</ul>\r\n\r\n<li>An annotation <i>A</i> is <em>associated</em> with an element <i>E</i>\r\nif either:\r\n\r\n<ul>\r\n\r\n<li><i>A</i> is directly or indirectly present on <i>E</i>; or\r\n\r\n<li>No annotation of <i>A</i> 's type is directly or indirectly\r\npresent on <i>E</i>, and <i>E</i> is a class, and <i>A</i>'s type\r\nis inheritable, and <i>A</i> is associated with the superclass of\r\n<i>E</i>.\r\n\r\n</ul>\r\n\r\n</ul>\r\n\r\n<p>The table below summarizes which kind of annotation presence\r\ndifferent methods in this interface examine.\r\n\r\n<table border>\r\n<caption>Overview of kind of presence detected by different AnnotatedElement methods</caption>\r\n<tr><th colspan=2></th><th colspan=4>Kind of Presence</th>\r\n<tr><th colspan=2>Method</th><th>Directly Present</th><th>Indirectly Present</th><th>Present</th><th>Associated</th>\r\n<tr><td align=right>{@code T}</td><td>{@link #getAnnotation(Class) getAnnotation(Class&lt;T&gt;)}\r\n<td></td><td></td><td>X</td><td></td>\r\n</tr>\r\n<tr><td align=right>{@code Annotation[]}</td><td>{@link #getAnnotations getAnnotations()}\r\n<td></td><td></td><td>X</td><td></td>\r\n</tr>\r\n<tr><td align=right>{@code T[]}</td><td>{@link #getAnnotationsByType(Class) getAnnotationsByType(Class&lt;T&gt;)}\r\n<td></td><td></td><td></td><td>X</td>\r\n</tr>\r\n<tr><td align=right>{@code T}</td><td>{@link #getDeclaredAnnotation(Class) getDeclaredAnnotation(Class&lt;T&gt;)}\r\n<td>X</td><td></td><td></td><td></td>\r\n</tr>\r\n<tr><td align=right>{@code Annotation[]}</td><td>{@link #getDeclaredAnnotations getDeclaredAnnotations()}\r\n<td>X</td><td></td><td></td><td></td>\r\n</tr>\r\n<tr><td align=right>{@code T[]}</td><td>{@link #getDeclaredAnnotationsByType(Class) getDeclaredAnnotationsByType(Class&lt;T&gt;)}\r\n<td>X</td><td>X</td><td></td><td></td>\r\n</tr>\r\n</table>\r\n\r\n<p>For an invocation of {@code get[Declared]AnnotationsByType( Class <\r\nT >)}, the order of annotations which are directly or indirectly\r\npresent on an element <i>E</i> is computed as if indirectly present\r\nannotations on <i>E</i> are directly present on <i>E</i> in place\r\nof their container annotation, in the order in which they appear in\r\nthe value element of the container annotation.\r\n\r\n<p>There are several compatibility concerns to keep in mind if an\r\nannotation type <i>T</i> is originally <em>not</em> repeatable and\r\nlater modified to be repeatable.\r\n\r\nThe containing annotation type for <i>T</i> is <i>TC</i>.\r\n\r\n<ul>\r\n\r\n<li>Modifying <i>T</i> to be repeatable is source and binary\r\ncompatible with existing uses of <i>T</i> and with existing uses\r\nof <i>TC</i>.\r\n\r\nThat is, for source compatibility, source code with annotations of\r\ntype <i>T</i> or of type <i>TC</i> will still compile. For binary\r\ncompatibility, class files with annotations of type <i>T</i> or of\r\ntype <i>TC</i> (or with other kinds of uses of type <i>T</i> or of\r\ntype <i>TC</i>) will link against the modified version of <i>T</i>\r\nif they linked against the earlier version.\r\n\r\n(An annotation type <i>TC</i> may informally serve as an acting\r\ncontaining annotation type before <i>T</i> is modified to be\r\nformally repeatable. Alternatively, when <i>T</i> is made\r\nrepeatable, <i>TC</i> can be introduced as a new type.)\r\n\r\n<li>If an annotation type <i>TC</i> is present on an element, and\r\n<i>T</i> is modified to be repeatable with <i>TC</i> as its\r\ncontaining annotation type then:\r\n\r\n<ul>\r\n\r\n<li>The change to <i>T</i> is behaviorally compatible with respect\r\nto the {@code get[Declared]Annotation(Class<T>)} (called with an\r\nargument of <i>T</i> or <i>TC</i>) and {@code\r\nget[Declared]Annotations()} methods because the results of the\r\nmethods will not change due to <i>TC</i> becoming the containing\r\nannotation type for <i>T</i>.\r\n\r\n<li>The change to <i>T</i> changes the results of the {@code\r\nget[Declared]AnnotationsByType(Class<T>)} methods called with an\r\nargument of <i>T</i>, because those methods will now recognize an\r\nannotation of type <i>TC</i> as a container annotation for <i>T</i>\r\nand will \"look through\" it to expose annotations of type <i>T</i>.\r\n\r\n</ul>\r\n\r\n<li>If an annotation of type <i>T</i> is present on an\r\nelement and <i>T</i> is made repeatable and more annotations of\r\ntype <i>T</i> are added to the element:\r\n\r\n<ul>\r\n\r\n<li> The addition of the annotations of type <i>T</i> is both\r\nsource compatible and binary compatible.\r\n\r\n<li>The addition of the annotations of type <i>T</i> changes the results\r\nof the {@code get[Declared]Annotation(Class<T>)} methods and {@code\r\nget[Declared]Annotations()} methods, because those methods will now\r\nonly see a container annotation on the element and not see an\r\nannotation of type <i>T</i>.\r\n\r\n<li>The addition of the annotations of type <i>T</i> changes the\r\nresults of the {@code get[Declared]AnnotationsByType(Class<T>)}\r\nmethods, because their results will expose the additional\r\nannotations of type <i>T</i> whereas previously they exposed only a\r\nsingle annotation of type <i>T</i>.\r\n\r\n</ul>\r\n\r\n</ul>\r\n\r\n<p>If an annotation returned by a method in this interface contains\r\n(directly or indirectly) a {@link Class}-valued member referring to\r\na class that is not accessible in this VM, attempting to read the class\r\nby calling the relevant Class-returning method on the returned annotation\r\nwill result in a {@link TypeNotPresentException}.\r\n\r\n<p>Similarly, attempting to read an enum-valued member will result in\r\na {@link EnumConstantNotPresentException} if the enum constant in the\r\nannotation is no longer present in the enum type.\r\n\r\n<p>If an annotation type <i>T</i> is (meta-)annotated with an\r\n{@code @Repeatable} annotation whose value element indicates a type\r\n<i>TC</i>, but <i>TC</i> does not declare a {@code value()} method\r\nwith a return type of <i>T</i>{@code []}, then an exception of type\r\n{@link java.lang.annotation.AnnotationFormatError} is thrown.\r\n\r\n<p>Finally, attempting to read a member whose definition has evolved\r\nincompatibly will result in a {@link\r\njava.lang.annotation.AnnotationTypeMismatchException} or an\r\n{@link java.lang.annotation.IncompleteAnnotationException}.","inherit":[],"name":"java.lang.reflect.AnnotatedElement","type":true},{"description":"{@code AnnotatedParameterizedType} represents the potentially annotated use\r\nof a parameterized type, whose type arguments may themselves represent\r\nannotated uses of types.","inherit":["java.lang.reflect.AnnotatedType"],"name":"java.lang.reflect.AnnotatedParameterizedType","type":true},{"description":"{@code AnnotatedType} represents the potentially annotated use of a type in\r\nthe program currently running in this VM. The use may be of any type in the\r\nJava programming language, including an array type, a parameterized type, a\r\ntype variable, or a wildcard type.","inherit":["java.lang.reflect.AnnotatedElement"],"name":"java.lang.reflect.AnnotatedType","type":true},{"description":"{@code AnnotatedTypeVariable} represents the potentially annotated use of a\r\ntype variable, whose declaration may have bounds which themselves represent\r\nannotated uses of types.","inherit":["java.lang.reflect.AnnotatedType"],"name":"java.lang.reflect.AnnotatedTypeVariable","type":true},{"description":"{@code AnnotatedWildcardType} represents the potentially annotated use of a\r\nwildcard type argument, whose upper or lower bounds may themselves represent\r\nannotated uses of types.","inherit":["java.lang.reflect.AnnotatedType"],"name":"java.lang.reflect.AnnotatedWildcardType","type":true},{"description":"The {@code Array} class provides static methods to dynamically create and\r\naccess Java arrays.\r\n\r\n<p>{@code Array} permits widening conversions to occur during a get or set\r\noperation, but throws an {@code IllegalArgumentException} if a narrowing\r\nconversion would occur.","inherit":[],"name":"java.lang.reflect.Array","type":false},{"description":"{@code Constructor} provides information about, and access to, a single\r\nconstructor for a class.\r\n\r\n<p>{@code Constructor} permits widening conversions to occur when matching the\r\nactual parameters to newInstance() with the underlying\r\nconstructor's formal parameters, but throws an\r\n{@code IllegalArgumentException} if a narrowing conversion would occur.","inherit":["java.lang.reflect.Executable"],"name":"java.lang.reflect.Constructor","type":false},{"description":"A shared superclass for the common functionality of {@link Method}\r\nand {@link Constructor}.","inherit":["java.lang.reflect.AccessibleObject","java.lang.reflect.Member","java.lang.reflect.GenericDeclaration"],"name":"java.lang.reflect.Executable","type":false},{"description":"A {@code Field} provides information about, and dynamic access to, a\r\nsingle field of a class or an interface.  The reflected field may\r\nbe a class (static) field or an instance field.\r\n\r\n<p>A {@code Field} permits widening conversions to occur during a get or\r\nset access operation, but throws an {@code IllegalArgumentException} if a\r\nnarrowing conversion would occur.","inherit":["java.lang.reflect.AccessibleObject","java.lang.reflect.Member"],"name":"java.lang.reflect.Field","type":false},{"description":"{@code GenericArrayType} represents an array type whose component\r\ntype is either a parameterized type or a type variable.","inherit":["java.lang.reflect.Type"],"name":"java.lang.reflect.GenericArrayType","type":true},{"description":"A common interface for all entities that declare type variables.","inherit":["java.lang.reflect.AnnotatedElement"],"name":"java.lang.reflect.GenericDeclaration","type":true},{"description":"Thrown when a syntactically malformed signature attribute is\r\nencountered by a reflective method that needs to interpret the\r\ngeneric signature information for a type, method or constructor.","inherit":["java.lang.ClassFormatError"],"name":"java.lang.reflect.GenericSignatureFormatError","type":false},{"description":"{@code InvocationHandler} is the interface implemented by\r\nthe <i>invocation handler</i> of a proxy instance.\r\n\r\n<p>Each proxy instance has an associated invocation handler.\r\nWhen a method is invoked on a proxy instance, the method\r\ninvocation is encoded and dispatched to the {@code invoke}\r\nmethod of its invocation handler.","inherit":[],"name":"java.lang.reflect.InvocationHandler","type":true},{"description":"InvocationTargetException is a checked exception that wraps\r\nan exception thrown by an invoked method or constructor.\r\n\r\n<p>As of release 1.4, this exception has been retrofitted to conform to\r\nthe general purpose exception-chaining mechanism.  The \"target exception\"\r\nthat is provided at construction time and accessed via the\r\n{@link #getTargetException()} method is now known as the <i>cause</i>,\r\nand may be accessed via the {@link Throwable#getCause()} method,\r\nas well as the aforementioned \"legacy method.\"","inherit":["java.lang.ReflectiveOperationException"],"name":"java.lang.reflect.InvocationTargetException","type":false},{"description":"Thrown when a semantically malformed parameterized type is\r\nencountered by a reflective method that needs to instantiate it.\r\nFor example, if the number of type arguments to a parameterized type\r\nis wrong.","inherit":["java.lang.RuntimeException"],"name":"java.lang.reflect.MalformedParameterizedTypeException","type":false},{"description":"Thrown when {@link java.lang.reflect.Executable#getParameters the\r\njava.lang.reflect package} attempts to read method parameters from\r\na class file and determines that one or more parameters are\r\nmalformed.\r\n\r\n<p>The following is a list of conditions under which this exception\r\ncan be thrown:\r\n<ul>\r\n<li> The number of parameters (parameter_count) is wrong for the method\r\n<li> A constant pool index is out of bounds.\r\n<li> A constant pool index does not refer to a UTF-8 entry\r\n<li> A parameter's name is \"\", or contains an illegal character\r\n<li> The flags field contains an illegal flag (something other than\r\n    FINAL, SYNTHETIC, or MANDATED)\r\n</ul>\r\n\r\nSee {@link java.lang.reflect.Executable#getParameters} for more\r\ninformation.","inherit":["java.lang.RuntimeException"],"name":"java.lang.reflect.MalformedParametersException","type":false},{"description":"Member is an interface that reflects identifying information about\r\na single member (a field or a method) or a constructor.","inherit":[],"name":"java.lang.reflect.Member","type":true},{"description":"A {@code Method} provides information about, and access to, a single method\r\non a class or interface.  The reflected method may be a class method\r\nor an instance method (including an abstract method).\r\n\r\n<p>A {@code Method} permits widening conversions to occur when matching the\r\nactual parameters to invoke with the underlying method's formal\r\nparameters, but it throws an {@code IllegalArgumentException} if a\r\nnarrowing conversion would occur.","inherit":["java.lang.reflect.Executable"],"name":"java.lang.reflect.Method","type":false},{"description":"The Modifier class provides {@code static} methods and\r\nconstants to decode class and member access modifiers.  The sets of\r\nmodifiers are represented as integers with distinct bit positions\r\nrepresenting different modifiers.  The values for the constants\r\nrepresenting the modifiers are taken from the tables in sections 4.1, 4.4, 4.5, and 4.7 of\r\n<cite>The Java&trade; Virtual Machine Specification</cite>.","inherit":[],"name":"java.lang.reflect.Modifier","type":false},{"description":"Information about method parameters.\r\n\r\nA {@code Parameter} provides information about method parameters,\r\nincluding its name and modifiers.  It also provides an alternate\r\nmeans of obtaining attributes for the parameter.","inherit":["java.lang.reflect.AnnotatedElement"],"name":"java.lang.reflect.Parameter","type":false},{"description":"ParameterizedType represents a parameterized type such as\r\nCollection&lt;String&gt;.\r\n\r\n<p>A parameterized type is created the first time it is needed by a\r\nreflective method, as specified in this package. When a\r\nparameterized type p is created, the generic type declaration that\r\np instantiates is resolved, and all type arguments of p are created\r\nrecursively. See {@link java.lang.reflect.TypeVariable\r\nTypeVariable} for details on the creation process for type\r\nvariables. Repeated creation of a parameterized type has no effect.\r\n\r\n<p>Instances of classes that implement this interface must implement\r\nan equals() method that equates any two instances that share the\r\nsame generic type declaration and have equal type parameters.","inherit":["java.lang.reflect.Type"],"name":"java.lang.reflect.ParameterizedType","type":true},{"description":"{@code Proxy} provides static methods for creating dynamic proxy\r\nclasses and instances, and it is also the superclass of all\r\ndynamic proxy classes created by those methods.\r\n\r\n<p>To create a proxy for some interface {@code Foo}:\r\n<pre>\r\n    InvocationHandler handler = new MyInvocationHandler(...);\r\n    Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);\r\n    Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).\r\n                    newInstance(handler);\r\n</pre>\r\nor more simply:\r\n<pre>\r\n    Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),\r\n                                         new Class&lt;?&gt;[] { Foo.class },\r\n                                         handler);\r\n</pre>\r\n\r\n<p>A <i>dynamic proxy class</i> (simply referred to as a <i>proxy\r\nclass</i> below) is a class that implements a list of interfaces\r\nspecified at runtime when the class is created, with behavior as\r\ndescribed below.\r\n\r\nA <i>proxy interface</i> is such an interface that is implemented\r\nby a proxy class.\r\n\r\nA <i>proxy instance</i> is an instance of a proxy class.\r\n\r\nEach proxy instance has an associated <i>invocation handler</i>\r\nobject, which implements the interface {@link InvocationHandler}.\r\nA method invocation on a proxy instance through one of its proxy\r\ninterfaces will be dispatched to the {@link InvocationHandler#invoke\r\ninvoke} method of the instance's invocation handler, passing the proxy\r\ninstance, a {@code java.lang.reflect.Method} object identifying\r\nthe method that was invoked, and an array of type {@code Object}\r\ncontaining the arguments.  The invocation handler processes the\r\nencoded method invocation as appropriate and the result that it\r\nreturns will be returned as the result of the method invocation on\r\nthe proxy instance.\r\n\r\n<p>A proxy class has the following properties:\r\n\r\n<ul>\r\n<li>Proxy classes are <em>public, final, and not abstract</em> if\r\nall proxy interfaces are public.</li>\r\n\r\n<li>Proxy classes are <em>non-public, final, and not abstract</em> if\r\nany of the proxy interfaces is non-public.</li>\r\n\r\n<li>The unqualified name of a proxy class is unspecified.  The space\r\nof class names that begin with the string {@code \"$Proxy\"}\r\nshould be, however, reserved for proxy classes.\r\n\r\n<li>A proxy class extends {@code java.lang.reflect.Proxy}.\r\n\r\n<li>A proxy class implements exactly the interfaces specified at its\r\ncreation, in the same order.\r\n\r\n<li>If a proxy class implements a non-public interface, then it will\r\nbe defined in the same package as that interface.  Otherwise, the\r\npackage of a proxy class is also unspecified.  Note that package\r\nsealing will not prevent a proxy class from being successfully defined\r\nin a particular package at runtime, and neither will classes already\r\ndefined by the same class loader and the same package with particular\r\nsigners.\r\n\r\n<li>Since a proxy class implements all of the interfaces specified at\r\nits creation, invoking {@code getInterfaces} on its\r\n{@code Class} object will return an array containing the same\r\nlist of interfaces (in the order specified at its creation), invoking\r\n{@code getMethods} on its {@code Class} object will return\r\nan array of {@code Method} objects that include all of the\r\nmethods in those interfaces, and invoking {@code getMethod} will\r\nfind methods in the proxy interfaces as would be expected.\r\n\r\n<li>The {@link Proxy#isProxyClass Proxy.isProxyClass} method will\r\nreturn true if it is passed a proxy class-- a class returned by\r\n{@code Proxy.getProxyClass} or the class of an object returned by\r\n{@code Proxy.newProxyInstance}-- and false otherwise.\r\n\r\n<li>The {@code java.security.ProtectionDomain} of a proxy class\r\nis the same as that of system classes loaded by the bootstrap class\r\nloader, such as {@code java.lang.Object}, because the code for a\r\nproxy class is generated by trusted system code.  This protection\r\ndomain will typically be granted\r\n{@code java.security.AllPermission}.\r\n\r\n<li>Each proxy class has one public constructor that takes one argument,\r\nan implementation of the interface {@link InvocationHandler}, to set\r\nthe invocation handler for a proxy instance.  Rather than having to use\r\nthe reflection API to access the public constructor, a proxy instance\r\ncan be also be created by calling the {@link Proxy#newProxyInstance\r\nProxy.newProxyInstance} method, which combines the actions of calling\r\n{@link Proxy#getProxyClass Proxy.getProxyClass} with invoking the\r\nconstructor with an invocation handler.\r\n</ul>\r\n\r\n<p>A proxy instance has the following properties:\r\n\r\n<ul>\r\n<li>Given a proxy instance {@code proxy} and one of the\r\ninterfaces implemented by its proxy class {@code Foo}, the\r\nfollowing expression will return true:\r\n<pre>\r\n    {@code proxy instanceof Foo}\r\n</pre>\r\nand the following cast operation will succeed (rather than throwing\r\na {@code ClassCastException}):\r\n<pre>\r\n    {@code (Foo) proxy}\r\n</pre>\r\n\r\n<li>Each proxy instance has an associated invocation handler, the one\r\nthat was passed to its constructor.  The static\r\n{@link Proxy#getInvocationHandler Proxy.getInvocationHandler} method\r\nwill return the invocation handler associated with the proxy instance\r\npassed as its argument.\r\n\r\n<li>An interface method invocation on a proxy instance will be\r\nencoded and dispatched to the invocation handler's {@link\r\nInvocationHandler#invoke invoke} method as described in the\r\ndocumentation for that method.\r\n\r\n<li>An invocation of the {@code hashCode},\r\n{@code equals}, or {@code toString} methods declared in\r\n{@code java.lang.Object} on a proxy instance will be encoded and\r\ndispatched to the invocation handler's {@code invoke} method in\r\nthe same manner as interface method invocations are encoded and\r\ndispatched, as described above.  The declaring class of the\r\n{@code Method} object passed to {@code invoke} will be\r\n{@code java.lang.Object}.  Other public methods of a proxy\r\ninstance inherited from {@code java.lang.Object} are not\r\noverridden by a proxy class, so invocations of those methods behave\r\nlike they do for instances of {@code java.lang.Object}.\r\n</ul>\r\n\r\n<h3>Methods Duplicated in Multiple Proxy Interfaces</h3>\r\n\r\n<p>When two or more interfaces of a proxy class contain a method with\r\nthe same name and parameter signature, the order of the proxy class's\r\ninterfaces becomes significant.  When such a <i>duplicate method</i>\r\nis invoked on a proxy instance, the {@code Method} object passed\r\nto the invocation handler will not necessarily be the one whose\r\ndeclaring class is assignable from the reference type of the interface\r\nthat the proxy's method was invoked through.  This limitation exists\r\nbecause the corresponding method implementation in the generated proxy\r\nclass cannot determine which interface it was invoked through.\r\nTherefore, when a duplicate method is invoked on a proxy instance,\r\nthe {@code Method} object for the method in the foremost interface\r\nthat contains the method (either directly or inherited through a\r\nsuperinterface) in the proxy class's list of interfaces is passed to\r\nthe invocation handler's {@code invoke} method, regardless of the\r\nreference type through which the method invocation occurred.\r\n\r\n<p>If a proxy interface contains a method with the same name and\r\nparameter signature as the {@code hashCode}, {@code equals},\r\nor {@code toString} methods of {@code java.lang.Object},\r\nwhen such a method is invoked on a proxy instance, the\r\n{@code Method} object passed to the invocation handler will have\r\n{@code java.lang.Object} as its declaring class.  In other words,\r\nthe public, non-final methods of {@code java.lang.Object}\r\nlogically precede all of the proxy interfaces for the determination of\r\nwhich {@code Method} object to pass to the invocation handler.\r\n\r\n<p>Note also that when a duplicate method is dispatched to an\r\ninvocation handler, the {@code invoke} method may only throw\r\nchecked exception types that are assignable to one of the exception\r\ntypes in the {@code throws} clause of the method in <i>all</i> of\r\nthe proxy interfaces that it can be invoked through.  If the\r\n{@code invoke} method throws a checked exception that is not\r\nassignable to any of the exception types declared by the method in one\r\nof the proxy interfaces that it can be invoked through, then an\r\nunchecked {@code UndeclaredThrowableException} will be thrown by\r\nthe invocation on the proxy instance.  This restriction means that not\r\nall of the exception types returned by invoking\r\n{@code getExceptionTypes} on the {@code Method} object\r\npassed to the {@code invoke} method can necessarily be thrown\r\nsuccessfully by the {@code invoke} method.","inherit":["java.io.Serializable"],"name":"java.lang.reflect.Proxy","type":false},{"description":"","inherit":["java.lang.ref.WeakReference"],"name":"java.lang.reflect.Proxy.Key1","type":false},{"description":"","inherit":["java.lang.ref.WeakReference"],"name":"java.lang.reflect.Proxy.Key2","type":false},{"description":"","inherit":[],"name":"java.lang.reflect.Proxy.KeyX","type":false},{"description":"A function that maps an array of interfaces to an optimal key where\r\nClass objects representing interfaces are weakly referenced.","inherit":["java.util.function.BiFunction"],"name":"java.lang.reflect.Proxy.KeyFactory","type":false},{"description":"A factory function that generates, defines and returns the proxy class given\r\nthe ClassLoader and array of interfaces.","inherit":["java.util.function.BiFunction"],"name":"java.lang.reflect.Proxy.ProxyClassFactory","type":false},{"description":"","inherit":["sun.reflect.LangReflectAccess"],"name":"java.lang.reflect.ReflectAccess","type":false},{"description":"The Permission class for reflective operations.\r\n<P>\r\nThe following table\r\nprovides a summary description of what the permission allows,\r\nand discusses the risks of granting code the permission.\r\n\r\n<table border=1 cellpadding=5 summary=\"Table shows permission target name, what the permission allows, and associated risks\">\r\n<tr>\r\n<th>Permission Target Name</th>\r\n<th>What the Permission Allows</th>\r\n<th>Risks of Allowing this Permission</th>\r\n</tr>\r\n\r\n<tr>\r\n  <td>suppressAccessChecks</td>\r\n  <td>ability to suppress the standard Java language access checks\r\n      on fields and methods in a class; allow access not only public members\r\n      but also allow access to default (package) access, protected,\r\n      and private members.</td>\r\n  <td>This is dangerous in that information (possibly confidential) and\r\n      methods normally unavailable would be accessible to malicious code.</td>\r\n</tr>\r\n<tr>\r\n  <td>newProxyInPackage.{package name}</td>\r\n  <td>ability to create a proxy instance in the specified package of which\r\n      the non-public interface that the proxy class implements.</td>\r\n  <td>This gives code access to classes in packages to which it normally\r\n      does not have access and the dynamic proxy class is in the system\r\n      protection domain. Malicious code may use these classes to\r\n      help in its attempt to compromise security in the system.</td>\r\n</tr>\r\n\r\n</table>","inherit":["java.security.BasicPermission"],"name":"java.lang.reflect.ReflectPermission","type":false},{"description":"Type is the common superinterface for all types in the Java\r\nprogramming language. These include raw types, parameterized types,\r\narray types, type variables and primitive types.","inherit":[],"name":"java.lang.reflect.Type","type":true},{"description":"TypeVariable is the common superinterface for type variables of kinds.\r\nA type variable is created the first time it is needed by a reflective\r\nmethod, as specified in this package.  If a type variable t is referenced\r\nby a type (i.e, class, interface or annotation type) T, and T is declared\r\nby the nth enclosing class of T (see JLS 8.1.2), then the creation of t\r\nrequires the resolution (see JVMS 5) of the ith enclosing class of T,\r\nfor i = 0 to n, inclusive. Creating a type variable must not cause the\r\ncreation of its bounds. Repeated creation of a type variable has no effect.\r\n\r\n<p>Multiple objects may be instantiated at run-time to\r\nrepresent a given type variable. Even though a type variable is\r\ncreated only once, this does not imply any requirement to cache\r\ninstances representing the type variable. However, all instances\r\nrepresenting a type variable must be equal() to each other.\r\nAs a consequence, users of type variables must not rely on the identity\r\nof instances of classes implementing this interface.","inherit":["java.lang.reflect.Type","java.lang.reflect.AnnotatedElement"],"name":"java.lang.reflect.TypeVariable","type":true},{"description":"Thrown by a method invocation on a proxy instance if its invocation\r\nhandler's {@link InvocationHandler#invoke invoke} method throws a\r\nchecked exception (a {@code Throwable} that is not assignable\r\nto {@code RuntimeException} or {@code Error}) that\r\nis not assignable to any of the exception types declared in the\r\n{@code throws} clause of the method that was invoked on the\r\nproxy instance and dispatched to the invocation handler.\r\n\r\n<p>An {@code UndeclaredThrowableException} instance contains\r\nthe undeclared checked exception that was thrown by the invocation\r\nhandler, and it can be retrieved with the\r\n{@code getUndeclaredThrowable()} method.\r\n{@code UndeclaredThrowableException} extends\r\n{@code RuntimeException}, so it is an unchecked exception\r\nthat wraps a checked exception.\r\n\r\n<p>As of release 1.4, this exception has been retrofitted to\r\nconform to the general purpose exception-chaining mechanism.  The\r\n\"undeclared checked exception that was thrown by the invocation\r\nhandler\" that may be provided at construction time and accessed via\r\nthe {@link #getUndeclaredThrowable()} method is now known as the\r\n<i>cause</i>, and may be accessed via the {@link\r\nThrowable#getCause()} method, as well as the aforementioned \"legacy\r\nmethod.\"","inherit":["java.lang.RuntimeException"],"name":"java.lang.reflect.UndeclaredThrowableException","type":false},{"description":"Cache mapping pairs of {@code (key, sub-key) -> value}. Keys and values are\r\nweakly but sub-keys are strongly referenced.  Keys are passed directly to\r\n{@link #get} method which also takes a {@code parameter}. Sub-keys are\r\ncalculated from keys and parameters using the {@code subKeyFactory} function\r\npassed to the constructor. Values are calculated from keys and parameters\r\nusing the {@code valueFactory} function passed to the constructor.\r\nKeys can be {@code null} and are compared by identity while sub-keys returned by\r\n{@code subKeyFactory} or values returned by {@code valueFactory}\r\ncan not be null. Sub-keys are compared using their {@link #equals} method.\r\nEntries are expunged from cache lazily on each invocation to {@link #get},\r\n{@link #containsValue} or {@link #size} methods when the WeakReferences to\r\nkeys are cleared. Cleared WeakReferences to individual values don't cause\r\nexpunging, but such entries are logically treated as non-existent and\r\ntrigger re-evaluation of {@code valueFactory} on request for their\r\nkey/subKey.","inherit":[],"name":"java.lang.reflect.WeakCache","type":false},{"description":"A factory {@link Supplier} that implements the lazy synchronized\r\nconstruction of the value and installment of it into the cache.","inherit":["java.util.function.Supplier"],"name":"java.lang.reflect.WeakCache.Factory","type":false},{"description":"Common type of value suppliers that are holding a referent.\r\nThe {@link #equals} and {@link #hashCode} of implementations is defined\r\nto compare the referent by identity.","inherit":["java.util.function.Supplier"],"name":"java.lang.reflect.WeakCache.Value","type":true},{"description":"An optimized {@link Value} used to look-up the value in\r\n{@link WeakCache#containsValue} method so that we are not\r\nconstructing the whole {@link CacheValue} just to look-up the referent.","inherit":["java.lang.reflect.WeakCache.Value"],"name":"java.lang.reflect.WeakCache.LookupValue","type":false},{"description":"A {@link Value} that weakly references the referent.","inherit":["java.lang.ref.WeakReference","java.lang.reflect.WeakCache.Value"],"name":"java.lang.reflect.WeakCache.CacheValue","type":false},{"description":"CacheKey containing a weakly referenced {@code key}. It registers\r\nitself with the {@code refQueue} so that it can be used to expunge\r\nthe entry when the {@link WeakReference} is cleared.","inherit":["java.lang.ref.WeakReference"],"name":"java.lang.reflect.WeakCache.CacheKey","type":false},{"description":"WildcardType represents a wildcard type expression, such as\r\n{@code ?}, {@code ? extends Number}, or {@code ? super Integer}.","inherit":["java.lang.reflect.Type"],"name":"java.lang.reflect.WildcardType","type":true},{"description":"Common superclass of exceptions thrown by reflective operations in\r\ncore reflection.","inherit":["java.lang.Exception"],"name":"java.lang.ReflectiveOperationException","type":false},{"description":"The <code>Runnable</code> interface should be implemented by any\r\nclass whose instances are intended to be executed by a thread. The\r\nclass must define a method of no arguments called <code>run</code>.\r\n<p>\r\nThis interface is designed to provide a common protocol for objects that\r\nwish to execute code while they are active. For example,\r\n<code>Runnable</code> is implemented by class <code>Thread</code>.\r\nBeing active simply means that a thread has been started and has not\r\nyet been stopped.\r\n<p>\r\nIn addition, <code>Runnable</code> provides the means for a class to be\r\nactive while not subclassing <code>Thread</code>. A class that implements\r\n<code>Runnable</code> can run without subclassing <code>Thread</code>\r\nby instantiating a <code>Thread</code> instance and passing itself in\r\nas the target.  In most cases, the <code>Runnable</code> interface should\r\nbe used if you are only planning to override the <code>run()</code>\r\nmethod and no other <code>Thread</code> methods.\r\nThis is important because classes should not be subclassed\r\nunless the programmer intends on modifying or enhancing the fundamental\r\nbehavior of the class.","inherit":[],"name":"java.lang.Runnable","type":true},{"description":"","inherit":[],"name":"java.lang.Runtime","type":false},{"description":"{@code RuntimeException} is the superclass of those\r\nexceptions that can be thrown during the normal operation of the\r\nJava Virtual Machine.\r\n\r\n<p>{@code RuntimeException} and its subclasses are <em>unchecked\r\nexceptions</em>.  Unchecked exceptions do <em>not</em> need to be\r\ndeclared in a method or constructor's {@code throws} clause if they\r\ncan be thrown by the execution of the method or constructor and\r\npropagate outside the method or constructor boundary.","inherit":["java.lang.Exception"],"name":"java.lang.RuntimeException","type":false},{"description":"","inherit":["java.security.BasicPermission"],"name":"java.lang.RuntimePermission","type":false},{"description":"Thrown by the security manager to indicate a security violation.","inherit":["java.lang.RuntimeException"],"name":"java.lang.SecurityException","type":false},{"description":"The security manager is a class that allows\r\napplications to implement a security policy. It allows an\r\napplication to determine, before performing a possibly unsafe or\r\nsensitive operation, what the operation is and whether\r\nit is being attempted in a security context that allows the\r\noperation to be performed. The\r\napplication can allow or disallow the operation.\r\n<p>\r\nThe <code>SecurityManager</code> class contains many methods with\r\nnames that begin with the word <code>check</code>. These methods\r\nare called by various methods in the Java libraries before those\r\nmethods perform certain potentially sensitive operations. The\r\ninvocation of such a <code>check</code> method typically looks like this:\r\n<blockquote><pre>\r\n    SecurityManager security = System.getSecurityManager();\r\n    if (security != null) {\r\n        security.check<i>XXX</i>(argument, &nbsp;.&nbsp;.&nbsp;.&nbsp;);\r\n    }\r\n</pre></blockquote>\r\n<p>\r\nThe security manager is thereby given an opportunity to prevent\r\ncompletion of the operation by throwing an exception. A security\r\nmanager routine simply returns if the operation is permitted, but\r\nthrows a <code>SecurityException</code> if the operation is not\r\npermitted. The only exception to this convention is\r\n<code>checkTopLevelWindow</code>, which returns a\r\n<code>boolean</code> value.\r\n<p>\r\nThe current security manager is set by the\r\n<code>setSecurityManager</code> method in class\r\n<code>System</code>. The current security manager is obtained\r\nby the <code>getSecurityManager</code> method.\r\n<p>\r\nThe special method\r\n{@link SecurityManager#checkPermission(java.security.Permission)}\r\ndetermines whether an access request indicated by a specified\r\npermission should be granted or denied. The\r\ndefault implementation calls\r\n\r\n<pre>\r\n  AccessController.checkPermission(perm);\r\n</pre>\r\n\r\n<p>\r\nIf a requested access is allowed,\r\n<code>checkPermission</code> returns quietly. If denied, a\r\n<code>SecurityException</code> is thrown.\r\n<p>\r\nAs of Java 2 SDK v1.2, the default implementation of each of the other\r\n<code>check</code> methods in <code>SecurityManager</code> is to\r\ncall the <code>SecurityManager checkPermission</code> method\r\nto determine if the calling thread has permission to perform the requested\r\noperation.\r\n<p>\r\nNote that the <code>checkPermission</code> method with\r\njust a single permission argument always performs security checks\r\nwithin the context of the currently executing thread.\r\nSometimes a security check that should be made within a given context\r\nwill actually need to be done from within a\r\n<i>different</i> context (for example, from within a worker thread).\r\nThe {@link SecurityManager#getSecurityContext getSecurityContext} method\r\nand the {@link SecurityManager#checkPermission(java.security.Permission,\r\njava.lang.Object) checkPermission}\r\nmethod that includes a context argument are provided\r\nfor this situation. The\r\n<code>getSecurityContext</code> method returns a \"snapshot\"\r\nof the current calling context. (The default implementation\r\nreturns an AccessControlContext object.) A sample call is\r\nthe following:\r\n\r\n<pre>\r\n  Object context = null;\r\n  SecurityManager sm = System.getSecurityManager();\r\n  if (sm != null) context = sm.getSecurityContext();\r\n</pre>\r\n\r\n<p>\r\nThe <code>checkPermission</code> method\r\nthat takes a context object in addition to a permission\r\nmakes access decisions based on that context,\r\nrather than on that of the current execution thread.\r\nCode within a different context can thus call that method,\r\npassing the permission and the\r\npreviously-saved context object. A sample call, using the\r\nSecurityManager <code>sm</code> obtained as in the previous example,\r\nis the following:\r\n\r\n<pre>\r\n  if (sm != null) sm.checkPermission(permission, context);\r\n</pre>\r\n\r\n<p>Permissions fall into these categories: File, Socket, Net,\r\nSecurity, Runtime, Property, AWT, Reflect, and Serializable.\r\nThe classes managing these various\r\npermission categories are <code>java.io.FilePermission</code>,\r\n<code>java.net.SocketPermission</code>,\r\n<code>java.net.NetPermission</code>,\r\n<code>java.security.SecurityPermission</code>,\r\n<code>java.lang.RuntimePermission</code>,\r\n<code>java.util.PropertyPermission</code>,\r\n<code>java.awt.AWTPermission</code>,\r\n<code>java.lang.reflect.ReflectPermission</code>, and\r\n<code>java.io.SerializablePermission</code>.\r\n\r\n<p>All but the first two (FilePermission and SocketPermission) are\r\nsubclasses of <code>java.security.BasicPermission</code>, which itself\r\nis an abstract subclass of the\r\ntop-level class for permissions, which is\r\n<code>java.security.Permission</code>. BasicPermission defines the\r\nfunctionality needed for all permissions that contain a name\r\nthat follows the hierarchical property naming convention\r\n(for example, \"exitVM\", \"setFactory\", \"queuePrintJob\", etc).\r\nAn asterisk\r\nmay appear at the end of the name, following a \".\", or by itself, to\r\nsignify a wildcard match. For example: \"a.*\" or \"*\" is valid,\r\n\"*a\" or \"a*b\" is not valid.\r\n\r\n<p>FilePermission and SocketPermission are subclasses of the\r\ntop-level class for permissions\r\n(<code>java.security.Permission</code>). Classes like these\r\nthat have a more complicated name syntax than that used by\r\nBasicPermission subclass directly from Permission rather than from\r\nBasicPermission. For example,\r\nfor a <code>java.io.FilePermission</code> object, the permission name is\r\nthe path name of a file (or directory).\r\n\r\n<p>Some of the permission classes have an \"actions\" list that tells\r\nthe actions that are permitted for the object.  For example,\r\nfor a <code>java.io.FilePermission</code> object, the actions list\r\n(such as \"read, write\") specifies which actions are granted for the\r\nspecified file (or for files in the specified directory).\r\n\r\n<p>Other permission classes are for \"named\" permissions -\r\nones that contain a name but no actions list; you either have the\r\nnamed permission or you don't.\r\n\r\n<p>Note: There is also a <code>java.security.AllPermission</code>\r\npermission that implies all permissions. It exists to simplify the work\r\nof system administrators who might need to perform multiple\r\ntasks that require all (or numerous) permissions.\r\n<p>\r\nSee <a href =\"../../../technotes/guides/security/permissions.html\">\r\nPermissions in the JDK</a> for permission-related information.\r\nThis document includes, for example, a table listing the various SecurityManager\r\n<code>check</code> methods and the permission(s) the default\r\nimplementation of each such method requires.\r\nIt also contains a table of all the version 1.2 methods\r\nthat require permissions, and for each such method tells\r\nwhich permission it requires.\r\n<p>\r\nFor more information about <code>SecurityManager</code> changes made in\r\nthe JDK and advice regarding porting of 1.1-style security managers,\r\nsee the <a href=\"../../../technotes/guides/security/index.html\">security documentation</a>.","inherit":[],"name":"java.lang.SecurityManager","type":false},{"description":"The {@code Short} class wraps a value of primitive type {@code\r\nshort} in an object.  An object of type {@code Short} contains a\r\nsingle field whose type is {@code short}.\r\n\r\n<p>In addition, this class provides several methods for converting\r\na {@code short} to a {@code String} and a {@code String} to a\r\n{@code short}, as well as other constants and methods useful when\r\ndealing with a {@code short}.","inherit":["java.lang.Number","java.lang.Comparable"],"name":"java.lang.Short","type":false},{"description":"","inherit":[],"name":"java.lang.Short.ShortCache","type":false},{"description":"","inherit":[],"name":"java.lang.Shutdown","type":false},{"description":"","inherit":[],"name":"java.lang.Shutdown.Lock","type":false},{"description":"Thrown when a stack overflow occurs because an application\r\nrecurses too deeply.","inherit":["java.lang.VirtualMachineError"],"name":"java.lang.StackOverflowError","type":false},{"description":"An element in a stack trace, as returned by {@link\r\nThrowable#getStackTrace()}.  Each element represents a single stack frame.\r\nAll stack frames except for the one at the top of the stack represent\r\na method invocation.  The frame at the top of the stack represents the\r\nexecution point at which the stack trace was generated.  Typically,\r\nthis is the point at which the throwable corresponding to the stack trace\r\nwas created.","inherit":["java.io.Serializable"],"name":"java.lang.StackTraceElement","type":false},{"description":"","inherit":[],"name":"java.lang.StrictMath","type":false},{"description":"","inherit":[],"name":"java.lang.StrictMath.RandomNumberGeneratorHolder","type":false},{"description":"","inherit":["java.io.Serializable","java.lang.Comparable","java.lang.CharSequence"],"name":"java.lang.String","type":false},{"description":"","inherit":["java.util.Comparator","java.io.Serializable"],"name":"java.lang.String.CaseInsensitiveComparator","type":false},{"description":"A thread-safe, mutable sequence of characters.\r\nA string buffer is like a {@link String}, but can be modified. At any\r\npoint in time it contains some particular sequence of characters, but\r\nthe length and content of the sequence can be changed through certain\r\nmethod calls.\r\n<p>\r\nString buffers are safe for use by multiple threads. The methods\r\nare synchronized where necessary so that all the operations on any\r\nparticular instance behave as if they occur in some serial order\r\nthat is consistent with the order of the method calls made by each of\r\nthe individual threads involved.\r\n<p>\r\nThe principal operations on a {@code StringBuffer} are the\r\n{@code append} and {@code insert} methods, which are\r\noverloaded so as to accept data of any type. Each effectively\r\nconverts a given datum to a string and then appends or inserts the\r\ncharacters of that string to the string buffer. The\r\n{@code append} method always adds these characters at the end\r\nof the buffer; the {@code insert} method adds the characters at\r\na specified point.\r\n<p>\r\nFor example, if {@code z} refers to a string buffer object\r\nwhose current contents are {@code \"start\"}, then\r\nthe method call {@code z.append(\"le\")} would cause the string\r\nbuffer to contain {@code \"startle\"}, whereas\r\n{@code z.insert(4, \"le\")} would alter the string buffer to\r\ncontain {@code \"starlet\"}.\r\n<p>\r\nIn general, if sb refers to an instance of a {@code StringBuffer},\r\nthen {@code sb.append(x)} has the same effect as\r\n{@code sb.insert(sb.length(), x)}.\r\n<p>\r\nWhenever an operation occurs involving a source sequence (such as\r\nappending or inserting from a source sequence), this class synchronizes\r\nonly on the string buffer performing the operation, not on the source.\r\nNote that while {@code StringBuffer} is designed to be safe to use\r\nconcurrently from multiple threads, if the constructor or the\r\n{@code append} or {@code insert} operation is passed a source sequence\r\nthat is shared across threads, the calling code must ensure\r\nthat the operation has a consistent and unchanging view of the source\r\nsequence for the duration of the operation.\r\nThis could be satisfied by the caller holding a lock during the\r\noperation's call, by using an immutable source sequence, or by not\r\nsharing the source sequence across threads.\r\n<p>\r\nEvery string buffer has a capacity. As long as the length of the\r\ncharacter sequence contained in the string buffer does not exceed\r\nthe capacity, it is not necessary to allocate a new internal\r\nbuffer array. If the internal buffer overflows, it is\r\nautomatically made larger.\r\n<p>\r\nUnless otherwise noted, passing a {@code null} argument to a constructor\r\nor method in this class will cause a {@link NullPointerException} to be\r\nthrown.\r\n<p>\r\nAs of  release JDK 5, this class has been supplemented with an equivalent\r\nclass designed for use by a single thread, {@link StringBuilder}.  The\r\n{@code StringBuilder} class should generally be used in preference to\r\nthis one, as it supports all of the same operations but it is faster, as\r\nit performs no synchronization.","inherit":["java.lang.AbstractStringBuilder","java.io.Serializable","java.lang.CharSequence"],"name":"java.lang.StringBuffer","type":false},{"description":"A mutable sequence of characters.  This class provides an API compatible\r\nwith {@code StringBuffer}, but with no guarantee of synchronization.\r\nThis class is designed for use as a drop-in replacement for\r\n{@code StringBuffer} in places where the string buffer was being\r\nused by a single thread (as is generally the case).   Where possible,\r\nit is recommended that this class be used in preference to\r\n{@code StringBuffer} as it will be faster under most implementations.\r\n\r\n<p>The principal operations on a {@code StringBuilder} are the\r\n{@code append} and {@code insert} methods, which are\r\noverloaded so as to accept data of any type. Each effectively\r\nconverts a given datum to a string and then appends or inserts the\r\ncharacters of that string to the string builder. The\r\n{@code append} method always adds these characters at the end\r\nof the builder; the {@code insert} method adds the characters at\r\na specified point.\r\n<p>\r\nFor example, if {@code z} refers to a string builder object\r\nwhose current contents are \"{@code start}\", then\r\nthe method call {@code z.append(\"le\")} would cause the string\r\nbuilder to contain \"{@code startle}\", whereas\r\n{@code z.insert(4, \"le\")} would alter the string builder to\r\ncontain \"{@code starlet}\".\r\n<p>\r\nIn general, if sb refers to an instance of a {@code StringBuilder},\r\nthen {@code sb.append(x)} has the same effect as\r\n{@code sb.insert(sb.length(), x)}.\r\n<p>\r\nEvery string builder has a capacity. As long as the length of the\r\ncharacter sequence contained in the string builder does not exceed\r\nthe capacity, it is not necessary to allocate a new internal\r\nbuffer. If the internal buffer overflows, it is automatically made larger.\r\n\r\n<p>Instances of {@code StringBuilder} are not safe for\r\nuse by multiple threads. If such synchronization is required then it is\r\nrecommended that {@link java.lang.StringBuffer} be used.\r\n\r\n<p>Unless otherwise noted, passing a {@code null} argument to a constructor\r\nor method in this class will cause a {@link NullPointerException} to be\r\nthrown.","inherit":["java.lang.AbstractStringBuilder","java.io.Serializable","java.lang.CharSequence"],"name":"java.lang.StringBuilder","type":false},{"description":"","inherit":[],"name":"java.lang.StringCoding","type":false},{"description":"","inherit":[],"name":"java.lang.StringCoding.StringDecoder","type":false},{"description":"","inherit":[],"name":"java.lang.StringCoding.StringEncoder","type":false},{"description":"Thrown by {@code String} methods to indicate that an index\r\nis either negative or greater than the size of the string.  For\r\nsome methods such as the charAt method, this exception also is\r\nthrown when the index is equal to the size of the string.","inherit":["java.lang.IndexOutOfBoundsException"],"name":"java.lang.StringIndexOutOfBoundsException","type":false},{"description":"The <code>System</code> class contains several useful class fields\r\nand methods. It cannot be instantiated.\r\n\r\n<p>Among the facilities provided by the <code>System</code> class\r\nare standard input, standard output, and error output streams;\r\naccess to externally defined properties and environment\r\nvariables; a means of loading files and libraries; and a utility\r\nmethod for quickly copying a portion of an array.","inherit":[],"name":"java.lang.System","type":false},{"description":"","inherit":[],"name":"java.lang.Terminator","type":false},{"description":"A <i>thread</i> is a thread of execution in a program. The Java\r\nVirtual Machine allows an application to have multiple threads of\r\nexecution running concurrently.\r\n<p>\r\nEvery thread has a priority. Threads with higher priority are\r\nexecuted in preference to threads with lower priority. Each thread\r\nmay or may not also be marked as a daemon. When code running in\r\nsome thread creates a new <code>Thread</code> object, the new\r\nthread has its priority initially set equal to the priority of the\r\ncreating thread, and is a daemon thread if and only if the\r\ncreating thread is a daemon.\r\n<p>\r\nWhen a Java Virtual Machine starts up, there is usually a single\r\nnon-daemon thread (which typically calls the method named\r\n<code>main</code> of some designated class). The Java Virtual\r\nMachine continues to execute threads until either of the following\r\noccurs:\r\n<ul>\r\n<li>The <code>exit</code> method of class <code>Runtime</code> has been\r\n    called and the security manager has permitted the exit operation\r\n    to take place.\r\n<li>All threads that are not daemon threads have died, either by\r\n    returning from the call to the <code>run</code> method or by\r\n    throwing an exception that propagates beyond the <code>run</code>\r\n    method.\r\n</ul>\r\n<p>\r\nThere are two ways to create a new thread of execution. One is to\r\ndeclare a class to be a subclass of <code>Thread</code>. This\r\nsubclass should override the <code>run</code> method of class\r\n<code>Thread</code>. An instance of the subclass can then be\r\nallocated and started. For example, a thread that computes primes\r\nlarger than a stated value could be written as follows:\r\n<hr><blockquote><pre>\r\n    class PrimeThread extends Thread {\r\n        long minPrime;\r\n        PrimeThread(long minPrime) {\r\n            this.minPrime = minPrime;\r\n        }\r\n\r\n        public void run() {\r\n            // compute primes larger than minPrime\r\n            &nbsp;.&nbsp;.&nbsp;.\r\n        }\r\n    }\r\n</pre></blockquote><hr>\r\n<p>\r\nThe following code would then create a thread and start it running:\r\n<blockquote><pre>\r\n    PrimeThread p = new PrimeThread(143);\r\n    p.start();\r\n</pre></blockquote>\r\n<p>\r\nThe other way to create a thread is to declare a class that\r\nimplements the <code>Runnable</code> interface. That class then\r\nimplements the <code>run</code> method. An instance of the class can\r\nthen be allocated, passed as an argument when creating\r\n<code>Thread</code>, and started. The same example in this other\r\nstyle looks like the following:\r\n<hr><blockquote><pre>\r\n    class PrimeRun implements Runnable {\r\n        long minPrime;\r\n        PrimeRun(long minPrime) {\r\n            this.minPrime = minPrime;\r\n        }\r\n\r\n        public void run() {\r\n            // compute primes larger than minPrime\r\n            &nbsp;.&nbsp;.&nbsp;.\r\n        }\r\n    }\r\n</pre></blockquote><hr>\r\n<p>\r\nThe following code would then create a thread and start it running:\r\n<blockquote><pre>\r\n    PrimeRun p = new PrimeRun(143);\r\n    new Thread(p).start();\r\n</pre></blockquote>\r\n<p>\r\nEvery thread has a name for identification purposes. More than\r\none thread may have the same name. If a name is not specified when\r\na thread is created, a new name is generated for it.\r\n<p>\r\nUnless otherwise noted, passing a {@code null} argument to a constructor\r\nor method in this class will cause a {@link NullPointerException} to be\r\nthrown.","inherit":["java.lang.Runnable"],"name":"java.lang.Thread","type":false},{"description":"","inherit":[],"name":"java.lang.Thread.Caches","type":false},{"description":"Interface for handlers invoked when a <tt>Thread</tt> abruptly\r\nterminates due to an uncaught exception.\r\n<p>When a thread is about to terminate due to an uncaught exception\r\nthe Java Virtual Machine will query the thread for its\r\n<tt>UncaughtExceptionHandler</tt> using\r\n{@link #getUncaughtExceptionHandler} and will invoke the handler's\r\n<tt>uncaughtException</tt> method, passing the thread and the\r\nexception as arguments.\r\nIf a thread has not had its <tt>UncaughtExceptionHandler</tt>\r\nexplicitly set, then its <tt>ThreadGroup</tt> object acts as its\r\n<tt>UncaughtExceptionHandler</tt>. If the <tt>ThreadGroup</tt> object\r\nhas no\r\nspecial requirements for dealing with the exception, it can forward\r\nthe invocation to the {@linkplain #getDefaultUncaughtExceptionHandler\r\ndefault uncaught exception handler}.","inherit":[],"name":"java.lang.Thread.UncaughtExceptionHandler","type":true},{"description":" Weak key for Class objects.","inherit":["java.lang.ref.WeakReference"],"name":"java.lang.Thread.WeakClassKey","type":false},{"description":"","inherit":["java.lang.Error"],"name":"java.lang.ThreadDeath","type":false},{"description":"","inherit":["java.lang.Thread.UncaughtExceptionHandler"],"name":"java.lang.ThreadGroup","type":false},{"description":"This class provides thread-local variables.  These variables differ from\r\ntheir normal counterparts in that each thread that accesses one (via its\r\n{@code get} or {@code set} method) has its own, independently initialized\r\ncopy of the variable.  {@code ThreadLocal} instances are typically private\r\nstatic fields in classes that wish to associate state with a thread (e.g.,\r\na user ID or Transaction ID).\r\n\r\n<p>For example, the class below generates unique identifiers local to each\r\nthread.\r\nA thread's id is assigned the first time it invokes {@code ThreadId.get()}\r\nand remains unchanged on subsequent calls.\r\n<pre>\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class ThreadId {\r\n    // Atomic integer containing the next thread ID to be assigned\r\n    private static final AtomicInteger nextId = new AtomicInteger(0);\r\n\r\n    // Thread local variable containing each thread's ID\r\n    private static final ThreadLocal&lt;Integer&gt; threadId =\r\n        new ThreadLocal&lt;Integer&gt;() {\r\n            &#64;Override protected Integer initialValue() {\r\n                return nextId.getAndIncrement();\r\n        }\r\n    };\r\n\r\n    // Returns the current thread's unique ID, assigning it if necessary\r\n    public static int get() {\r\n        return threadId.get();\r\n    }\r\n}\r\n</pre>\r\n<p>Each thread holds an implicit reference to its copy of a thread-local\r\nvariable as long as the thread is alive and the {@code ThreadLocal}\r\ninstance is accessible; after a thread goes away, all of its copies of\r\nthread-local instances are subject to garbage collection (unless other\r\nreferences to these copies exist).","inherit":[],"name":"java.lang.ThreadLocal","type":false},{"description":"An extension of ThreadLocal that obtains its initial value from\r\nthe specified {@code Supplier}.","inherit":["java.lang.ThreadLocal"],"name":"java.lang.ThreadLocal.SuppliedThreadLocal","type":false},{"description":"ThreadLocalMap is a customized hash map suitable only for\r\nmaintaining thread local values. No operations are exported\r\noutside of the ThreadLocal class. The class is package private to\r\nallow declaration of fields in class Thread.  To help deal with\r\nvery large and long-lived usages, the hash table entries use\r\nWeakReferences for keys. However, since reference queues are not\r\nused, stale entries are guaranteed to be removed only when\r\nthe table starts running out of space.","inherit":[],"name":"java.lang.ThreadLocal.ThreadLocalMap","type":false},{"description":"The entries in this hash map extend WeakReference, using\r\nits main ref field as the key (which is always a\r\nThreadLocal object).  Note that null keys (i.e. entry.get()\r\n== null) mean that the key is no longer referenced, so the\r\nentry can be expunged from table.  Such entries are referred to\r\nas \"stale entries\" in the code that follows.","inherit":["java.lang.ref.WeakReference"],"name":"java.lang.ThreadLocal.ThreadLocalMap.Entry","type":false},{"description":"The {@code Throwable} class is the superclass of all errors and\r\nexceptions in the Java language. Only objects that are instances of this\r\nclass (or one of its subclasses) are thrown by the Java Virtual Machine or\r\ncan be thrown by the Java {@code throw} statement. Similarly, only\r\nthis class or one of its subclasses can be the argument type in a\r\n{@code catch} clause.\r\n\r\nFor the purposes of compile-time checking of exceptions, {@code\r\nThrowable} and any subclass of {@code Throwable} that is not also a\r\nsubclass of either {@link RuntimeException} or {@link Error} are\r\nregarded as checked exceptions.\r\n\r\n<p>Instances of two subclasses, {@link java.lang.Error} and\r\n{@link java.lang.Exception}, are conventionally used to indicate\r\nthat exceptional situations have occurred. Typically, these instances\r\nare freshly created in the context of the exceptional situation so\r\nas to include relevant information (such as stack trace data).\r\n\r\n<p>A throwable contains a snapshot of the execution stack of its\r\nthread at the time it was created. It can also contain a message\r\nstring that gives more information about the error. Over time, a\r\nthrowable can {@linkplain Throwable#addSuppressed suppress} other\r\nthrowables from being propagated.  Finally, the throwable can also\r\ncontain a <i>cause</i>: another throwable that caused this\r\nthrowable to be constructed.  The recording of this causal information\r\nis referred to as the <i>chained exception</i> facility, as the\r\ncause can, itself, have a cause, and so on, leading to a \"chain\" of\r\nexceptions, each caused by another.\r\n\r\n<p>One reason that a throwable may have a cause is that the class that\r\nthrows it is built atop a lower layered abstraction, and an operation on\r\nthe upper layer fails due to a failure in the lower layer.  It would be bad\r\ndesign to let the throwable thrown by the lower layer propagate outward, as\r\nit is generally unrelated to the abstraction provided by the upper layer.\r\nFurther, doing so would tie the API of the upper layer to the details of\r\nits implementation, assuming the lower layer's exception was a checked\r\nexception.  Throwing a \"wrapped exception\" (i.e., an exception containing a\r\ncause) allows the upper layer to communicate the details of the failure to\r\nits caller without incurring either of these shortcomings.  It preserves\r\nthe flexibility to change the implementation of the upper layer without\r\nchanging its API (in particular, the set of exceptions thrown by its\r\nmethods).\r\n\r\n<p>A second reason that a throwable may have a cause is that the method\r\nthat throws it must conform to a general-purpose interface that does not\r\npermit the method to throw the cause directly.  For example, suppose\r\na persistent collection conforms to the {@link java.util.Collection\r\nCollection} interface, and that its persistence is implemented atop\r\n{@code java.io}.  Suppose the internals of the {@code add} method\r\ncan throw an {@link java.io.IOException IOException}.  The implementation\r\ncan communicate the details of the {@code IOException} to its caller\r\nwhile conforming to the {@code Collection} interface by wrapping the\r\n{@code IOException} in an appropriate unchecked exception.  (The\r\nspecification for the persistent collection should indicate that it is\r\ncapable of throwing such exceptions.)\r\n\r\n<p>A cause can be associated with a throwable in two ways: via a\r\nconstructor that takes the cause as an argument, or via the\r\n{@link #initCause(Throwable)} method.  New throwable classes that\r\nwish to allow causes to be associated with them should provide constructors\r\nthat take a cause and delegate (perhaps indirectly) to one of the\r\n{@code Throwable} constructors that takes a cause.\r\n\r\nBecause the {@code initCause} method is public, it allows a cause to be\r\nassociated with any throwable, even a \"legacy throwable\" whose\r\nimplementation predates the addition of the exception chaining mechanism to\r\n{@code Throwable}.\r\n\r\n<p>By convention, class {@code Throwable} and its subclasses have two\r\nconstructors, one that takes no arguments and one that takes a\r\n{@code String} argument that can be used to produce a detail message.\r\nFurther, those subclasses that might likely have a cause associated with\r\nthem should have two more constructors, one that takes a\r\n{@code Throwable} (the cause), and one that takes a\r\n{@code String} (the detail message) and a {@code Throwable} (the\r\ncause).","inherit":["java.io.Serializable"],"name":"java.lang.Throwable","type":false},{"description":"Holder class to defer initializing sentinel objects only used\r\nfor serialization.","inherit":[],"name":"java.lang.Throwable.SentinelHolder","type":false},{"description":"Wrapper class for PrintStream and PrintWriter to enable a single\r\nimplementation of printStackTrace.","inherit":[],"name":"java.lang.Throwable.PrintStreamOrWriter","type":false},{"description":"","inherit":["java.lang.Throwable.PrintStreamOrWriter"],"name":"java.lang.Throwable.WrappedPrintStream","type":false},{"description":"","inherit":["java.lang.Throwable.PrintStreamOrWriter"],"name":"java.lang.Throwable.WrappedPrintWriter","type":false},{"description":"Thrown when an application tries to access a type using a string\r\nrepresenting the type's name, but no definition for the type with\r\nthe specified name can be found.   This exception differs from\r\n{@link ClassNotFoundException} in that <tt>ClassNotFoundException</tt> is a\r\nchecked exception, whereas this exception is unchecked.\r\n\r\n<p>Note that this exception may be used when undefined type variables\r\nare accessed as well as when types (e.g., classes, interfaces or\r\nannotation types) are loaded.\r\nIn particular, this exception can be thrown by the {@linkplain\r\njava.lang.reflect.AnnotatedElement API used to read annotations\r\nreflectively}.","inherit":["java.lang.RuntimeException"],"name":"java.lang.TypeNotPresentException","type":false},{"description":"Thrown when an unknown but serious exception has occurred in the\r\nJava Virtual Machine.","inherit":["java.lang.VirtualMachineError"],"name":"java.lang.UnknownError","type":false},{"description":"Thrown if the Java Virtual Machine cannot find an appropriate\r\nnative-language definition of a method declared <code>native</code>.","inherit":["java.lang.LinkageError"],"name":"java.lang.UnsatisfiedLinkError","type":false},{"description":"Thrown when the Java Virtual Machine attempts to read a class\r\nfile and determines that the major and minor version numbers\r\nin the file are not supported.","inherit":["java.lang.ClassFormatError"],"name":"java.lang.UnsupportedClassVersionError","type":false},{"description":"Thrown to indicate that the requested operation is not supported.<p>\r\n\r\nThis class is a member of the\r\n<a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\r\nJava Collections Framework</a>.","inherit":["java.lang.RuntimeException"],"name":"java.lang.UnsupportedOperationException","type":false},{"description":"Thrown when the \"verifier\" detects that a class file,\r\nthough well formed, contains some sort of internal inconsistency\r\nor security problem.","inherit":["java.lang.LinkageError"],"name":"java.lang.VerifyError","type":false},{"description":"Thrown to indicate that the Java Virtual Machine is broken or has\r\nrun out of resources necessary for it to continue operating.","inherit":["java.lang.Error"],"name":"java.lang.VirtualMachineError","type":false},{"description":"The {@code Void} class is an uninstantiable placeholder class to hold a\r\nreference to the {@code Class} object representing the Java keyword\r\nvoid.","inherit":[],"name":"java.lang.Void","type":false}]